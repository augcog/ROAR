{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ROAR \u00a4","title":"Welcome to ROAR"},{"location":"#welcome-to-roar","text":"","title":"Welcome to ROAR"},{"location":"architecture/","text":"ROAR Carla Overall Architecture \u00a4 Environment Maps \u00a4 Environmental Perception \u00a4 Motion Planning \u00a4 Vehicle Controller \u00a4","title":"Architecture"},{"location":"architecture/#roar-carla-overall-architecture","text":"","title":"ROAR Carla Overall Architecture"},{"location":"architecture/#environment-maps","text":"","title":"Environment Maps"},{"location":"architecture/#environmental-perception","text":"","title":"Environmental Perception"},{"location":"architecture/#motion-planning","text":"","title":"Motion Planning"},{"location":"architecture/#vehicle-controller","text":"","title":"Vehicle Controller"},{"location":"competition_instruction/","text":"Competition Instruction \u00a4 Please visit http://roar.berkeley.edu/","title":"Competition Instruction"},{"location":"competition_instruction/#competition-instruction","text":"Please visit http://roar.berkeley.edu/","title":"Competition Instruction"},{"location":"coordinate/","text":"Coordinate \u00a4 We are using Aruco Marker for defining center of the world. We are using Aruco Marker ID 0 from configuration 5x5, 250 A printable PDF version can be found at https://drive.google.com/file/d/1QtufqHznFYSQKumHuKppixglUSEPIFkc/view?usp=sharing . A cleaner version (recommended) is Localization Module \u00a4 The localization module in ROAR offers the global coordinate of the vehicle at real time with ARUCO Marker and two cameras on the vehicle ( D435i and t265 ). You can check out an introduction and setup instruction video from below: Some other resources include: the slides for the presentation earlier discussion on some features of the t-camera (implementation details)","title":"Coordinate"},{"location":"coordinate/#coordinate","text":"We are using Aruco Marker for defining center of the world. We are using Aruco Marker ID 0 from configuration 5x5, 250 A printable PDF version can be found at https://drive.google.com/file/d/1QtufqHznFYSQKumHuKppixglUSEPIFkc/view?usp=sharing . A cleaner version (recommended) is","title":"Coordinate"},{"location":"coordinate/#localization-module","text":"The localization module in ROAR offers the global coordinate of the vehicle at real time with ARUCO Marker and two cameras on the vehicle ( D435i and t265 ). You can check out an introduction and setup instruction video from below: Some other resources include: the slides for the presentation earlier discussion on some features of the t-camera (implementation details)","title":"Localization Module"},{"location":"faq/","text":"FAQ \u00a4 I did git pull origin main , no updates were made, why? Remember that we are using submodules. If you are trying to update ROAR_Sim / ROAR_Jetson / ROAR_Gym , please understand that they are submodules, and refer to this stackoverflow post Also check if origin is actually pointing to http://www.github.com/YOURUSERNAME if you intended to update your own github Please checkout this document to understand git remotes: https://www.atlassian.com/git/tutorials/syncing","title":"FAQ"},{"location":"faq/#faq","text":"I did git pull origin main , no updates were made, why? Remember that we are using submodules. If you are trying to update ROAR_Sim / ROAR_Jetson / ROAR_Gym , please understand that they are submodules, and refer to this stackoverflow post Also check if origin is actually pointing to http://www.github.com/YOURUSERNAME if you intended to update your own github Please checkout this document to understand git remotes: https://www.atlassian.com/git/tutorials/syncing","title":"FAQ"},{"location":"introduction/","text":"Welcome to ROAR \u00a4 Documentation for ROAR-Simulator \u00a4 Quick Links \u00a4 If you are new to the project visit Quick Start If you are curious about ROAR Competition at Berkeley visit Berkeley ROAR If you are curious about Carla visit Carla Simulator Joining the competition? Read our competition instruction ! For more information regarding DeCal Course visit Roar Decal . Contribute To ROAR Guide \u00a4 Communication \u00a4 Before starting a new contribution, it is important to let the community know what you plan on doing. This serves several purposes. It lets everyone know that you are going to start work on a feature or bug fix so that no one else does the same and duplicates your effort. It lets anyone who may already be working on the feature or bug fix know you intend to work on it, so they can tell you and you don't duplicate their effort. It gives others a chance to provide more information about what the feature or bug fix might need or how it may need to be implemented. You can let the community know by first opening an Issue on Github. An admin will tag a related Pull Request if this is a duplicated issue Documentation Style \u00a4 We use mkdocs and mkdocstrings to automatically generate documentation. This means that we require all Python code documentation to be written in Google Style The recommended method for enabling automatic Google Docstring framework generation is through PyCharm. Here's a tutorial on how to enable this feature in PyCharm Pull Request Style \u00a4 We ask that you fill out the pull request template as indicated in Github, to provide as much details as possible. Issue Style \u00a4 We ask that you fill out the correct issue template as indicated on Github.","title":"Introduction"},{"location":"introduction/#welcome-to-roar","text":"","title":"Welcome to ROAR"},{"location":"introduction/#documentation-for-roar-simulator","text":"","title":"Documentation for ROAR-Simulator"},{"location":"introduction/#quick-links","text":"If you are new to the project visit Quick Start If you are curious about ROAR Competition at Berkeley visit Berkeley ROAR If you are curious about Carla visit Carla Simulator Joining the competition? Read our competition instruction ! For more information regarding DeCal Course visit Roar Decal .","title":"Quick Links"},{"location":"introduction/#contribute-to-roar-guide","text":"","title":"Contribute To ROAR Guide"},{"location":"introduction/#communication","text":"Before starting a new contribution, it is important to let the community know what you plan on doing. This serves several purposes. It lets everyone know that you are going to start work on a feature or bug fix so that no one else does the same and duplicates your effort. It lets anyone who may already be working on the feature or bug fix know you intend to work on it, so they can tell you and you don't duplicate their effort. It gives others a chance to provide more information about what the feature or bug fix might need or how it may need to be implemented. You can let the community know by first opening an Issue on Github. An admin will tag a related Pull Request if this is a duplicated issue","title":"Communication"},{"location":"introduction/#documentation-style","text":"We use mkdocs and mkdocstrings to automatically generate documentation. This means that we require all Python code documentation to be written in Google Style The recommended method for enabling automatic Google Docstring framework generation is through PyCharm. Here's a tutorial on how to enable this feature in PyCharm","title":"Documentation Style"},{"location":"introduction/#pull-request-style","text":"We ask that you fill out the pull request template as indicated in Github, to provide as much details as possible.","title":"Pull Request Style"},{"location":"introduction/#issue-style","text":"We ask that you fill out the correct issue template as indicated on Github.","title":"Issue Style"},{"location":"quickstart/","text":"Note: for Mac users, please dual boot as Windows 10. Fork the Repo Please click the Fork button on the upper right corner and submit a pull request to master branch. For a more in-depth tutorial on recommended setup video clone the repo git clone --recursive https://github.com/YOURUSERNAME/ROAR.git Create virtual environment with python3.7 conda create -n ROAR python=3.7 conda activate ROAR Install Dependency General Dependency pip install -r requirements.txt in the ROAR folder For simulator cd ROAR_Sim pip install -r requirements.txt Download Simulator distribution for your OS Easy map Link Berkeley Minor Link For actual vehicle wired to your computer cd ROAR_Jetson pip install -r requirements.txt For actual vehicle running on Jetson Nano cd ROAR_Jetson sudo apt-get install python-dev libsdl1.2-dev libsdl-image1.2-dev libsdl-mixer1.2-dev libsdl-ttf2.0-dev libsdl1.2-dev libsmpeg-dev python-numpy subversion libportmidi-dev ffmpeg libswscale-dev libavformat-dev libavcodec-dev libfreetype6-dev pip3 install -r requirements_jetson_nano.txt Enjoy For Simulator python runner_sim.py For physical car python runner_jetson.py or python3 runner_jetson.py","title":"Quick Start"},{"location":"code_documentations/runner_sim/","text":"main () \u00a4 Starts game loop Source code in ROAR/runner_sim.py def main (): \"\"\"Starts game loop\"\"\" agent_config = AgentConfig . parse_file ( Path ( \"./ROAR_Sim/configurations/agent_configuration.json\" )) carla_config = CarlaConfig . parse_file ( Path ( \"./ROAR_Sim/configurations/configuration.json\" )) carla_runner = CarlaRunner ( carla_settings = carla_config , agent_settings = agent_config , npc_agent_class = PurePursuitAgent ) try : my_vehicle = carla_runner . set_carla_world () agent = OccupancyMapAgent ( vehicle = my_vehicle , agent_settings = agent_config ) carla_runner . start_game_loop ( agent = agent , use_manual_control = True ) except Exception as e : logging . error ( f \"Something bad happened during initialization: { e } \" ) carla_runner . on_finish () logging . error ( f \" { e } . Might be a good idea to restart Server\" )","title":"Runner Sim"},{"location":"code_documentations/runner_sim/#runner_sim.main","text":"Starts game loop Source code in ROAR/runner_sim.py def main (): \"\"\"Starts game loop\"\"\" agent_config = AgentConfig . parse_file ( Path ( \"./ROAR_Sim/configurations/agent_configuration.json\" )) carla_config = CarlaConfig . parse_file ( Path ( \"./ROAR_Sim/configurations/configuration.json\" )) carla_runner = CarlaRunner ( carla_settings = carla_config , agent_settings = agent_config , npc_agent_class = PurePursuitAgent ) try : my_vehicle = carla_runner . set_carla_world () agent = OccupancyMapAgent ( vehicle = my_vehicle , agent_settings = agent_config ) carla_runner . start_game_loop ( agent = agent , use_manual_control = True ) except Exception as e : logging . error ( f \"Something bad happened during initialization: { e } \" ) carla_runner . on_finish () logging . error ( f \" { e } . Might be a good idea to restart Server\" )","title":"main()"},{"location":"code_documentations/Bridges/bridges/","text":"This file defines a basic Bridge for extensibility of the ROAR Autonomous software Bridge \u00a4 __init__ ( self ) special \u00a4 Source code in Bridges/bridge.py def __init__ ( self ): self . logger = logging . Logger ( __name__ ) convert_control_from_agent_to_source ( self , control ) \u00a4 Source code in Bridges/bridge.py @abstractmethod def convert_control_from_agent_to_source ( self , control : VehicleControl ) -> Any : pass convert_control_from_source_to_agent ( self , source ) \u00a4 Source code in Bridges/bridge.py @abstractmethod def convert_control_from_source_to_agent ( self , source ) -> VehicleControl : pass convert_depth_from_source_to_agent ( self , source ) \u00a4 Source code in Bridges/bridge.py @abstractmethod def convert_depth_from_source_to_agent ( self , source ) -> DepthData : pass convert_imu_from_source_to_agent ( self , source ) \u00a4 Source code in Bridges/bridge.py @abstractmethod def convert_imu_from_source_to_agent ( self , source ) -> IMUData : pass convert_location_from_source_to_agent ( self , source ) \u00a4 Source code in Bridges/bridge.py @abstractmethod def convert_location_from_source_to_agent ( self , source ) -> Location : pass convert_rgb_from_source_to_agent ( self , source ) \u00a4 Source code in Bridges/bridge.py @abstractmethod def convert_rgb_from_source_to_agent ( self , source ) -> RGBData : pass convert_rotation_from_source_to_agent ( self , source ) \u00a4 Source code in Bridges/bridge.py @abstractmethod def convert_rotation_from_source_to_agent ( self , source ) -> Rotation : pass convert_sensor_data_from_source_to_agent ( self , source ) \u00a4 Source code in Bridges/bridge.py @abstractmethod def convert_sensor_data_from_source_to_agent ( self , source ) -> SensorsData : pass convert_transform_from_source_to_agent ( self , source ) \u00a4 Source code in Bridges/bridge.py @abstractmethod def convert_transform_from_source_to_agent ( self , source ) -> Transform : pass convert_vector3d_from_agent_to_source ( self , vector3d ) \u00a4 Source code in Bridges/bridge.py @abstractmethod def convert_vector3d_from_agent_to_source ( self , vector3d : Vector3D ) -> Any : pass convert_vector3d_from_source_to_agent ( self , source ) \u00a4 Source code in Bridges/bridge.py @abstractmethod def convert_vector3d_from_source_to_agent ( self , source ) -> Vector3D : pass convert_vehicle_from_source_to_agent ( self , source ) \u00a4 Source code in Bridges/bridge.py @abstractmethod def convert_vehicle_from_source_to_agent ( self , source ) -> Vehicle : pass","title":"Bridge"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge","text":"","title":"Bridge"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge.__init__","text":"Source code in Bridges/bridge.py def __init__ ( self ): self . logger = logging . Logger ( __name__ )","title":"__init__()"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge.convert_control_from_agent_to_source","text":"Source code in Bridges/bridge.py @abstractmethod def convert_control_from_agent_to_source ( self , control : VehicleControl ) -> Any : pass","title":"convert_control_from_agent_to_source()"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge.convert_control_from_source_to_agent","text":"Source code in Bridges/bridge.py @abstractmethod def convert_control_from_source_to_agent ( self , source ) -> VehicleControl : pass","title":"convert_control_from_source_to_agent()"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge.convert_depth_from_source_to_agent","text":"Source code in Bridges/bridge.py @abstractmethod def convert_depth_from_source_to_agent ( self , source ) -> DepthData : pass","title":"convert_depth_from_source_to_agent()"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge.convert_imu_from_source_to_agent","text":"Source code in Bridges/bridge.py @abstractmethod def convert_imu_from_source_to_agent ( self , source ) -> IMUData : pass","title":"convert_imu_from_source_to_agent()"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge.convert_location_from_source_to_agent","text":"Source code in Bridges/bridge.py @abstractmethod def convert_location_from_source_to_agent ( self , source ) -> Location : pass","title":"convert_location_from_source_to_agent()"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge.convert_rgb_from_source_to_agent","text":"Source code in Bridges/bridge.py @abstractmethod def convert_rgb_from_source_to_agent ( self , source ) -> RGBData : pass","title":"convert_rgb_from_source_to_agent()"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge.convert_rotation_from_source_to_agent","text":"Source code in Bridges/bridge.py @abstractmethod def convert_rotation_from_source_to_agent ( self , source ) -> Rotation : pass","title":"convert_rotation_from_source_to_agent()"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge.convert_sensor_data_from_source_to_agent","text":"Source code in Bridges/bridge.py @abstractmethod def convert_sensor_data_from_source_to_agent ( self , source ) -> SensorsData : pass","title":"convert_sensor_data_from_source_to_agent()"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge.convert_transform_from_source_to_agent","text":"Source code in Bridges/bridge.py @abstractmethod def convert_transform_from_source_to_agent ( self , source ) -> Transform : pass","title":"convert_transform_from_source_to_agent()"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge.convert_vector3d_from_agent_to_source","text":"Source code in Bridges/bridge.py @abstractmethod def convert_vector3d_from_agent_to_source ( self , vector3d : Vector3D ) -> Any : pass","title":"convert_vector3d_from_agent_to_source()"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge.convert_vector3d_from_source_to_agent","text":"Source code in Bridges/bridge.py @abstractmethod def convert_vector3d_from_source_to_agent ( self , source ) -> Vector3D : pass","title":"convert_vector3d_from_source_to_agent()"},{"location":"code_documentations/Bridges/bridges/#Bridges.bridge.Bridge.convert_vehicle_from_source_to_agent","text":"Source code in Bridges/bridge.py @abstractmethod def convert_vehicle_from_source_to_agent ( self , source ) -> Vehicle : pass","title":"convert_vehicle_from_source_to_agent()"},{"location":"code_documentations/Bridges/carla_bridge/","text":"CarlaBridge \u00a4 convert_control_from_agent_to_source ( self , control ) \u00a4 Converts control to carla.VehicleControl Source code in Bridges/carla_bridge.py def convert_control_from_agent_to_source ( self , control : VehicleControl ) -> carla . VehicleControl : \"\"\"Converts control to carla.VehicleControl\"\"\" return carla . VehicleControl ( throttle = abs ( control . throttle ), steer = control . steering , brake = 0 , hand_brake = False , reverse = True if control . throttle < 0 else False , manual_gear_shift = False , gear = 1 , ) convert_control_from_source_to_agent ( self , source ) \u00a4 Convert CARLA raw vehicle control to VehicleControl(throttle,steering). Source code in Bridges/carla_bridge.py def convert_control_from_source_to_agent ( self , source : carla . VehicleControl ) -> VehicleControl : \"\"\"Convert CARLA raw vehicle control to VehicleControl(throttle,steering).\"\"\" return VehicleControl ( throttle =- 1 * source . throttle if source . reverse else source . throttle , steering = source . steer , ) convert_depth_from_source_to_agent ( self , source ) \u00a4 Convert CARLA raw Image to a Union with Depth numpy array. Source code in Bridges/carla_bridge.py def convert_depth_from_source_to_agent ( self , source : carla . Image ) -> Union [ DepthData , None ]: \"\"\"Convert CARLA raw Image to a Union with Depth numpy array.\"\"\" try : array = np . frombuffer ( source . raw_data , dtype = np . dtype ( \"uint8\" )) array = np . reshape ( array , ( source . height , source . width , 4 )) # BGRA array = array [:, :, : 3 ] # BGR array = array [:, :, :: - 1 ] # RGB array = png_to_depth ( array ) return DepthData ( data = array ) except : return None convert_imu_from_source_to_agent ( self , source ) \u00a4 Convert CARLA raw IMUData to IMUData(accelerometer, gyroscope). Source code in Bridges/carla_bridge.py def convert_imu_from_source_to_agent ( self , source : IMUSensor ) -> IMUData : \"\"\"Convert CARLA raw IMUData to IMUData(accelerometer, gyroscope).\"\"\" return IMUData ( accelerometer = Vector3D ( x = source . accelerometer [ 0 ], y = source . accelerometer [ 1 ], z = source . accelerometer [ 2 ], ), gyroscope = Vector3D ( x = source . gyroscope [ 0 ], y = source . gyroscope [ 1 ], z = source . gyroscope [ 2 ] ), ) convert_location_from_agent_to_source ( self , source ) \u00a4 Convert Agent's Location to a Carla.Location. Source code in Bridges/carla_bridge.py def convert_location_from_agent_to_source ( self , source : Location ) -> carla . Location : \"\"\"Convert Agent's Location to a Carla.Location.\"\"\" return carla . Location ( x = source . x , y =- source . z , z = source . y ) convert_location_from_source_to_agent ( self , source ) \u00a4 Convert Location data from Carla.location to Agent's location data type invert the Z axis to make it into right hand coordinate system Parameters: Name Type Description Default source Location carla.location required Returns: Type Description Location Source code in Bridges/carla_bridge.py def convert_location_from_source_to_agent ( self , source : carla . Location ) -> Location : \"\"\" Convert Location data from Carla.location to Agent's location data type invert the Z axis to make it into right hand coordinate system Args: source: carla.location Returns: \"\"\" return Location ( x = source . x , y = source . z , z = source . y ) convert_rgb_from_source_to_agent ( self , source ) \u00a4 Convert CARLA raw Image to a Union with RGB numpy array. Source code in Bridges/carla_bridge.py def convert_rgb_from_source_to_agent ( self , source : carla . Image ) -> Union [ RGBData , None ]: \"\"\"Convert CARLA raw Image to a Union with RGB numpy array.\"\"\" try : source . convert ( cc . Raw ) rgb_image = self . _to_rgb_array ( source ) return RGBData ( data = rgb_image ) except : return None convert_rotation_from_agent_to_source ( self , source ) \u00a4 Convert Agent's Rotation to a Carla.Rotation. Source code in Bridges/carla_bridge.py def convert_rotation_from_agent_to_source ( self , source : Rotation ) -> carla . Rotation : \"\"\"Convert Agent's Rotation to a Carla.Rotation.\"\"\" return carla . Rotation ( pitch = source . yaw , yaw = source . pitch , roll = source . roll ) convert_rotation_from_source_to_agent ( self , source ) \u00a4 Convert a CARLA raw rotation to Rotation(pitch=float,yaw=float,roll=float). Source code in Bridges/carla_bridge.py def convert_rotation_from_source_to_agent ( self , source : carla . Rotation ) -> Rotation : \"\"\"Convert a CARLA raw rotation to Rotation(pitch=float,yaw=float,roll=float).\"\"\" roll , pitch , yaw = source . roll , source . pitch , source . yaw if yaw <= 90 : yaw = yaw + 90 else : yaw = yaw - 270 return Rotation ( roll = roll , pitch = pitch , yaw =- yaw ) convert_sensor_data_from_source_to_agent ( self , source ) \u00a4 Returns CARLA Sensors Data from raw front RGB, rear RGB, front depth, and IMU Data. Source code in Bridges/carla_bridge.py def convert_sensor_data_from_source_to_agent ( self , source : dict ) -> SensorsData : \"\"\"Returns CARLA Sensors Data from raw front RGB, rear RGB, front depth, and IMU Data.\"\"\" return SensorsData ( front_rgb = self . convert_rgb_from_source_to_agent ( source = source . get ( \"front_rgb\" , None ) ), rear_rgb = self . convert_rgb_from_source_to_agent ( source = source . get ( \"rear_rgb\" , None ) ), front_depth = self . convert_depth_from_source_to_agent ( source = source . get ( \"front_depth\" , None ) ), imu_data = self . convert_imu_from_source_to_agent ( source = source . get ( \"imu\" , None ) ), ) convert_transform_from_agent_to_source ( self , source ) \u00a4 Convert Agent's Transform to a Carla.Transform. Source code in Bridges/carla_bridge.py def convert_transform_from_agent_to_source ( self , source : Transform ) -> carla . Transform : \"\"\"Convert Agent's Transform to a Carla.Transform.\"\"\" return carla . Transform ( location = self . convert_location_from_agent_to_source ( source = source . location ), rotation = self . convert_rotation_from_agent_to_source ( source = source . rotation ), ) convert_transform_from_source_to_agent ( self , source ) \u00a4 Convert CARLA raw location and rotation to Transform(location,rotation). Source code in Bridges/carla_bridge.py def convert_transform_from_source_to_agent ( self , source : carla . Transform ) -> Transform : \"\"\"Convert CARLA raw location and rotation to Transform(location,rotation).\"\"\" return Transform ( location = self . convert_location_from_source_to_agent ( source = source . location ), rotation = self . convert_rotation_from_source_to_agent ( source = source . rotation ), ) convert_vector3d_from_agent_to_source ( self , vector3d ) \u00a4 Convert Vector3D Object to a CARLA raw Vector3d Data. Source code in Bridges/carla_bridge.py def convert_vector3d_from_agent_to_source ( self , vector3d : Vector3D ) -> carla . Vector3D : \"\"\"Convert Vector3D Object to a CARLA raw Vector3d Data.\"\"\" return carla . Vector3D ( x = vector3d . x , y = vector3d . y , z = vector3d . z ) convert_vector3d_from_source_to_agent ( self , source ) \u00a4 Convert CARLA raw Vector3d Data to a Vector3D Object. Source code in Bridges/carla_bridge.py def convert_vector3d_from_source_to_agent ( self , source : carla . Vector3D ) -> Vector3D : \"\"\"Convert CARLA raw Vector3d Data to a Vector3D Object.\"\"\" return Vector3D ( x = source . x , y = source . y , z = source . z ) convert_vehicle_from_source_to_agent ( self , source ) \u00a4 Converts Velocity, Transform, and Control of carla.Vehicle Source code in Bridges/carla_bridge.py def convert_vehicle_from_source_to_agent ( self , source : carla . Vehicle ) -> Vehicle : \"\"\"Converts Velocity, Transform, and Control of carla.Vehicle\"\"\" control : VehicleControl = self . convert_control_from_source_to_agent ( source . get_control () ) # this is cheating here, vehicle does not know its own location transform : Transform = self . convert_transform_from_source_to_agent ( source . get_transform () ) velocity : Vector3D = self . convert_vector3d_from_source_to_agent ( source . get_velocity () ) return Vehicle ( velocity = velocity , transform = transform , control = control )","title":"Carla Bridge"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge","text":"","title":"CarlaBridge"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_control_from_agent_to_source","text":"Converts control to carla.VehicleControl Source code in Bridges/carla_bridge.py def convert_control_from_agent_to_source ( self , control : VehicleControl ) -> carla . VehicleControl : \"\"\"Converts control to carla.VehicleControl\"\"\" return carla . VehicleControl ( throttle = abs ( control . throttle ), steer = control . steering , brake = 0 , hand_brake = False , reverse = True if control . throttle < 0 else False , manual_gear_shift = False , gear = 1 , )","title":"convert_control_from_agent_to_source()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_control_from_source_to_agent","text":"Convert CARLA raw vehicle control to VehicleControl(throttle,steering). Source code in Bridges/carla_bridge.py def convert_control_from_source_to_agent ( self , source : carla . VehicleControl ) -> VehicleControl : \"\"\"Convert CARLA raw vehicle control to VehicleControl(throttle,steering).\"\"\" return VehicleControl ( throttle =- 1 * source . throttle if source . reverse else source . throttle , steering = source . steer , )","title":"convert_control_from_source_to_agent()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_depth_from_source_to_agent","text":"Convert CARLA raw Image to a Union with Depth numpy array. Source code in Bridges/carla_bridge.py def convert_depth_from_source_to_agent ( self , source : carla . Image ) -> Union [ DepthData , None ]: \"\"\"Convert CARLA raw Image to a Union with Depth numpy array.\"\"\" try : array = np . frombuffer ( source . raw_data , dtype = np . dtype ( \"uint8\" )) array = np . reshape ( array , ( source . height , source . width , 4 )) # BGRA array = array [:, :, : 3 ] # BGR array = array [:, :, :: - 1 ] # RGB array = png_to_depth ( array ) return DepthData ( data = array ) except : return None","title":"convert_depth_from_source_to_agent()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_imu_from_source_to_agent","text":"Convert CARLA raw IMUData to IMUData(accelerometer, gyroscope). Source code in Bridges/carla_bridge.py def convert_imu_from_source_to_agent ( self , source : IMUSensor ) -> IMUData : \"\"\"Convert CARLA raw IMUData to IMUData(accelerometer, gyroscope).\"\"\" return IMUData ( accelerometer = Vector3D ( x = source . accelerometer [ 0 ], y = source . accelerometer [ 1 ], z = source . accelerometer [ 2 ], ), gyroscope = Vector3D ( x = source . gyroscope [ 0 ], y = source . gyroscope [ 1 ], z = source . gyroscope [ 2 ] ), )","title":"convert_imu_from_source_to_agent()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_location_from_agent_to_source","text":"Convert Agent's Location to a Carla.Location. Source code in Bridges/carla_bridge.py def convert_location_from_agent_to_source ( self , source : Location ) -> carla . Location : \"\"\"Convert Agent's Location to a Carla.Location.\"\"\" return carla . Location ( x = source . x , y =- source . z , z = source . y )","title":"convert_location_from_agent_to_source()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_location_from_source_to_agent","text":"Convert Location data from Carla.location to Agent's location data type invert the Z axis to make it into right hand coordinate system Parameters: Name Type Description Default source Location carla.location required Returns: Type Description Location Source code in Bridges/carla_bridge.py def convert_location_from_source_to_agent ( self , source : carla . Location ) -> Location : \"\"\" Convert Location data from Carla.location to Agent's location data type invert the Z axis to make it into right hand coordinate system Args: source: carla.location Returns: \"\"\" return Location ( x = source . x , y = source . z , z = source . y )","title":"convert_location_from_source_to_agent()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_rgb_from_source_to_agent","text":"Convert CARLA raw Image to a Union with RGB numpy array. Source code in Bridges/carla_bridge.py def convert_rgb_from_source_to_agent ( self , source : carla . Image ) -> Union [ RGBData , None ]: \"\"\"Convert CARLA raw Image to a Union with RGB numpy array.\"\"\" try : source . convert ( cc . Raw ) rgb_image = self . _to_rgb_array ( source ) return RGBData ( data = rgb_image ) except : return None","title":"convert_rgb_from_source_to_agent()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_rotation_from_agent_to_source","text":"Convert Agent's Rotation to a Carla.Rotation. Source code in Bridges/carla_bridge.py def convert_rotation_from_agent_to_source ( self , source : Rotation ) -> carla . Rotation : \"\"\"Convert Agent's Rotation to a Carla.Rotation.\"\"\" return carla . Rotation ( pitch = source . yaw , yaw = source . pitch , roll = source . roll )","title":"convert_rotation_from_agent_to_source()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_rotation_from_source_to_agent","text":"Convert a CARLA raw rotation to Rotation(pitch=float,yaw=float,roll=float). Source code in Bridges/carla_bridge.py def convert_rotation_from_source_to_agent ( self , source : carla . Rotation ) -> Rotation : \"\"\"Convert a CARLA raw rotation to Rotation(pitch=float,yaw=float,roll=float).\"\"\" roll , pitch , yaw = source . roll , source . pitch , source . yaw if yaw <= 90 : yaw = yaw + 90 else : yaw = yaw - 270 return Rotation ( roll = roll , pitch = pitch , yaw =- yaw )","title":"convert_rotation_from_source_to_agent()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_sensor_data_from_source_to_agent","text":"Returns CARLA Sensors Data from raw front RGB, rear RGB, front depth, and IMU Data. Source code in Bridges/carla_bridge.py def convert_sensor_data_from_source_to_agent ( self , source : dict ) -> SensorsData : \"\"\"Returns CARLA Sensors Data from raw front RGB, rear RGB, front depth, and IMU Data.\"\"\" return SensorsData ( front_rgb = self . convert_rgb_from_source_to_agent ( source = source . get ( \"front_rgb\" , None ) ), rear_rgb = self . convert_rgb_from_source_to_agent ( source = source . get ( \"rear_rgb\" , None ) ), front_depth = self . convert_depth_from_source_to_agent ( source = source . get ( \"front_depth\" , None ) ), imu_data = self . convert_imu_from_source_to_agent ( source = source . get ( \"imu\" , None ) ), )","title":"convert_sensor_data_from_source_to_agent()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_transform_from_agent_to_source","text":"Convert Agent's Transform to a Carla.Transform. Source code in Bridges/carla_bridge.py def convert_transform_from_agent_to_source ( self , source : Transform ) -> carla . Transform : \"\"\"Convert Agent's Transform to a Carla.Transform.\"\"\" return carla . Transform ( location = self . convert_location_from_agent_to_source ( source = source . location ), rotation = self . convert_rotation_from_agent_to_source ( source = source . rotation ), )","title":"convert_transform_from_agent_to_source()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_transform_from_source_to_agent","text":"Convert CARLA raw location and rotation to Transform(location,rotation). Source code in Bridges/carla_bridge.py def convert_transform_from_source_to_agent ( self , source : carla . Transform ) -> Transform : \"\"\"Convert CARLA raw location and rotation to Transform(location,rotation).\"\"\" return Transform ( location = self . convert_location_from_source_to_agent ( source = source . location ), rotation = self . convert_rotation_from_source_to_agent ( source = source . rotation ), )","title":"convert_transform_from_source_to_agent()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_vector3d_from_agent_to_source","text":"Convert Vector3D Object to a CARLA raw Vector3d Data. Source code in Bridges/carla_bridge.py def convert_vector3d_from_agent_to_source ( self , vector3d : Vector3D ) -> carla . Vector3D : \"\"\"Convert Vector3D Object to a CARLA raw Vector3d Data.\"\"\" return carla . Vector3D ( x = vector3d . x , y = vector3d . y , z = vector3d . z )","title":"convert_vector3d_from_agent_to_source()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_vector3d_from_source_to_agent","text":"Convert CARLA raw Vector3d Data to a Vector3D Object. Source code in Bridges/carla_bridge.py def convert_vector3d_from_source_to_agent ( self , source : carla . Vector3D ) -> Vector3D : \"\"\"Convert CARLA raw Vector3d Data to a Vector3D Object.\"\"\" return Vector3D ( x = source . x , y = source . y , z = source . z )","title":"convert_vector3d_from_source_to_agent()"},{"location":"code_documentations/Bridges/carla_bridge/#Bridges.carla_bridge.CarlaBridge.convert_vehicle_from_source_to_agent","text":"Converts Velocity, Transform, and Control of carla.Vehicle Source code in Bridges/carla_bridge.py def convert_vehicle_from_source_to_agent ( self , source : carla . Vehicle ) -> Vehicle : \"\"\"Converts Velocity, Transform, and Control of carla.Vehicle\"\"\" control : VehicleControl = self . convert_control_from_source_to_agent ( source . get_control () ) # this is cheating here, vehicle does not know its own location transform : Transform = self . convert_transform_from_source_to_agent ( source . get_transform () ) velocity : Vector3D = self . convert_vector3d_from_source_to_agent ( source . get_velocity () ) return Vehicle ( velocity = velocity , transform = transform , control = control )","title":"convert_vehicle_from_source_to_agent()"},{"location":"code_documentations/Bridges/jetson_bridge/","text":"JetsonBridge \u00a4 convert_control_from_agent_to_source ( self , control ) \u00a4 Converts control to Throttle and Steering numpy arrays bound between -1 and 1. Parameters: Name Type Description Default control VehicleControl required Returns: Type Description Tuple Tuple Source code in Bridges/jetson_bridge.py def convert_control_from_agent_to_source ( self , control : VehicleControl ) -> Tuple : \"\"\" Converts control to Throttle and Steering numpy arrays bound between -1 and 1. Args: control (): Returns: Tuple \"\"\" return np . clip ( control . throttle , a_min =- 1 , a_max = 1 ), np . clip ( control . steering , a_min =- 1 , a_max = 1 ) convert_control_from_source_to_agent ( self , source ) \u00a4 Convert Jetson raw vehicle control to VehicleControl(throttle,steering). Parameters: Name Type Description Default source Vehicle required Returns: Type Description VehicleControl VehicleControl(Throttle, Steering) Source code in Bridges/jetson_bridge.py def convert_control_from_source_to_agent ( self , source : JetsonVehicle ) -> VehicleControl : \"\"\" Convert Jetson raw vehicle control to VehicleControl(throttle,steering). Args: source (): Returns: VehicleControl(Throttle, Steering) \"\"\" return VehicleControl ( throttle = source . throttle , steering = source . steering ) convert_depth_from_source_to_agent ( self , source ) \u00a4 Convert Jetson raw Image to an Optional with Depth numpy array. Parameters: Name Type Description Default source required Returns: Type Description Optional[ROAR.utilities_module.data_structures_models.DepthData] DepthData Source code in Bridges/jetson_bridge.py def convert_depth_from_source_to_agent ( self , source ) -> Optional [ DepthData ]: \"\"\" Convert Jetson raw Image to an Optional with Depth numpy array. Args: source (): Returns: DepthData \"\"\" if source is not None : depth_data = DepthData ( data = source / np . amax ( source )) return depth_data return None convert_imu_from_source_to_agent ( self , source ) \u00a4 Convert Jetson raw IMUData to IMUData(accelerometer, gyroscope). Parameters: Name Type Description Default source required Returns: Type Description IMUData IMUData(accelerometer, gyroscope) Source code in Bridges/jetson_bridge.py def convert_imu_from_source_to_agent ( self , source ) -> IMUData : \"\"\" Convert Jetson raw IMUData to IMUData(accelerometer, gyroscope). Args: source (): Returns: IMUData(accelerometer, gyroscope) \"\"\" # TODO fill in data here return IMUData ( accelerometer = Vector3D ( x = 0 , y = 0 , z = 0 ), gyroscope = Vector3D ( x = 0 , y = 0 , z = 0 ), ) convert_location_from_source_to_agent ( self , source ) \u00a4 Convert Location data from Jetson Vehicle to Agent's location data type. Parameters: Name Type Description Default source ndarray required Returns: Type Description Location Location(x, y, z) Source code in Bridges/jetson_bridge.py def convert_location_from_source_to_agent ( self , source : np . ndarray ) -> Location : \"\"\" Convert Location data from Jetson Vehicle to Agent's location data type. Args: source (): Returns: Location(x, y, z) \"\"\" return Location ( x = source [ 0 ], y = source [ 1 ], z = source [ 2 ]) convert_rgb_from_source_to_agent ( self , source ) \u00a4 Convert Jetson raw Image to an Optional with RGB numpy array. Parameters: Name Type Description Default source required Returns: Type Description Optional[ROAR.utilities_module.data_structures_models.RGBData] RGBData Source code in Bridges/jetson_bridge.py def convert_rgb_from_source_to_agent ( self , source ) -> Optional [ RGBData ]: \"\"\" Convert Jetson raw Image to an Optional with RGB numpy array. Args: source (): Returns: RGBData \"\"\" if source is not None : return RGBData ( data = source ) return None convert_rotation_from_source_to_agent ( self , source ) \u00a4 Convert a Jetson raw rotation to Rotation(pitch=float,yaw=float,roll=float). Parameters: Name Type Description Default source ndarray required Returns: Type Description Rotation Rotation(pitch, yaw, roll) Source code in Bridges/jetson_bridge.py def convert_rotation_from_source_to_agent ( self , source : np . ndarray ) -> Rotation : \"\"\" Convert a Jetson raw rotation to Rotation(pitch=float,yaw=float,roll=float). Args: source (): Returns: Rotation(pitch, yaw, roll) \"\"\" return Rotation ( roll = source [ 0 ], pitch = source [ 1 ], yaw = source [ 2 ]) convert_sensor_data_from_source_to_agent ( self , source ) \u00a4 Returns Jetson Sensors Data from raw front RGB, rear RGB, front depth, and IMU Data. Parameters: Name Type Description Default source required Returns: Type Description SensorsData SensorData(front_RGB, rear_RGB, front_depth, IMU_Data) Source code in Bridges/jetson_bridge.py def convert_sensor_data_from_source_to_agent ( self , source ) -> SensorsData : \"\"\" Returns Jetson Sensors Data from raw front RGB, rear RGB, front depth, and IMU Data. Args: source (): Returns: SensorData(front_RGB, rear_RGB, front_depth, IMU_Data) \"\"\" return SensorsData ( front_rgb = self . convert_rgb_from_source_to_agent ( source = source . get ( \"front_rgb\" , None ) ), rear_rgb = self . convert_rgb_from_source_to_agent ( source = source . get ( \"rear_rgb\" , None ) ), front_depth = self . convert_depth_from_source_to_agent ( source = source . get ( \"front_depth\" , None ) ), imu_data = self . convert_imu_from_source_to_agent ( source = source . get ( \"imu\" , None ) ), location = self . convert_location_from_source_to_agent ( source = source . get ( \"location\" , None )), rotation = self . convert_rotation_from_source_to_agent ( source = source . get ( \"rotation\" , None )), velocity = self . convert_location_from_source_to_agent ( source = source . get ( \"velocity\" , None )) ) convert_transform_from_source_to_agent ( self , source ) \u00a4 Convert Jetson raw location and rotation to Transform(location,rotation). Parameters: Name Type Description Default source required Returns: Type Description Transform Transform(Location, Rotation) Source code in Bridges/jetson_bridge.py def convert_transform_from_source_to_agent ( self , source ) -> Transform : \"\"\" Convert Jetson raw location and rotation to Transform(location,rotation). Args: source (): Returns: Transform(Location, Rotation) \"\"\" return Transform ( location = self . convert_location_from_source_to_agent ( source = source . location ), rotation = self . convert_rotation_from_source_to_agent ( source = source . rotation ), ) convert_vector3d_from_agent_to_source ( self , vector3d ) \u00a4 Convert Jetson Vector3D Object to Vector3D data. Parameters: Name Type Description Default vector3d Vector3D required Returns: Type Description Any Array Source code in Bridges/jetson_bridge.py def convert_vector3d_from_agent_to_source ( self , vector3d : Vector3D ) -> Any : \"\"\" Convert Jetson Vector3D Object to Vector3D data. Args: vector3d (): Returns: Array \"\"\" return [ vector3d . x , vector3d . y , vector3d . z ] convert_vector3d_from_source_to_agent ( self , source ) \u00a4 Convert Jetson raw Vector3d Data to a Vector3D Object. Parameters: Name Type Description Default source required Returns: Type Description Vector3D Vector3D(x, y, z) Source code in Bridges/jetson_bridge.py def convert_vector3d_from_source_to_agent ( self , source ) -> Vector3D : \"\"\" Convert Jetson raw Vector3d Data to a Vector3D Object. Args: source (): Returns: Vector3D(x, y, z) \"\"\" return Vector3D ( x = source . x , y = source . y , z = source . z ) convert_vehicle_from_source_to_agent ( self , source ) \u00a4 Converts Transform, Velocity, Wheel_Base, and Control of JetsonVehicle. Parameters: Name Type Description Default source Vehicle required Returns: Type Description Vehicle Vehicle(Transform, Velocity, Wheel_Base, Control) Source code in Bridges/jetson_bridge.py def convert_vehicle_from_source_to_agent ( self , source : JetsonVehicle ) -> Vehicle : \"\"\" Converts Transform, Velocity, Wheel_Base, and Control of JetsonVehicle. Args: source (): Returns: Vehicle(Transform, Velocity, Wheel_Base, Control) \"\"\" return Vehicle ( wheel_base = 0.26 , control = self . convert_control_from_source_to_agent ( source = source ) ) convert_vive_tracker_data_from_source_to_agent ( self , source ) \u00a4 Converts raw Vive Tracker data to ViveTrackerData(Location, Rotation, Velocity). Parameters: Name Type Description Default source Optional[ROAR_Jetson.vive.models.ViveTrackerMessage] required Returns: Type Description Optional[ROAR.utilities_module.data_structures_models.ViveTrackerData] ViveTrackerData(Location, Rotation, Velocity) Source code in Bridges/jetson_bridge.py def convert_vive_tracker_data_from_source_to_agent ( self , source : Optional [ ViveTrackerMessage ]) -> \\ Optional [ ViveTrackerData ]: \"\"\" Converts raw Vive Tracker data to ViveTrackerData(Location, Rotation, Velocity). Args: source (): Returns: ViveTrackerData(Location, Rotation, Velocity) \"\"\" if source is not None : vive_tracker_data = ViveTrackerData ( location = Location ( x =- source . x , y = source . y , z =- source . z ), rotation = Rotation ( roll =- source . roll , pitch = source . pitch - 90 , # \u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u670960\u5ea6\u7684\u8bef\u5dee yaw =- source . yaw ), velocity = Vector3D ( x = source . vel_x , y = source . vel_y , z = source . vel_z ) ) return vive_tracker_data return None","title":"Jetson Bridge"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge","text":"","title":"JetsonBridge"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge.convert_control_from_agent_to_source","text":"Converts control to Throttle and Steering numpy arrays bound between -1 and 1. Parameters: Name Type Description Default control VehicleControl required Returns: Type Description Tuple Tuple Source code in Bridges/jetson_bridge.py def convert_control_from_agent_to_source ( self , control : VehicleControl ) -> Tuple : \"\"\" Converts control to Throttle and Steering numpy arrays bound between -1 and 1. Args: control (): Returns: Tuple \"\"\" return np . clip ( control . throttle , a_min =- 1 , a_max = 1 ), np . clip ( control . steering , a_min =- 1 , a_max = 1 )","title":"convert_control_from_agent_to_source()"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge.convert_control_from_source_to_agent","text":"Convert Jetson raw vehicle control to VehicleControl(throttle,steering). Parameters: Name Type Description Default source Vehicle required Returns: Type Description VehicleControl VehicleControl(Throttle, Steering) Source code in Bridges/jetson_bridge.py def convert_control_from_source_to_agent ( self , source : JetsonVehicle ) -> VehicleControl : \"\"\" Convert Jetson raw vehicle control to VehicleControl(throttle,steering). Args: source (): Returns: VehicleControl(Throttle, Steering) \"\"\" return VehicleControl ( throttle = source . throttle , steering = source . steering )","title":"convert_control_from_source_to_agent()"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge.convert_depth_from_source_to_agent","text":"Convert Jetson raw Image to an Optional with Depth numpy array. Parameters: Name Type Description Default source required Returns: Type Description Optional[ROAR.utilities_module.data_structures_models.DepthData] DepthData Source code in Bridges/jetson_bridge.py def convert_depth_from_source_to_agent ( self , source ) -> Optional [ DepthData ]: \"\"\" Convert Jetson raw Image to an Optional with Depth numpy array. Args: source (): Returns: DepthData \"\"\" if source is not None : depth_data = DepthData ( data = source / np . amax ( source )) return depth_data return None","title":"convert_depth_from_source_to_agent()"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge.convert_imu_from_source_to_agent","text":"Convert Jetson raw IMUData to IMUData(accelerometer, gyroscope). Parameters: Name Type Description Default source required Returns: Type Description IMUData IMUData(accelerometer, gyroscope) Source code in Bridges/jetson_bridge.py def convert_imu_from_source_to_agent ( self , source ) -> IMUData : \"\"\" Convert Jetson raw IMUData to IMUData(accelerometer, gyroscope). Args: source (): Returns: IMUData(accelerometer, gyroscope) \"\"\" # TODO fill in data here return IMUData ( accelerometer = Vector3D ( x = 0 , y = 0 , z = 0 ), gyroscope = Vector3D ( x = 0 , y = 0 , z = 0 ), )","title":"convert_imu_from_source_to_agent()"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge.convert_location_from_source_to_agent","text":"Convert Location data from Jetson Vehicle to Agent's location data type. Parameters: Name Type Description Default source ndarray required Returns: Type Description Location Location(x, y, z) Source code in Bridges/jetson_bridge.py def convert_location_from_source_to_agent ( self , source : np . ndarray ) -> Location : \"\"\" Convert Location data from Jetson Vehicle to Agent's location data type. Args: source (): Returns: Location(x, y, z) \"\"\" return Location ( x = source [ 0 ], y = source [ 1 ], z = source [ 2 ])","title":"convert_location_from_source_to_agent()"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge.convert_rgb_from_source_to_agent","text":"Convert Jetson raw Image to an Optional with RGB numpy array. Parameters: Name Type Description Default source required Returns: Type Description Optional[ROAR.utilities_module.data_structures_models.RGBData] RGBData Source code in Bridges/jetson_bridge.py def convert_rgb_from_source_to_agent ( self , source ) -> Optional [ RGBData ]: \"\"\" Convert Jetson raw Image to an Optional with RGB numpy array. Args: source (): Returns: RGBData \"\"\" if source is not None : return RGBData ( data = source ) return None","title":"convert_rgb_from_source_to_agent()"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge.convert_rotation_from_source_to_agent","text":"Convert a Jetson raw rotation to Rotation(pitch=float,yaw=float,roll=float). Parameters: Name Type Description Default source ndarray required Returns: Type Description Rotation Rotation(pitch, yaw, roll) Source code in Bridges/jetson_bridge.py def convert_rotation_from_source_to_agent ( self , source : np . ndarray ) -> Rotation : \"\"\" Convert a Jetson raw rotation to Rotation(pitch=float,yaw=float,roll=float). Args: source (): Returns: Rotation(pitch, yaw, roll) \"\"\" return Rotation ( roll = source [ 0 ], pitch = source [ 1 ], yaw = source [ 2 ])","title":"convert_rotation_from_source_to_agent()"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge.convert_sensor_data_from_source_to_agent","text":"Returns Jetson Sensors Data from raw front RGB, rear RGB, front depth, and IMU Data. Parameters: Name Type Description Default source required Returns: Type Description SensorsData SensorData(front_RGB, rear_RGB, front_depth, IMU_Data) Source code in Bridges/jetson_bridge.py def convert_sensor_data_from_source_to_agent ( self , source ) -> SensorsData : \"\"\" Returns Jetson Sensors Data from raw front RGB, rear RGB, front depth, and IMU Data. Args: source (): Returns: SensorData(front_RGB, rear_RGB, front_depth, IMU_Data) \"\"\" return SensorsData ( front_rgb = self . convert_rgb_from_source_to_agent ( source = source . get ( \"front_rgb\" , None ) ), rear_rgb = self . convert_rgb_from_source_to_agent ( source = source . get ( \"rear_rgb\" , None ) ), front_depth = self . convert_depth_from_source_to_agent ( source = source . get ( \"front_depth\" , None ) ), imu_data = self . convert_imu_from_source_to_agent ( source = source . get ( \"imu\" , None ) ), location = self . convert_location_from_source_to_agent ( source = source . get ( \"location\" , None )), rotation = self . convert_rotation_from_source_to_agent ( source = source . get ( \"rotation\" , None )), velocity = self . convert_location_from_source_to_agent ( source = source . get ( \"velocity\" , None )) )","title":"convert_sensor_data_from_source_to_agent()"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge.convert_transform_from_source_to_agent","text":"Convert Jetson raw location and rotation to Transform(location,rotation). Parameters: Name Type Description Default source required Returns: Type Description Transform Transform(Location, Rotation) Source code in Bridges/jetson_bridge.py def convert_transform_from_source_to_agent ( self , source ) -> Transform : \"\"\" Convert Jetson raw location and rotation to Transform(location,rotation). Args: source (): Returns: Transform(Location, Rotation) \"\"\" return Transform ( location = self . convert_location_from_source_to_agent ( source = source . location ), rotation = self . convert_rotation_from_source_to_agent ( source = source . rotation ), )","title":"convert_transform_from_source_to_agent()"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge.convert_vector3d_from_agent_to_source","text":"Convert Jetson Vector3D Object to Vector3D data. Parameters: Name Type Description Default vector3d Vector3D required Returns: Type Description Any Array Source code in Bridges/jetson_bridge.py def convert_vector3d_from_agent_to_source ( self , vector3d : Vector3D ) -> Any : \"\"\" Convert Jetson Vector3D Object to Vector3D data. Args: vector3d (): Returns: Array \"\"\" return [ vector3d . x , vector3d . y , vector3d . z ]","title":"convert_vector3d_from_agent_to_source()"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge.convert_vector3d_from_source_to_agent","text":"Convert Jetson raw Vector3d Data to a Vector3D Object. Parameters: Name Type Description Default source required Returns: Type Description Vector3D Vector3D(x, y, z) Source code in Bridges/jetson_bridge.py def convert_vector3d_from_source_to_agent ( self , source ) -> Vector3D : \"\"\" Convert Jetson raw Vector3d Data to a Vector3D Object. Args: source (): Returns: Vector3D(x, y, z) \"\"\" return Vector3D ( x = source . x , y = source . y , z = source . z )","title":"convert_vector3d_from_source_to_agent()"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge.convert_vehicle_from_source_to_agent","text":"Converts Transform, Velocity, Wheel_Base, and Control of JetsonVehicle. Parameters: Name Type Description Default source Vehicle required Returns: Type Description Vehicle Vehicle(Transform, Velocity, Wheel_Base, Control) Source code in Bridges/jetson_bridge.py def convert_vehicle_from_source_to_agent ( self , source : JetsonVehicle ) -> Vehicle : \"\"\" Converts Transform, Velocity, Wheel_Base, and Control of JetsonVehicle. Args: source (): Returns: Vehicle(Transform, Velocity, Wheel_Base, Control) \"\"\" return Vehicle ( wheel_base = 0.26 , control = self . convert_control_from_source_to_agent ( source = source ) )","title":"convert_vehicle_from_source_to_agent()"},{"location":"code_documentations/Bridges/jetson_bridge/#Bridges.jetson_bridge.JetsonBridge.convert_vive_tracker_data_from_source_to_agent","text":"Converts raw Vive Tracker data to ViveTrackerData(Location, Rotation, Velocity). Parameters: Name Type Description Default source Optional[ROAR_Jetson.vive.models.ViveTrackerMessage] required Returns: Type Description Optional[ROAR.utilities_module.data_structures_models.ViveTrackerData] ViveTrackerData(Location, Rotation, Velocity) Source code in Bridges/jetson_bridge.py def convert_vive_tracker_data_from_source_to_agent ( self , source : Optional [ ViveTrackerMessage ]) -> \\ Optional [ ViveTrackerData ]: \"\"\" Converts raw Vive Tracker data to ViveTrackerData(Location, Rotation, Velocity). Args: source (): Returns: ViveTrackerData(Location, Rotation, Velocity) \"\"\" if source is not None : vive_tracker_data = ViveTrackerData ( location = Location ( x =- source . x , y = source . y , z =- source . z ), rotation = Rotation ( roll =- source . roll , pitch = source . pitch - 90 , # \u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u670960\u5ea6\u7684\u8bef\u5dee yaw =- source . yaw ), velocity = Vector3D ( x = source . vel_x , y = source . vel_y , z = source . vel_z ) ) return vive_tracker_data return None","title":"convert_vive_tracker_data_from_source_to_agent()"},{"location":"code_documentations/ROAR/agent_module/","text":"ForwardOnlyAgent \u00a4 __init__ ( self , vehicle , agent_settings , ** kwargs ) special \u00a4 Source code in ROAR/agent_module/forward_only_agent.py def __init__ ( self , vehicle : Vehicle , agent_settings : AgentConfig , ** kwargs ): super () . __init__ ( vehicle , agent_settings , ** kwargs ) run_step ( self , sensors_data , vehicle ) \u00a4 Receive Sensor Data and vehicle state information on every step and return a control Parameters: Name Type Description Default sensors_data SensorsData sensor data on this frame required vehicle Vehicle vehicle state on this frame required Returns: Type Description VehicleControl Vehicle Control Source code in ROAR/agent_module/forward_only_agent.py def run_step ( self , sensors_data : SensorsData , vehicle : Vehicle ) -> VehicleControl : super () . run_step ( sensors_data = sensors_data , vehicle = vehicle ) print ( self . vehicle . transform ) control = VehicleControl ( throttle = 0.4 , steering = 0 ) return control OpenCVTensorflowObjectDetectionAgent \u00a4 __init__ ( self , vehicle , agent_settings ) special \u00a4 Source code in ROAR/agent_module/opencv_tensorflow_object_detection_agent.py def __init__ ( self , vehicle : Vehicle , agent_settings : AgentConfig ): super () . __init__ ( vehicle , agent_settings ) folder_name = \"ssd_mobilenet_v2_coco_2018_03_29\" self . weights_folder_path = \\ Path ( \"/home/michael/Desktop/projects/ROAR/ROAR-Sim/data/weights/\" ) frozen_graph_weights_path : Path = self . weights_folder_path / 'opencv_weights_and_config' / folder_name / 'frozen_inference_graph.pb' frozen_graph_struct_path : Path = self . weights_folder_path / 'opencv_weights_and_config' / folder_name / 'model_structure.pbtxt' print ( f \"Path set \\n { frozen_graph_weights_path } \\n { frozen_graph_struct_path } \" ) self . tensorflowNet = cv2 . dnn . readNetFromTensorflow ( frozen_graph_weights_path . as_posix (), frozen_graph_struct_path . as_posix () ) print ( \"OpenCVTensorflowObjectDetectionAgent initialized\" ) run_step ( self , sensors_data , vehicle ) \u00a4 Receive Sensor Data and vehicle state information on every step and return a control Parameters: Name Type Description Default sensors_data SensorsData sensor data on this frame required vehicle Vehicle vehicle state on this frame required Returns: Type Description VehicleControl Vehicle Control Source code in ROAR/agent_module/opencv_tensorflow_object_detection_agent.py def run_step ( self , sensors_data : SensorsData , vehicle : Vehicle ) -> VehicleControl : super ( OpenCVTensorflowObjectDetectionAgent , self ) . run_step ( sensors_data = sensors_data , vehicle = vehicle ) image = self . front_rgb_camera . data . copy () rows , cols , channels = image . shape # image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) # Use the given image as input, which needs to be blob(s). self . tensorflowNet . setInput ( cv2 . dnn . blobFromImage ( image , size = ( 300 , 300 ), swapRB = True , crop = False )) # Runs a forward pass to compute the net output networkOutput = self . tensorflowNet . forward () # Loop on the outputs for detection in networkOutput [ 0 , 0 ]: score = float ( detection [ 2 ]) if score > 0.3 : left = detection [ 3 ] * cols top = detection [ 4 ] * rows right = detection [ 5 ] * cols bottom = detection [ 6 ] * rows area = ( right - left ) * ( bottom - top ) # draw a red rectangle around detected objects if area < 10000 : cv2 . rectangle ( image , ( int ( left ), int ( top )), ( int ( right ), int ( bottom )), ( 0 , 0 , 255 ), thickness = 2 ) self . logger . debug ( f \"Detection confirmed. Score = { score } \" ) # cv2.rectangle(image, (int(left), int(top)), (int(right), int(bottom)), (0, 0, 255), thickness=2) # Show the image with a rectagle surrounding the detected objects cv2 . imshow ( 'Image' , image ) cv2 . waitKey ( 1 ) return VehicleControl () PIDAgent \u00a4 __init__ ( self , target_speed = 40 , ** kwargs ) special \u00a4 Source code in ROAR/agent_module/pid_agent.py def __init__ ( self , target_speed = 40 , ** kwargs ): super () . __init__ ( ** kwargs ) self . target_speed = target_speed self . logger = logging . getLogger ( \"PID Agent\" ) self . route_file_path = Path ( self . agent_settings . waypoint_file_path ) self . pid_controller = PIDController ( agent = self , steering_boundary = ( - 1 , 1 ), throttle_boundary = ( 0 , 1 )) self . mission_planner = WaypointFollowingMissionPlanner ( agent = self ) # initiated right after mission plan self . behavior_planner = BehaviorPlanner ( agent = self ) self . local_planner = SimpleWaypointFollowingLocalPlanner ( agent = self , controller = self . pid_controller , mission_planner = self . mission_planner , behavior_planner = self . behavior_planner , closeness_threshold = 1 ) self . logger . debug ( f \"Waypoint Following Agent Initiated. Reading f\" f \"rom { self . route_file_path . as_posix () } \" ) run_step ( self , vehicle , sensors_data ) \u00a4 Receive Sensor Data and vehicle state information on every step and return a control Parameters: Name Type Description Default sensors_data SensorsData sensor data on this frame required vehicle Vehicle vehicle state on this frame required Returns: Type Description VehicleControl Vehicle Control Source code in ROAR/agent_module/pid_agent.py def run_step ( self , vehicle : Vehicle , sensors_data : SensorsData ) -> VehicleControl : super ( PIDAgent , self ) . run_step ( vehicle = vehicle , sensors_data = sensors_data ) self . transform_history . append ( self . vehicle . transform ) # print(self.vehicle.transform, self.vehicle.velocity) if self . is_done : control = VehicleControl () self . logger . debug ( \"Path Following Agent is Done. Idling.\" ) else : control = self . local_planner . run_in_series () return control PurePursuitAgent \u00a4 __init__ ( self , vehicle , agent_settings , target_speed = 50 ) special \u00a4 Source code in ROAR/agent_module/pure_pursuit_agent.py def __init__ ( self , vehicle : Vehicle , agent_settings : AgentConfig , target_speed = 50 ): super () . __init__ ( vehicle = vehicle , agent_settings = agent_settings ) self . route_file_path = Path ( self . agent_settings . waypoint_file_path ) self . pure_pursuit_controller = \\ PurePursuitController ( agent = self , target_speed = target_speed , look_ahead_gain = 0.1 , look_ahead_distance = 3 ) self . mission_planner = WaypointFollowingMissionPlanner ( agent = self ) # initiated right after mission plan self . behavior_planner = BehaviorPlanner ( agent = self ) self . local_planner = SimpleWaypointFollowingLocalPlanner ( agent = self , controller = self . pure_pursuit_controller , mission_planner = self . mission_planner , behavior_planner = self . behavior_planner , closeness_threshold = 3 ) run_step ( self , sensors_data , vehicle ) \u00a4 Receive Sensor Data and vehicle state information on every step and return a control Parameters: Name Type Description Default sensors_data SensorsData sensor data on this frame required vehicle Vehicle vehicle state on this frame required Returns: Type Description VehicleControl Vehicle Control Source code in ROAR/agent_module/pure_pursuit_agent.py def run_step ( self , sensors_data : SensorsData , vehicle : Vehicle ) -> VehicleControl : super ( PurePursuitAgent , self ) . run_step ( sensors_data = sensors_data , vehicle = vehicle ) vehicle_control = self . local_planner . run_in_series () return vehicle_control LQRAgent \u00a4 __init__ ( self , target_speed = 40 , ** kwargs ) special \u00a4 Source code in ROAR/agent_module/lqr_agent.py def __init__ ( self , target_speed = 40 , ** kwargs ): super () . __init__ ( ** kwargs ) self . target_speed = target_speed self . logger = logging . getLogger ( \"LQR Agent\" ) self . route_file_path = Path ( self . agent_settings . waypoint_file_path ) self . lqr_controller = LQRController ( agent = self , steering_boundary = ( - 1 , 1 ), throttle_boundary = ( - 1 , 1 )) self . mission_planner = WaypointFollowingMissionPlanner ( agent = self ) # initiated right after mission plan self . behavior_planner = BehaviorPlanner ( agent = self ) self . local_planner = SmoothWaypointFollowingLocalPlanner ( agent = self , controller = self . lqr_controller , mission_planner = self . mission_planner , behavior_planner = self . behavior_planner , closeness_threshold = 1 ) self . logger . debug ( f \"Waypoint Following Agent Initiated. Reading f\" f \"rom { self . route_file_path . as_posix () } \" ) run_step ( self , vehicle , sensors_data ) \u00a4 Receive Sensor Data and vehicle state information on every step and return a control Parameters: Name Type Description Default sensors_data SensorsData sensor data on this frame required vehicle Vehicle vehicle state on this frame required Returns: Type Description VehicleControl Vehicle Control Source code in ROAR/agent_module/lqr_agent.py def run_step ( self , vehicle : Vehicle , sensors_data : SensorsData ) -> VehicleControl : super ( LQRAgent , self ) . run_step ( vehicle = vehicle , sensors_data = sensors_data ) self . transform_history . append ( self . vehicle . transform ) if self . local_planner . is_done (): control = VehicleControl () self . logger . debug ( \"Path Following Agent is Done. Idling.\" ) else : control = self . local_planner . run_in_series () return control","title":"Agent Module"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.forward_only_agent.ForwardOnlyAgent","text":"","title":"ForwardOnlyAgent"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.forward_only_agent.ForwardOnlyAgent.__init__","text":"Source code in ROAR/agent_module/forward_only_agent.py def __init__ ( self , vehicle : Vehicle , agent_settings : AgentConfig , ** kwargs ): super () . __init__ ( vehicle , agent_settings , ** kwargs )","title":"__init__()"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.forward_only_agent.ForwardOnlyAgent.run_step","text":"Receive Sensor Data and vehicle state information on every step and return a control Parameters: Name Type Description Default sensors_data SensorsData sensor data on this frame required vehicle Vehicle vehicle state on this frame required Returns: Type Description VehicleControl Vehicle Control Source code in ROAR/agent_module/forward_only_agent.py def run_step ( self , sensors_data : SensorsData , vehicle : Vehicle ) -> VehicleControl : super () . run_step ( sensors_data = sensors_data , vehicle = vehicle ) print ( self . vehicle . transform ) control = VehicleControl ( throttle = 0.4 , steering = 0 ) return control","title":"run_step()"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.opencv_tensorflow_object_detection_agent.OpenCVTensorflowObjectDetectionAgent","text":"","title":"OpenCVTensorflowObjectDetectionAgent"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.opencv_tensorflow_object_detection_agent.OpenCVTensorflowObjectDetectionAgent.__init__","text":"Source code in ROAR/agent_module/opencv_tensorflow_object_detection_agent.py def __init__ ( self , vehicle : Vehicle , agent_settings : AgentConfig ): super () . __init__ ( vehicle , agent_settings ) folder_name = \"ssd_mobilenet_v2_coco_2018_03_29\" self . weights_folder_path = \\ Path ( \"/home/michael/Desktop/projects/ROAR/ROAR-Sim/data/weights/\" ) frozen_graph_weights_path : Path = self . weights_folder_path / 'opencv_weights_and_config' / folder_name / 'frozen_inference_graph.pb' frozen_graph_struct_path : Path = self . weights_folder_path / 'opencv_weights_and_config' / folder_name / 'model_structure.pbtxt' print ( f \"Path set \\n { frozen_graph_weights_path } \\n { frozen_graph_struct_path } \" ) self . tensorflowNet = cv2 . dnn . readNetFromTensorflow ( frozen_graph_weights_path . as_posix (), frozen_graph_struct_path . as_posix () ) print ( \"OpenCVTensorflowObjectDetectionAgent initialized\" )","title":"__init__()"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.opencv_tensorflow_object_detection_agent.OpenCVTensorflowObjectDetectionAgent.run_step","text":"Receive Sensor Data and vehicle state information on every step and return a control Parameters: Name Type Description Default sensors_data SensorsData sensor data on this frame required vehicle Vehicle vehicle state on this frame required Returns: Type Description VehicleControl Vehicle Control Source code in ROAR/agent_module/opencv_tensorflow_object_detection_agent.py def run_step ( self , sensors_data : SensorsData , vehicle : Vehicle ) -> VehicleControl : super ( OpenCVTensorflowObjectDetectionAgent , self ) . run_step ( sensors_data = sensors_data , vehicle = vehicle ) image = self . front_rgb_camera . data . copy () rows , cols , channels = image . shape # image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) # Use the given image as input, which needs to be blob(s). self . tensorflowNet . setInput ( cv2 . dnn . blobFromImage ( image , size = ( 300 , 300 ), swapRB = True , crop = False )) # Runs a forward pass to compute the net output networkOutput = self . tensorflowNet . forward () # Loop on the outputs for detection in networkOutput [ 0 , 0 ]: score = float ( detection [ 2 ]) if score > 0.3 : left = detection [ 3 ] * cols top = detection [ 4 ] * rows right = detection [ 5 ] * cols bottom = detection [ 6 ] * rows area = ( right - left ) * ( bottom - top ) # draw a red rectangle around detected objects if area < 10000 : cv2 . rectangle ( image , ( int ( left ), int ( top )), ( int ( right ), int ( bottom )), ( 0 , 0 , 255 ), thickness = 2 ) self . logger . debug ( f \"Detection confirmed. Score = { score } \" ) # cv2.rectangle(image, (int(left), int(top)), (int(right), int(bottom)), (0, 0, 255), thickness=2) # Show the image with a rectagle surrounding the detected objects cv2 . imshow ( 'Image' , image ) cv2 . waitKey ( 1 ) return VehicleControl ()","title":"run_step()"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.pid_agent.PIDAgent","text":"","title":"PIDAgent"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.pid_agent.PIDAgent.__init__","text":"Source code in ROAR/agent_module/pid_agent.py def __init__ ( self , target_speed = 40 , ** kwargs ): super () . __init__ ( ** kwargs ) self . target_speed = target_speed self . logger = logging . getLogger ( \"PID Agent\" ) self . route_file_path = Path ( self . agent_settings . waypoint_file_path ) self . pid_controller = PIDController ( agent = self , steering_boundary = ( - 1 , 1 ), throttle_boundary = ( 0 , 1 )) self . mission_planner = WaypointFollowingMissionPlanner ( agent = self ) # initiated right after mission plan self . behavior_planner = BehaviorPlanner ( agent = self ) self . local_planner = SimpleWaypointFollowingLocalPlanner ( agent = self , controller = self . pid_controller , mission_planner = self . mission_planner , behavior_planner = self . behavior_planner , closeness_threshold = 1 ) self . logger . debug ( f \"Waypoint Following Agent Initiated. Reading f\" f \"rom { self . route_file_path . as_posix () } \" )","title":"__init__()"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.pid_agent.PIDAgent.run_step","text":"Receive Sensor Data and vehicle state information on every step and return a control Parameters: Name Type Description Default sensors_data SensorsData sensor data on this frame required vehicle Vehicle vehicle state on this frame required Returns: Type Description VehicleControl Vehicle Control Source code in ROAR/agent_module/pid_agent.py def run_step ( self , vehicle : Vehicle , sensors_data : SensorsData ) -> VehicleControl : super ( PIDAgent , self ) . run_step ( vehicle = vehicle , sensors_data = sensors_data ) self . transform_history . append ( self . vehicle . transform ) # print(self.vehicle.transform, self.vehicle.velocity) if self . is_done : control = VehicleControl () self . logger . debug ( \"Path Following Agent is Done. Idling.\" ) else : control = self . local_planner . run_in_series () return control","title":"run_step()"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.pure_pursuit_agent.PurePursuitAgent","text":"","title":"PurePursuitAgent"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.pure_pursuit_agent.PurePursuitAgent.__init__","text":"Source code in ROAR/agent_module/pure_pursuit_agent.py def __init__ ( self , vehicle : Vehicle , agent_settings : AgentConfig , target_speed = 50 ): super () . __init__ ( vehicle = vehicle , agent_settings = agent_settings ) self . route_file_path = Path ( self . agent_settings . waypoint_file_path ) self . pure_pursuit_controller = \\ PurePursuitController ( agent = self , target_speed = target_speed , look_ahead_gain = 0.1 , look_ahead_distance = 3 ) self . mission_planner = WaypointFollowingMissionPlanner ( agent = self ) # initiated right after mission plan self . behavior_planner = BehaviorPlanner ( agent = self ) self . local_planner = SimpleWaypointFollowingLocalPlanner ( agent = self , controller = self . pure_pursuit_controller , mission_planner = self . mission_planner , behavior_planner = self . behavior_planner , closeness_threshold = 3 )","title":"__init__()"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.pure_pursuit_agent.PurePursuitAgent.run_step","text":"Receive Sensor Data and vehicle state information on every step and return a control Parameters: Name Type Description Default sensors_data SensorsData sensor data on this frame required vehicle Vehicle vehicle state on this frame required Returns: Type Description VehicleControl Vehicle Control Source code in ROAR/agent_module/pure_pursuit_agent.py def run_step ( self , sensors_data : SensorsData , vehicle : Vehicle ) -> VehicleControl : super ( PurePursuitAgent , self ) . run_step ( sensors_data = sensors_data , vehicle = vehicle ) vehicle_control = self . local_planner . run_in_series () return vehicle_control","title":"run_step()"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.lqr_agent.LQRAgent","text":"","title":"LQRAgent"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.lqr_agent.LQRAgent.__init__","text":"Source code in ROAR/agent_module/lqr_agent.py def __init__ ( self , target_speed = 40 , ** kwargs ): super () . __init__ ( ** kwargs ) self . target_speed = target_speed self . logger = logging . getLogger ( \"LQR Agent\" ) self . route_file_path = Path ( self . agent_settings . waypoint_file_path ) self . lqr_controller = LQRController ( agent = self , steering_boundary = ( - 1 , 1 ), throttle_boundary = ( - 1 , 1 )) self . mission_planner = WaypointFollowingMissionPlanner ( agent = self ) # initiated right after mission plan self . behavior_planner = BehaviorPlanner ( agent = self ) self . local_planner = SmoothWaypointFollowingLocalPlanner ( agent = self , controller = self . lqr_controller , mission_planner = self . mission_planner , behavior_planner = self . behavior_planner , closeness_threshold = 1 ) self . logger . debug ( f \"Waypoint Following Agent Initiated. Reading f\" f \"rom { self . route_file_path . as_posix () } \" )","title":"__init__()"},{"location":"code_documentations/ROAR/agent_module/#ROAR.agent_module.lqr_agent.LQRAgent.run_step","text":"Receive Sensor Data and vehicle state information on every step and return a control Parameters: Name Type Description Default sensors_data SensorsData sensor data on this frame required vehicle Vehicle vehicle state on this frame required Returns: Type Description VehicleControl Vehicle Control Source code in ROAR/agent_module/lqr_agent.py def run_step ( self , vehicle : Vehicle , sensors_data : SensorsData ) -> VehicleControl : super ( LQRAgent , self ) . run_step ( vehicle = vehicle , sensors_data = sensors_data ) self . transform_history . append ( self . vehicle . transform ) if self . local_planner . is_done (): control = VehicleControl () self . logger . debug ( \"Path Following Agent is Done. Idling.\" ) else : control = self . local_planner . run_in_series () return control","title":"run_step()"},{"location":"code_documentations/ROAR/config/","text":"Configuration pydantic-model \u00a4 absolute_maximum_map_size : int pydantic-field \u00a4 This variable is used to intialize the Occupancy grid map.The bigger it is, the more impact it is going to have on the runtime computationHowever, if it is smaller than the actual map, some weird things can happen enable_autopilot : bool pydantic-field \u00a4 Enable Antopilot front_depth_cam : Camera pydantic-field \u00a4 front_rgb_cam : Camera pydantic-field \u00a4 json_qr_code_file_path : str pydantic-field \u00a4 json_waypoint_file_path : str pydantic-field \u00a4 lqr_config_file_path : str pydantic-field \u00a4 max_speed : float pydantic-field \u00a4 maximum speed in which the vehicle can drive at name : str pydantic-field \u00a4 Duplicate from Carla Setting. But good to have num_laps : int pydantic-field \u00a4 Number of laps to run for output_data_folder_path : str pydantic-field \u00a4 pid_config_file_path : str pydantic-field \u00a4 rear_rgb_cam : Camera pydantic-field \u00a4 save_sensor_data : bool pydantic-field \u00a4 show_sensors_data : bool pydantic-field \u00a4 simple_waypoint_local_planner_config_file_path : str pydantic-field \u00a4 spawn_point_id : int pydantic-field \u00a4 Spanning Location ID target_speed : int pydantic-field \u00a4 waypoint_file_path : str pydantic-field \u00a4 __config__ \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4","title":"Configurations"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration","text":"","title":"Configuration"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.absolute_maximum_map_size","text":"This variable is used to intialize the Occupancy grid map.The bigger it is, the more impact it is going to have on the runtime computationHowever, if it is smaller than the actual map, some weird things can happen","title":"absolute_maximum_map_size"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.enable_autopilot","text":"Enable Antopilot","title":"enable_autopilot"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.front_depth_cam","text":"","title":"front_depth_cam"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.front_rgb_cam","text":"","title":"front_rgb_cam"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.json_qr_code_file_path","text":"","title":"json_qr_code_file_path"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.json_waypoint_file_path","text":"","title":"json_waypoint_file_path"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.lqr_config_file_path","text":"","title":"lqr_config_file_path"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.max_speed","text":"maximum speed in which the vehicle can drive at","title":"max_speed"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.name","text":"Duplicate from Carla Setting. But good to have","title":"name"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.num_laps","text":"Number of laps to run for","title":"num_laps"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.output_data_folder_path","text":"","title":"output_data_folder_path"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.pid_config_file_path","text":"","title":"pid_config_file_path"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.rear_rgb_cam","text":"","title":"rear_rgb_cam"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.save_sensor_data","text":"","title":"save_sensor_data"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.show_sensors_data","text":"","title":"show_sensors_data"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.simple_waypoint_local_planner_config_file_path","text":"","title":"simple_waypoint_local_planner_config_file_path"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.spawn_point_id","text":"Spanning Location ID","title":"spawn_point_id"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.target_speed","text":"","title":"target_speed"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.waypoint_file_path","text":"","title":"waypoint_file_path"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/config/#ROAR.configurations.configuration.Configuration.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/controller_module/","text":"Controller \u00a4 __init__ ( self , agent , ** kwargs ) special \u00a4 Source code in ROAR/control_module/controller.py def __init__ ( self , agent , ** kwargs ): super () . __init__ ( ** kwargs ) self . agent = agent self . logger = logging . getLogger ( \"Controller\" ) run_in_series ( self , next_waypoint , ** kwargs ) \u00a4 Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description VehicleControl VehicleControl Source code in ROAR/control_module/controller.py @abstractmethod def run_in_series ( self , next_waypoint : Transform , ** kwargs ) \\ -> VehicleControl : \"\"\" Abstract function for run step Args: next_waypoint: next waypoint **kwargs: Returns: VehicleControl \"\"\" return VehicleControl () run_in_threaded ( self , ** kwargs ) \u00a4 This is the threaded function. Parameters: Name Type Description Default **kwargs {} Source code in ROAR/control_module/controller.py def run_in_threaded ( self , ** kwargs ): pass save ( self , ** kwargs ) \u00a4 Source code in ROAR/control_module/controller.py def save ( self , ** kwargs ): pass LQRController \u00a4 __init__ ( self , agent , steering_boundary , throttle_boundary , ** kwargs ) special \u00a4 Source code in ROAR/control_module/lqr_controller.py def __init__ ( self , agent , steering_boundary : Tuple [ float , float ], throttle_boundary : Tuple [ float , float ], ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . max_speed = self . agent . agent_settings . max_speed self . throttle_boundary = throttle_boundary self . steering_boundary = steering_boundary # load in system matrices self . config = json . load ( Path ( agent . agent_settings . lqr_config_file_path ) . open ( mode = 'r' )) self . A = np . array ( self . config [ 'A' ]) self . B = np . array ( self . config [ 'B' ]) self . Q = np . array ( self . config [ 'Q' ]) self . R = np . array ( self . config [ 'R' ]) # calculate our feedback matrix self . P , self . K = self . _dlqr ( self . A , self . B , self . Q , self . R ) # some reactive speed control stuff self . errBoi = 0 self . errAlpha = self . config [ 'errAlpha' ] self . slowdown = self . config [ 'slowdown' ] self . maxSlow = self . config [ 'maxSlow' ] self . logger = logging . getLogger ( __name__ ) run_in_series ( self , next_waypoint , speed_multiplier = 1.0 , ** kwargs ) \u00a4 Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description VehicleControl VehicleControl Source code in ROAR/control_module/lqr_controller.py def run_in_series ( self , next_waypoint : Transform , speed_multiplier = 1.0 , ** kwargs ) -> VehicleControl : # Calculate the current angle to the next waypoint angBoi = - self . _calculate_angle_error ( next_waypoint = next_waypoint ) # Grab our current speed curSpeed = Vehicle . get_speed ( self . agent . vehicle ) # Toss both values into a current xt xt = np . array ([ angBoi , curSpeed ]) # Generate our target speed with reactive speed reduction when off track target_speed = min ( self . max_speed , kwargs . get ( \"target_speed\" , self . max_speed )) * speed_multiplier # if we are very off track, update error to reflect that absErr = np . abs ( angBoi ) if absErr > self . errBoi : self . errBoi = absErr else : # if we are getting back on track, gradually reduce our error self . errBoi = self . errBoi * ( 1 - self . errAlpha ) + absErr * self . errAlpha # reduce our target speed based on how far off target we are # target_speed *= (math.exp(-self.errBoi) - 1) * self.slowdown + 1 target_speed *= max (( math . cos ( self . errBoi ) - 1 ) * self . slowdown , - self . maxSlow ) + 1 ## Note for future: It may be helpful to have another module for adaptive speed control and some way to slowly ## increase the target speed when we can. # Assume we want to go in the direction of the waypoint at the target speed foreversies xd = np . array ([ 0 , target_speed ]) cur_speed = Vehicle . get_speed ( self . agent . vehicle ) cd = np . array ([ 0 , cur_speed ]) # Calculate the feasible ud trajectory ud , _ , _ , _ = np . linalg . lstsq ( self . B , xd - np . dot ( self . A , cd ), rcond = None ) # convert to offset variables zt and ht zt = xt - xd ht = - np . dot ( self . K , zt ) # convert back to ut and clip our inputs ut = ht + ud steering = np . clip ( ut [ 0 ], self . steering_boundary [ 0 ], self . steering_boundary [ 1 ]) throttle = np . clip ( ut [ 1 ], self . throttle_boundary [ 0 ], self . throttle_boundary [ 1 ]) return VehicleControl ( steering = steering , throttle = throttle ) VehicleMPCController \u00a4 __init__ ( self , agent , route_file_path , target_speed = inf , steps_ahead = 10 , max_throttle = 1 , max_steering = 1 , dt = 0.1 ) special \u00a4 Source code in ROAR/control_module/mpc_controller.py def __init__ ( self , agent : Agent , route_file_path : Path , # read in route target_speed = float ( \"inf\" ), steps_ahead = 10 , max_throttle = 1 , max_steering = 1 , dt = 0.1 ): super () . __init__ ( agent = agent ) self . logger = logging . getLogger ( __name__ ) # Read in route file self . track_DF = pd . read_csv ( route_file_path , header = None ) # Fit the route to a curve spline_points = 10000 self . pts_2D = self . track_DF . loc [:, [ 0 , 1 ]] . values tck , u = splprep ( self . pts_2D . T , u = None , s = 2.0 , per = 1 , k = 3 ) u_new = np . linspace ( u . min (), u . max (), spline_points ) x_new , y_new = splev ( u_new , tck , der = 0 ) self . pts_2D = np . c_ [ x_new , y_new ] # Modified parm self . prev_cte = 0 self . target_speed = target_speed self . state_vars = ( 'x' , 'y' , 'v' , '\u03c8' , 'cte' , 'e\u03c8' ) self . steps_ahead = steps_ahead self . dt = dt # Cost function coefficients self . cte_coeff = 100 # 100 self . epsi_coeff = 100 # 100 self . speed_coeff = 0.4 # 0.2 self . acc_coeff = 1 # 1 self . steer_coeff = 0.1 # 0.1 self . consec_acc_coeff = 50 self . consec_steer_coeff = 50 # Front wheel L self . Lf = 2.5 # How the polynomial fitting the desired curve is fitted self . steps_poly = 30 # modify to 3 when using 3D data self . poly_degree = 3 # Bounds for the optimizer self . bounds = ( 6 * self . steps_ahead * [( None , None )] + self . steps_ahead * [( 0 , max_throttle )] # throttle bounds + self . steps_ahead * [( - max_steering , max_steering )] # steer bounds ) # State 0 placeholder num_vars = ( len ( self . state_vars ) + 2 ) # State variables and two actuators self . state0 = np . zeros ( self . steps_ahead * num_vars ) # Lambdify and minimize stuff self . evaluator = 'numpy' self . tolerance = 1 self . cost_func , self . cost_grad_func , self . constr_funcs = \\ self . get_func_constraints_and_bounds () # To keep the previous state self . steer = 0 self . throttle = 0 self . logger . debug ( \"MPC Controller initiated\" ) clip_throttle ( throttle , curr_speed , target_speed ) staticmethod \u00a4 Source code in ROAR/control_module/mpc_controller.py @staticmethod def clip_throttle ( throttle , curr_speed , target_speed ): return np . clip ( throttle - 0.01 * ( curr_speed - target_speed ), 0.4 , 0.9 ) create_array_of_symbols ( str_symbol , N ) staticmethod \u00a4 Source code in ROAR/control_module/mpc_controller.py @staticmethod def create_array_of_symbols ( str_symbol , N ): return sym . symbols ( ' {symbol} 0: {N} ' . format ( symbol = str_symbol , N = N )) generate_fun ( self , symb_fun , vars_ , init , poly ) \u00a4 Generates a function of the form fun(x, *args) Source code in ROAR/control_module/mpc_controller.py def generate_fun ( self , symb_fun , vars_ , init , poly ): \"\"\" Generates a function of the form `fun(x, *args)` \"\"\" args = init + poly return sym . lambdify (( vars_ , * args ), symb_fun , self . evaluator ) generate_grad ( self , symb_fun , vars_ , init , poly ) \u00a4 TODO: add comments Source code in ROAR/control_module/mpc_controller.py def generate_grad ( self , symb_fun , vars_ , init , poly ): \"\"\" TODO: add comments \"\"\" args = init + poly return sym . lambdify ( ( vars_ , * args ), derive_by_array ( symb_fun , vars_ + args )[: len ( vars_ )], self . evaluator ) get_closest_waypoint_index_2D ( self , car_location , waypoint_location ) \u00a4 Get the index of the closest waypoint in self.pts_2D Note: it may give wrong index when the route is overlapped Source code in ROAR/control_module/mpc_controller.py def get_closest_waypoint_index_2D ( self , car_location , waypoint_location ): \"\"\"Get the index of the closest waypoint in self.pts_2D Note: it may give wrong index when the route is overlapped \"\"\" location_arr = np . array ([ car_location . x , car_location . y ]) dists = np . linalg . norm ( self . pts_2D - location_arr , axis = 1 ) return np . argmin ( dists ) get_closest_waypoint_index_3D ( self , car_location , waypoint_location ) \u00a4 Get the index of the closest waypoint in self.track_DF car_location: current car location waypoint_location: next_waypoint Source code in ROAR/control_module/mpc_controller.py def get_closest_waypoint_index_3D ( self , car_location , waypoint_location ): \"\"\"Get the index of the closest waypoint in self.track_DF car_location: current car location waypoint_location: next_waypoint \"\"\" index = self . track_DF . loc [( self . track_DF [ 0 ] == waypoint_location . x ) & ( self . track_DF [ 1 ] == waypoint_location . y )] . index if len ( index ) > 0 : return index [ 0 ] else : location_arr = np . array ([ car_location . x , car_location . y , car_location . z , ]) dists = np . linalg . norm ( self . track_DF - location_arr , axis = 1 ) return np . argmin ( dists ) get_func_constraints_and_bounds ( self ) \u00a4 Defines MPC's cost function and constraints. Source code in ROAR/control_module/mpc_controller.py def get_func_constraints_and_bounds ( self ): \"\"\" Defines MPC's cost function and constraints. \"\"\" # Polynomial coefficients will also be symbolic variables poly = self . create_array_of_symbols ( 'poly' , self . poly_degree + 1 ) # Initialize the initial state x_init = sym . symbols ( 'x_init' ) y_init = sym . symbols ( 'y_init' ) \u03c8_init = sym . symbols ( '\u03c8_init' ) v_init = sym . symbols ( 'v_init' ) cte_init = sym . symbols ( 'cte_init' ) e\u03c8_init = sym . symbols ( 'e\u03c8_init' ) init = ( x_init , y_init , \u03c8_init , v_init , cte_init , e\u03c8_init ) # State variables x = self . create_array_of_symbols ( 'x' , self . steps_ahead ) y = self . create_array_of_symbols ( 'y' , self . steps_ahead ) \u03c8 = self . create_array_of_symbols ( '\u03c8' , self . steps_ahead ) v = self . create_array_of_symbols ( 'v' , self . steps_ahead ) cte = self . create_array_of_symbols ( 'cte' , self . steps_ahead ) e\u03c8 = self . create_array_of_symbols ( 'e\u03c8' , self . steps_ahead ) # Actuators a = self . create_array_of_symbols ( 'a' , self . steps_ahead ) \u03b4 = self . create_array_of_symbols ( '\u03b4' , self . steps_ahead ) vars_ = ( # Symbolic arrays (but NOT actuators) * x , * y , * \u03c8 , * v , * cte , * e\u03c8 , # Symbolic arrays (actuators) * a , * \u03b4 , ) cost = 0 for t in range ( self . steps_ahead ): cost += ( # Reference state penalties self . cte_coeff * cte [ t ] ** 2 + self . epsi_coeff * e\u03c8 [ t ] ** 2 + + self . speed_coeff * ( v [ t ] - self . target_speed ) ** 2 # Actuator penalties + self . acc_coeff * a [ t ] ** 2 + self . steer_coeff * \u03b4 [ t ] ** 2 ) # Penalty for differences in consecutive actuators for t in range ( self . steps_ahead - 1 ): cost += ( self . consec_acc_coeff * ( a [ t + 1 ] - a [ t ]) ** 2 + self . consec_steer_coeff * ( \u03b4 [ t + 1 ] - \u03b4 [ t ]) ** 2 ) # Initialize constraints eq_constr = _EqualityConstraints ( self . steps_ahead , self . state_vars ) eq_constr [ 'x' ][ 0 ] = x [ 0 ] - x_init eq_constr [ 'y' ][ 0 ] = y [ 0 ] - y_init eq_constr [ '\u03c8' ][ 0 ] = \u03c8 [ 0 ] - \u03c8_init eq_constr [ 'v' ][ 0 ] = v [ 0 ] - v_init eq_constr [ 'cte' ][ 0 ] = cte [ 0 ] - cte_init eq_constr [ 'e\u03c8' ][ 0 ] = e\u03c8 [ 0 ] - e\u03c8_init for t in range ( 1 , self . steps_ahead ): curve = sum ( poly [ - ( i + 1 )] * x [ t - 1 ] ** i for i in range ( len ( poly ))) # The desired \u03c8 is equal to the derivative of the polynomial # curve at # point x[t-1] \u03c8des = sum ( poly [ - ( i + 1 )] * i * x [ t - 1 ] ** ( i - 1 ) for i in range ( 1 , len ( poly ))) eq_constr [ 'x' ][ t ] = x [ t ] - ( x [ t - 1 ] + v [ t - 1 ] * sym . cos ( \u03c8 [ t - 1 ]) * self . dt ) eq_constr [ 'y' ][ t ] = y [ t ] - ( y [ t - 1 ] + v [ t - 1 ] * sym . sin ( \u03c8 [ t - 1 ]) * self . dt ) eq_constr [ '\u03c8' ][ t ] = \u03c8 [ t ] - ( \u03c8 [ t - 1 ] - v [ t - 1 ] * \u03b4 [ t - 1 ] / self . Lf * self . dt ) eq_constr [ 'v' ][ t ] = v [ t ] - ( v [ t - 1 ] + a [ t - 1 ] * self . dt ) eq_constr [ 'cte' ][ t ] = cte [ t ] - ( curve - y [ t - 1 ] + v [ t - 1 ] * sym . sin ( e\u03c8 [ t - 1 ]) * self . dt ) eq_constr [ 'e\u03c8' ][ t ] = e\u03c8 [ t ] - ( \u03c8 [ t - 1 ] - \u03c8des - v [ t - 1 ] * \u03b4 [ t - 1 ] / self . Lf * self . dt ) # Generate actual functions from cost_func = self . generate_fun ( cost , vars_ , init , poly ) cost_grad_func = self . generate_grad ( cost , vars_ , init , poly ) constr_funcs = [] for symbol in self . state_vars : for t in range ( self . steps_ahead ): func = self . generate_fun ( eq_constr [ symbol ][ t ], vars_ , init , poly ) grad_func = self . generate_grad ( eq_constr [ symbol ][ t ], vars_ , init , poly ) constr_funcs . append ( { 'type' : 'eq' , 'fun' : func , 'jac' : grad_func , 'args' : None }, ) return cost_func , cost_grad_func , constr_funcs get_state0 ( self , v , cte , epsi , a , delta , poly ) \u00a4 Source code in ROAR/control_module/mpc_controller.py def get_state0 ( self , v , cte , epsi , a , delta , poly ): a = a or 0 delta = delta or 0 x = np . linspace ( 0 , 1 , self . steps_ahead ) y = np . polyval ( poly , x ) psi = 0 self . state0 [: self . steps_ahead ] = x self . state0 [ self . steps_ahead : 2 * self . steps_ahead ] = y self . state0 [ 2 * self . steps_ahead : 3 * self . steps_ahead ] = psi self . state0 [ 3 * self . steps_ahead : 4 * self . steps_ahead ] = v self . state0 [ 4 * self . steps_ahead : 5 * self . steps_ahead ] = cte self . state0 [ 5 * self . steps_ahead : 6 * self . steps_ahead ] = epsi self . state0 [ 6 * self . steps_ahead : 7 * self . steps_ahead ] = a self . state0 [ 7 * self . steps_ahead : 8 * self . steps_ahead ] = delta return self . state0 minimize_cost ( self , bounds , x0 , init ) \u00a4 Source code in ROAR/control_module/mpc_controller.py def minimize_cost ( self , bounds , x0 , init ): for constr_func in self . constr_funcs : constr_func [ 'args' ] = init return minimize ( fun = self . cost_func , x0 = x0 , args = init , jac = self . cost_grad_func , bounds = bounds , constraints = self . constr_funcs , method = 'SLSQP' , tol = self . tolerance , ) run_in_series ( self , next_waypoint ) \u00a4 Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs required Returns: Type Description VehicleControl VehicleControl Source code in ROAR/control_module/mpc_controller.py def run_in_series ( self , next_waypoint : Transform ) -> VehicleControl : super ( VehicleMPCController , self ) . run_in_series ( next_waypoint ) # get vehicle location (x, y) # location = self.vehicle.transform.location location = self . agent . vehicle . transform . location x , y = location . x , location . y # get vehicle rotation # rotation = self.vehicle.transform.rotation rotation = self . agent . vehicle . transform . rotation \u03c8 = rotation . yaw / 180 * np . pi # transform into radient cos_\u03c8 = np . cos ( \u03c8 ) sin_\u03c8 = np . sin ( \u03c8 ) # get vehicle speed # v = Vehicle.get_speed(self.vehicle) v = Vehicle . get_speed ( self . agent . vehicle ) # get next waypoint location wx , wy = next_waypoint . location . x , next_waypoint . location . y # debug logging # self.logger.debug(f\"car location: ({x}, {y})\") # self.logger.debug(f\"car \u03c8: {\u03c8}\") # self.logger.debug(f\"car speed: {v}\") # self.logger.debug(f\"next waypoint: ({wx}, {wy})\") ### 3D ### # get the index of next waypoint # waypoint_index = self.get_closest_waypoint_index_3D(location, # next_waypoint.location) # # find more waypoints index to fit a polynomial # waypoint_index_shifted = waypoint_index - 2 # indeces = waypoint_index_shifted + self.steps_poly * np.arange( # self.poly_degree + 1) # indeces = indeces % self.track_DF.shape[0] # # get waypoints for polynomial fitting # pts = np.array([[self.track_DF.iloc[i][0], self.track_DF.iloc[i][ # 1]] for i in indeces]) ### 2D ### index_2D = self . get_closest_waypoint_index_2D ( location , next_waypoint . location ) index_2D_shifted = index_2D - 5 indeces_2D = index_2D_shifted + self . steps_poly * np . arange ( self . poly_degree + 1 ) indeces_2D = indeces_2D % self . pts_2D . shape [ 0 ] pts = self . pts_2D [ indeces_2D ] # self.logger.debug(f'\\nwaypoint index:\\n {index_2D}') # self.logger.debug(f'\\nindeces:\\n {indeces_2D}') # transform waypoints from world to car coorinate pts_car = VehicleMPCController . transform_into_cars_coordinate_system ( pts , x , y , cos_\u03c8 , sin_\u03c8 ) # fit the polynomial poly = np . polyfit ( pts_car [:, 0 ], pts_car [:, 1 ], self . poly_degree ) # Debug # self.logger.debug(f'\\nwaypoint index:\\n {waypoint_index}') # self.logger.debug(f'\\nindeces:\\n {indeces}') # self.logger.debug(f'\\npts for poly_fit:\\n {pts}') # self.logger.debug(f'\\npts_car:\\n {pts_car}') ########### cte = poly [ - 1 ] e\u03c8 = - np . arctan ( poly [ - 2 ]) init = ( 0 , 0 , 0 , v , cte , e\u03c8 , * poly ) self . state0 = self . get_state0 ( v , cte , e\u03c8 , self . steer , self . throttle , poly ) result = self . minimize_cost ( self . bounds , self . state0 , init ) # self.steer = -0.6 * cte - 5.5 * (cte - self.prev_cte) # self.prev_cte = cte # self.throttle = VehicleMPCController.clip_throttle(self.throttle, # v, self.target_speed) control = VehicleControl () if 'success' in result . message : self . steer = result . x [ - self . steps_ahead ] self . throttle = result . x [ - 2 * self . steps_ahead ] else : self . logger . debug ( 'Unsuccessful optimization' ) control . steering = self . steer control . throttle = self . throttle return control transform_into_cars_coordinate_system ( pts , x , y , cos_\u03c8 , sin_\u03c8 ) staticmethod \u00a4 Source code in ROAR/control_module/mpc_controller.py @staticmethod def transform_into_cars_coordinate_system ( pts , x , y , cos_\u03c8 , sin_\u03c8 ): diff = ( pts - [ x , y ]) pts_car = np . zeros_like ( diff ) pts_car [:, 0 ] = cos_\u03c8 * diff [:, 0 ] + sin_\u03c8 * diff [:, 1 ] pts_car [:, 1 ] = sin_\u03c8 * diff [:, 0 ] - cos_\u03c8 * diff [:, 1 ] return pts_car LatPIDController \u00a4 __init__ ( self , agent , config , steering_boundary , dt = 0.03 , ** kwargs ) special \u00a4 Source code in ROAR/control_module/pid_controller.py def __init__ ( self , agent , config : dict , steering_boundary : Tuple [ float , float ], dt : float = 0.03 , ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . config = config self . steering_boundary = steering_boundary self . _error_buffer = deque ( maxlen = 10 ) self . _dt = dt run_in_series ( self , next_waypoint , ** kwargs ) \u00a4 Calculates a vector that represent where you are going. Parameters: Name Type Description Default next_waypoint Transform required **kwargs {} Returns: Type Description float lat_control Source code in ROAR/control_module/pid_controller.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> float : \"\"\" Calculates a vector that represent where you are going. Args: next_waypoint (): **kwargs (): Returns: lat_control \"\"\" # calculate a vector that represent where you are going v_begin = self . agent . vehicle . transform . location . to_array () direction_vector = np . array ([ - np . sin ( np . deg2rad ( self . agent . vehicle . transform . rotation . yaw )), 0 , - np . cos ( np . deg2rad ( self . agent . vehicle . transform . rotation . yaw ))]) v_end = v_begin + direction_vector v_vec = np . array ([( v_end [ 0 ] - v_begin [ 0 ]), 0 , ( v_end [ 2 ] - v_begin [ 2 ])]) # calculate error projection w_vec = np . array ( [ next_waypoint . location . x - v_begin [ 0 ], 0 , next_waypoint . location . z - v_begin [ 2 ], ] ) v_vec_normed = v_vec / np . linalg . norm ( v_vec ) w_vec_normed = w_vec / np . linalg . norm ( w_vec ) error = np . arccos ( v_vec_normed @ w_vec_normed . T ) _cross = np . cross ( v_vec_normed , w_vec_normed ) if _cross [ 1 ] > 0 : error *= - 1 self . _error_buffer . append ( error ) if len ( self . _error_buffer ) >= 2 : _de = ( self . _error_buffer [ - 1 ] - self . _error_buffer [ - 2 ]) / self . _dt _ie = sum ( self . _error_buffer ) * self . _dt else : _de = 0.0 _ie = 0.0 k_p , k_d , k_i = PIDController . find_k_values ( config = self . config , vehicle = self . agent . vehicle ) lat_control = float ( np . clip (( k_p * error ) + ( k_d * _de ) + ( k_i * _ie ), self . steering_boundary [ 0 ], self . steering_boundary [ 1 ]) ) return lat_control LongPIDController \u00a4 __init__ ( self , agent , config , throttle_boundary , max_speed , dt = 0.03 , ** kwargs ) special \u00a4 Source code in ROAR/control_module/pid_controller.py def __init__ ( self , agent , config : dict , throttle_boundary : Tuple [ float , float ], max_speed : float , dt : float = 0.03 , ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . config = config self . max_speed = max_speed self . throttle_boundary = throttle_boundary self . _error_buffer = deque ( maxlen = 10 ) self . _dt = dt run_in_series ( self , next_waypoint , ** kwargs ) \u00a4 Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description float VehicleControl Source code in ROAR/control_module/pid_controller.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> float : target_speed = min ( self . max_speed , kwargs . get ( \"target_speed\" , self . max_speed )) current_speed = Vehicle . get_speed ( self . agent . vehicle ) k_p , k_d , k_i = PIDController . find_k_values ( vehicle = self . agent . vehicle , config = self . config ) error = target_speed - current_speed self . _error_buffer . append ( error ) if len ( self . _error_buffer ) >= 2 : # print(self._error_buffer[-1], self._error_buffer[-2]) _de = ( self . _error_buffer [ - 2 ] - self . _error_buffer [ - 1 ]) / self . _dt _ie = sum ( self . _error_buffer ) * self . _dt else : _de = 0.0 _ie = 0.0 output = float ( np . clip (( k_p * error ) + ( k_d * _de ) + ( k_i * _ie ), self . throttle_boundary [ 0 ], self . throttle_boundary [ 1 ])) # self.logger.debug(f\"curr_speed: {round(current_speed, 2)} | kp: {round(k_p, 2)} | kd: {k_d} | ki = {k_i} | \" # f\"err = {round(error, 2)} | de = {round(_de, 2)} | ie = {round(_ie, 2)}\") # f\"self._error_buffer[-1] {self._error_buffer[-1]} | self._error_buffer[-2] = {self._error_buffer[-2]}\") return output PIDController \u00a4 __init__ ( self , agent , steering_boundary , throttle_boundary , ** kwargs ) special \u00a4 Source code in ROAR/control_module/pid_controller.py def __init__ ( self , agent , steering_boundary : Tuple [ float , float ], throttle_boundary : Tuple [ float , float ], ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . max_speed = self . agent . agent_settings . max_speed self . throttle_boundary = throttle_boundary self . steering_boundary = steering_boundary self . config = json . load ( Path ( agent . agent_settings . pid_config_file_path ) . open ( mode = 'r' )) self . long_pid_controller = LongPIDController ( agent = agent , throttle_boundary = throttle_boundary , max_speed = self . max_speed , config = self . config [ \"longitudinal_controller\" ]) self . lat_pid_controller = LatPIDController ( agent = agent , config = self . config [ \"latitudinal_controller\" ], steering_boundary = steering_boundary ) self . logger = logging . getLogger ( __name__ ) find_k_values ( vehicle , config ) staticmethod \u00a4 Source code in ROAR/control_module/pid_controller.py @staticmethod def find_k_values ( vehicle : Vehicle , config : dict ) -> np . array : current_speed = Vehicle . get_speed ( vehicle = vehicle ) k_p , k_d , k_i = 1 , 0 , 0 for speed_upper_bound , kvalues in config . items (): speed_upper_bound = float ( speed_upper_bound ) if current_speed < speed_upper_bound : k_p , k_d , k_i = kvalues [ \"Kp\" ], kvalues [ \"Kd\" ], kvalues [ \"Ki\" ] break return np . clip ([ k_p , k_d , k_i ], a_min = 0 , a_max = 1 ) run_in_series ( self , next_waypoint , ** kwargs ) \u00a4 Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description VehicleControl VehicleControl Source code in ROAR/control_module/pid_controller.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> VehicleControl : throttle = self . long_pid_controller . run_in_series ( next_waypoint = next_waypoint , target_speed = kwargs . get ( \"target_speed\" , self . max_speed )) steering = self . lat_pid_controller . run_in_series ( next_waypoint = next_waypoint ) return VehicleControl ( throttle = throttle , steering = steering ) LatitunalPurePursuitController \u00a4 __init__ ( self , agent , look_ahead_gain , look_ahead_distance ) special \u00a4 Source code in ROAR/control_module/pure_pursuit_control.py def __init__ ( self , agent : Agent , look_ahead_gain : float , look_ahead_distance : float ): self . agent = agent self . look_ahead_gain = look_ahead_gain self . look_ahead_distance = look_ahead_distance run_step ( self , next_waypoint ) \u00a4 Parameters: Name Type Description Default next_waypoint Transform required Returns: Type Description float VehicleControl.clamp Source code in ROAR/control_module/pure_pursuit_control.py def run_step ( self , next_waypoint : Transform ) -> float : \"\"\" Args: next_waypoint (): Returns: VehicleControl.clamp \"\"\" target_z = next_waypoint . location . z target_x = next_waypoint . location . x angle_difference = math . atan2 ( target_z - self . agent . vehicle . transform . location . z , target_x - self . agent . vehicle . transform . location . x ) - np . radians ( self . agent . vehicle . transform . rotation . pitch ) curr_look_forward = ( self . look_ahead_gain * Vehicle . get_speed ( vehicle = self . agent . vehicle ) + self . look_ahead_distance ) lateral_difference = math . atan2 ( 2.0 * self . agent . vehicle . wheel_base * math . sin ( angle_difference ) / curr_look_forward , 1.0 , ) return VehicleControl . clamp ( lateral_difference , - 1 , 1 ) LongitunalPurePursuitController \u00a4 __init__ ( self , agent , target_speed = 60 , kp = 0.1 ) special \u00a4 Source code in ROAR/control_module/pure_pursuit_control.py def __init__ ( self , agent : Agent , target_speed = 60 , kp = 0.1 ): self . agent = agent self . target_speed = target_speed self . kp = kp run_step ( self ) \u00a4 Source code in ROAR/control_module/pure_pursuit_control.py def run_step ( self ) -> float : return float ( VehicleControl . clamp ( self . kp * ( self . target_speed - Vehicle . get_speed ( self . agent . vehicle )), 0 , 1 ) ) PurePursuitController \u00a4 __init__ ( self , agent , look_ahead_gain = 0.1 , look_ahead_distance = 2 , target_speed = 60 ) special \u00a4 Parameters: Name Type Description Default vehicle Vehicle information required look_ahead_gain float Look ahead factor 0.1 look_ahead_distance float look ahead distance 2 target_speed desired longitudinal speed to maintain 60 Source code in ROAR/control_module/pure_pursuit_control.py def __init__ ( self , agent : Agent , look_ahead_gain : float = 0.1 , look_ahead_distance : float = 2 , target_speed = 60 , ): \"\"\" Args: vehicle: Vehicle information look_ahead_gain: Look ahead factor look_ahead_distance: look ahead distance target_speed: desired longitudinal speed to maintain \"\"\" super ( PurePursuitController , self ) . __init__ ( agent = agent ) self . target_speed = self . agent . agent_config . max_speed \\ if self . agent . agent_config . max_speed else target_speed self . look_ahead_gain = look_ahead_gain self . look_ahead_distance = look_ahead_distance self . latitunal_controller = LatitunalPurePursuitController ( agent = self . agent , look_ahead_gain = look_ahead_gain , look_ahead_distance = look_ahead_distance , ) self . longitunal_controller = LongitunalPurePursuitController ( agent = self . agent , target_speed = target_speed ) run_in_series ( self , next_waypoint , ** kwargs ) \u00a4 run one step of Pure Pursuit Control Parameters: Name Type Description Default vehicle current vehicle state required next_waypoint Transform Next waypoint, Transform required **kwargs {} Returns: Type Description VehicleControl Vehicle Control Source code in ROAR/control_module/pure_pursuit_control.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> VehicleControl : \"\"\" run one step of Pure Pursuit Control Args: vehicle: current vehicle state next_waypoint: Next waypoint, Transform **kwargs: Returns: Vehicle Control \"\"\" control = VehicleControl ( throttle = self . longitunal_controller . run_step (), steering = self . latitunal_controller . run_step ( next_waypoint = next_waypoint ), ) return control LatPIDController \u00a4 __init__ ( self , agent , steering_boundary , dt = 0.03 , ** kwargs ) special \u00a4 Source code in ROAR/control_module/rl_pid_controller.py def __init__ ( self , agent , steering_boundary : Tuple [ float , float ], dt : float = 0.03 , ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . steering_boundary = steering_boundary self . _error_buffer = deque ( maxlen = 10 ) self . _dt = dt find_k_values ( self ) \u00a4 Source code in ROAR/control_module/rl_pid_controller.py def find_k_values ( self ) -> Tuple [ float , float , float ]: k_p = self . agent . kwargs . get ( \"lat_k_p\" , 1 ) k_d = self . agent . kwargs . get ( \"lat_k_d\" , 0 ) k_i = self . agent . kwargs . get ( \"lat_k_i\" , 0 ) return k_p , k_d , k_i run_in_series ( self , next_waypoint , ** kwargs ) \u00a4 Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description float VehicleControl Source code in ROAR/control_module/rl_pid_controller.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> float : # calculate a vector that represent where you are going v_begin = self . agent . vehicle . transform . location v_end = v_begin + Location ( x = math . cos ( math . radians ( self . agent . vehicle . transform . rotation . pitch )), y = 0 , z = math . sin ( math . radians ( self . agent . vehicle . transform . rotation . pitch )), ) v_vec = np . array ([ v_end . x - v_begin . x , 0 , v_end . z - v_begin . z ]) # calculate error projection w_vec = np . array ( [ next_waypoint . location . x - v_begin . x , 0 , next_waypoint . location . z - v_begin . z , ] ) _dot = math . acos ( np . clip ( np . dot ( v_vec , w_vec ) / ( np . linalg . norm ( w_vec ) * np . linalg . norm ( v_vec )), - 1.0 , 1.0 , ) ) _cross = np . cross ( v_vec , w_vec ) if _cross [ 1 ] > 0 : _dot *= - 1 self . _error_buffer . append ( _dot ) if len ( self . _error_buffer ) >= 2 : _de = ( self . _error_buffer [ - 1 ] - self . _error_buffer [ - 2 ]) / self . _dt _ie = sum ( self . _error_buffer ) * self . _dt else : _de = 0.0 _ie = 0.0 k_p , k_d , k_i = self . find_k_values () lat_control = float ( np . clip (( k_p * _dot ) + ( k_d * _de ) + ( k_i * _ie ), self . steering_boundary [ 0 ], self . steering_boundary [ 1 ]) ) return lat_control LongPIDController \u00a4 __init__ ( self , agent , throttle_boundary , max_speed , dt = 0.03 , ** kwargs ) special \u00a4 Source code in ROAR/control_module/rl_pid_controller.py def __init__ ( self , agent , throttle_boundary : Tuple [ float , float ], max_speed : float , dt : float = 0.03 , ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . max_speed = max_speed self . throttle_boundary = throttle_boundary self . _error_buffer = deque ( maxlen = 10 ) self . _dt = dt find_k_values ( self ) \u00a4 Source code in ROAR/control_module/rl_pid_controller.py def find_k_values ( self ) -> Tuple [ float , float , float ]: k_p = self . agent . kwargs . get ( \"long_k_p\" , 1 ) k_d = self . agent . kwargs . get ( \"long_k_d\" , 0 ) k_i = self . agent . kwargs . get ( \"long_k_i\" , 0 ) return k_p , k_d , k_i run_in_series ( self , next_waypoint , ** kwargs ) \u00a4 Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description float VehicleControl Source code in ROAR/control_module/rl_pid_controller.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> float : target_speed = min ( self . max_speed , self . agent . kwargs . get ( \"target_speed\" , self . max_speed )) self . logger . debug ( f \"Target_Speed: { target_speed } | max_speed = { self . max_speed } \" ) current_speed = Vehicle . get_speed ( self . agent . vehicle ) k_p , k_d , k_i = self . find_k_values () error = target_speed - current_speed self . _error_buffer . append ( error ) if len ( self . _error_buffer ) >= 2 : # print(self._error_buffer[-1], self._error_buffer[-2]) _de = ( self . _error_buffer [ - 2 ] - self . _error_buffer [ - 1 ]) / self . _dt _ie = sum ( self . _error_buffer ) * self . _dt else : _de = 0.0 _ie = 0.0 output = float ( np . clip (( k_p * error ) + ( k_d * _de ) + ( k_i * _ie ), self . throttle_boundary [ 0 ], self . throttle_boundary [ 1 ])) # self.logger.debug(f\"curr_speed: {round(current_speed, 2)} | kp: {round(k_p, 2)} | kd: {k_d} | ki = {k_i} | \" # f\"err = {round(error, 2)} | de = {round(_de, 2)} | ie = {round(_ie, 2)}\") # f\"self._error_buffer[-1] {self._error_buffer[-1]} | self._error_buffer[-2] = {self._error_buffer[-2]}\") return output PIDController \u00a4 __init__ ( self , agent , steering_boundary , throttle_boundary , ** kwargs ) special \u00a4 Source code in ROAR/control_module/rl_pid_controller.py def __init__ ( self , agent : Agent , steering_boundary : Tuple [ float , float ], throttle_boundary : Tuple [ float , float ], ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . max_speed = self . agent . agent_settings . max_speed self . throttle_boundary = throttle_boundary self . steering_boundary = steering_boundary self . long_pid_controller = LongPIDController ( agent = agent , throttle_boundary = throttle_boundary , max_speed = self . max_speed ) self . lat_pid_controller = LatPIDController ( agent = agent , steering_boundary = steering_boundary ) self . logger = logging . getLogger ( __name__ ) run_in_series ( self , next_waypoint , ** kwargs ) \u00a4 Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description VehicleControl VehicleControl Source code in ROAR/control_module/rl_pid_controller.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> VehicleControl : throttle = self . long_pid_controller . run_in_series ( next_waypoint = next_waypoint ) steering = self . lat_pid_controller . run_in_series ( next_waypoint = next_waypoint ) return VehicleControl ( throttle = throttle , steering = steering )","title":"Control Module"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.controller.Controller","text":"","title":"Controller"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.controller.Controller.__init__","text":"Source code in ROAR/control_module/controller.py def __init__ ( self , agent , ** kwargs ): super () . __init__ ( ** kwargs ) self . agent = agent self . logger = logging . getLogger ( \"Controller\" )","title":"__init__()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.controller.Controller.run_in_series","text":"Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description VehicleControl VehicleControl Source code in ROAR/control_module/controller.py @abstractmethod def run_in_series ( self , next_waypoint : Transform , ** kwargs ) \\ -> VehicleControl : \"\"\" Abstract function for run step Args: next_waypoint: next waypoint **kwargs: Returns: VehicleControl \"\"\" return VehicleControl ()","title":"run_in_series()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.controller.Controller.run_in_threaded","text":"This is the threaded function. Parameters: Name Type Description Default **kwargs {} Source code in ROAR/control_module/controller.py def run_in_threaded ( self , ** kwargs ): pass","title":"run_in_threaded()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.controller.Controller.save","text":"Source code in ROAR/control_module/controller.py def save ( self , ** kwargs ): pass","title":"save()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.lqr_controller.LQRController","text":"","title":"LQRController"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.lqr_controller.LQRController.__init__","text":"Source code in ROAR/control_module/lqr_controller.py def __init__ ( self , agent , steering_boundary : Tuple [ float , float ], throttle_boundary : Tuple [ float , float ], ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . max_speed = self . agent . agent_settings . max_speed self . throttle_boundary = throttle_boundary self . steering_boundary = steering_boundary # load in system matrices self . config = json . load ( Path ( agent . agent_settings . lqr_config_file_path ) . open ( mode = 'r' )) self . A = np . array ( self . config [ 'A' ]) self . B = np . array ( self . config [ 'B' ]) self . Q = np . array ( self . config [ 'Q' ]) self . R = np . array ( self . config [ 'R' ]) # calculate our feedback matrix self . P , self . K = self . _dlqr ( self . A , self . B , self . Q , self . R ) # some reactive speed control stuff self . errBoi = 0 self . errAlpha = self . config [ 'errAlpha' ] self . slowdown = self . config [ 'slowdown' ] self . maxSlow = self . config [ 'maxSlow' ] self . logger = logging . getLogger ( __name__ )","title":"__init__()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.lqr_controller.LQRController.run_in_series","text":"Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description VehicleControl VehicleControl Source code in ROAR/control_module/lqr_controller.py def run_in_series ( self , next_waypoint : Transform , speed_multiplier = 1.0 , ** kwargs ) -> VehicleControl : # Calculate the current angle to the next waypoint angBoi = - self . _calculate_angle_error ( next_waypoint = next_waypoint ) # Grab our current speed curSpeed = Vehicle . get_speed ( self . agent . vehicle ) # Toss both values into a current xt xt = np . array ([ angBoi , curSpeed ]) # Generate our target speed with reactive speed reduction when off track target_speed = min ( self . max_speed , kwargs . get ( \"target_speed\" , self . max_speed )) * speed_multiplier # if we are very off track, update error to reflect that absErr = np . abs ( angBoi ) if absErr > self . errBoi : self . errBoi = absErr else : # if we are getting back on track, gradually reduce our error self . errBoi = self . errBoi * ( 1 - self . errAlpha ) + absErr * self . errAlpha # reduce our target speed based on how far off target we are # target_speed *= (math.exp(-self.errBoi) - 1) * self.slowdown + 1 target_speed *= max (( math . cos ( self . errBoi ) - 1 ) * self . slowdown , - self . maxSlow ) + 1 ## Note for future: It may be helpful to have another module for adaptive speed control and some way to slowly ## increase the target speed when we can. # Assume we want to go in the direction of the waypoint at the target speed foreversies xd = np . array ([ 0 , target_speed ]) cur_speed = Vehicle . get_speed ( self . agent . vehicle ) cd = np . array ([ 0 , cur_speed ]) # Calculate the feasible ud trajectory ud , _ , _ , _ = np . linalg . lstsq ( self . B , xd - np . dot ( self . A , cd ), rcond = None ) # convert to offset variables zt and ht zt = xt - xd ht = - np . dot ( self . K , zt ) # convert back to ut and clip our inputs ut = ht + ud steering = np . clip ( ut [ 0 ], self . steering_boundary [ 0 ], self . steering_boundary [ 1 ]) throttle = np . clip ( ut [ 1 ], self . throttle_boundary [ 0 ], self . throttle_boundary [ 1 ]) return VehicleControl ( steering = steering , throttle = throttle )","title":"run_in_series()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.mpc_controller.VehicleMPCController","text":"","title":"VehicleMPCController"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.mpc_controller.VehicleMPCController.__init__","text":"Source code in ROAR/control_module/mpc_controller.py def __init__ ( self , agent : Agent , route_file_path : Path , # read in route target_speed = float ( \"inf\" ), steps_ahead = 10 , max_throttle = 1 , max_steering = 1 , dt = 0.1 ): super () . __init__ ( agent = agent ) self . logger = logging . getLogger ( __name__ ) # Read in route file self . track_DF = pd . read_csv ( route_file_path , header = None ) # Fit the route to a curve spline_points = 10000 self . pts_2D = self . track_DF . loc [:, [ 0 , 1 ]] . values tck , u = splprep ( self . pts_2D . T , u = None , s = 2.0 , per = 1 , k = 3 ) u_new = np . linspace ( u . min (), u . max (), spline_points ) x_new , y_new = splev ( u_new , tck , der = 0 ) self . pts_2D = np . c_ [ x_new , y_new ] # Modified parm self . prev_cte = 0 self . target_speed = target_speed self . state_vars = ( 'x' , 'y' , 'v' , '\u03c8' , 'cte' , 'e\u03c8' ) self . steps_ahead = steps_ahead self . dt = dt # Cost function coefficients self . cte_coeff = 100 # 100 self . epsi_coeff = 100 # 100 self . speed_coeff = 0.4 # 0.2 self . acc_coeff = 1 # 1 self . steer_coeff = 0.1 # 0.1 self . consec_acc_coeff = 50 self . consec_steer_coeff = 50 # Front wheel L self . Lf = 2.5 # How the polynomial fitting the desired curve is fitted self . steps_poly = 30 # modify to 3 when using 3D data self . poly_degree = 3 # Bounds for the optimizer self . bounds = ( 6 * self . steps_ahead * [( None , None )] + self . steps_ahead * [( 0 , max_throttle )] # throttle bounds + self . steps_ahead * [( - max_steering , max_steering )] # steer bounds ) # State 0 placeholder num_vars = ( len ( self . state_vars ) + 2 ) # State variables and two actuators self . state0 = np . zeros ( self . steps_ahead * num_vars ) # Lambdify and minimize stuff self . evaluator = 'numpy' self . tolerance = 1 self . cost_func , self . cost_grad_func , self . constr_funcs = \\ self . get_func_constraints_and_bounds () # To keep the previous state self . steer = 0 self . throttle = 0 self . logger . debug ( \"MPC Controller initiated\" )","title":"__init__()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.mpc_controller.VehicleMPCController.clip_throttle","text":"Source code in ROAR/control_module/mpc_controller.py @staticmethod def clip_throttle ( throttle , curr_speed , target_speed ): return np . clip ( throttle - 0.01 * ( curr_speed - target_speed ), 0.4 , 0.9 )","title":"clip_throttle()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.mpc_controller.VehicleMPCController.create_array_of_symbols","text":"Source code in ROAR/control_module/mpc_controller.py @staticmethod def create_array_of_symbols ( str_symbol , N ): return sym . symbols ( ' {symbol} 0: {N} ' . format ( symbol = str_symbol , N = N ))","title":"create_array_of_symbols()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.mpc_controller.VehicleMPCController.generate_fun","text":"Generates a function of the form fun(x, *args) Source code in ROAR/control_module/mpc_controller.py def generate_fun ( self , symb_fun , vars_ , init , poly ): \"\"\" Generates a function of the form `fun(x, *args)` \"\"\" args = init + poly return sym . lambdify (( vars_ , * args ), symb_fun , self . evaluator )","title":"generate_fun()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.mpc_controller.VehicleMPCController.generate_grad","text":"TODO: add comments Source code in ROAR/control_module/mpc_controller.py def generate_grad ( self , symb_fun , vars_ , init , poly ): \"\"\" TODO: add comments \"\"\" args = init + poly return sym . lambdify ( ( vars_ , * args ), derive_by_array ( symb_fun , vars_ + args )[: len ( vars_ )], self . evaluator )","title":"generate_grad()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.mpc_controller.VehicleMPCController.get_closest_waypoint_index_2D","text":"Get the index of the closest waypoint in self.pts_2D Note: it may give wrong index when the route is overlapped Source code in ROAR/control_module/mpc_controller.py def get_closest_waypoint_index_2D ( self , car_location , waypoint_location ): \"\"\"Get the index of the closest waypoint in self.pts_2D Note: it may give wrong index when the route is overlapped \"\"\" location_arr = np . array ([ car_location . x , car_location . y ]) dists = np . linalg . norm ( self . pts_2D - location_arr , axis = 1 ) return np . argmin ( dists )","title":"get_closest_waypoint_index_2D()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.mpc_controller.VehicleMPCController.get_closest_waypoint_index_3D","text":"Get the index of the closest waypoint in self.track_DF car_location: current car location waypoint_location: next_waypoint Source code in ROAR/control_module/mpc_controller.py def get_closest_waypoint_index_3D ( self , car_location , waypoint_location ): \"\"\"Get the index of the closest waypoint in self.track_DF car_location: current car location waypoint_location: next_waypoint \"\"\" index = self . track_DF . loc [( self . track_DF [ 0 ] == waypoint_location . x ) & ( self . track_DF [ 1 ] == waypoint_location . y )] . index if len ( index ) > 0 : return index [ 0 ] else : location_arr = np . array ([ car_location . x , car_location . y , car_location . z , ]) dists = np . linalg . norm ( self . track_DF - location_arr , axis = 1 ) return np . argmin ( dists )","title":"get_closest_waypoint_index_3D()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.mpc_controller.VehicleMPCController.get_func_constraints_and_bounds","text":"Defines MPC's cost function and constraints. Source code in ROAR/control_module/mpc_controller.py def get_func_constraints_and_bounds ( self ): \"\"\" Defines MPC's cost function and constraints. \"\"\" # Polynomial coefficients will also be symbolic variables poly = self . create_array_of_symbols ( 'poly' , self . poly_degree + 1 ) # Initialize the initial state x_init = sym . symbols ( 'x_init' ) y_init = sym . symbols ( 'y_init' ) \u03c8_init = sym . symbols ( '\u03c8_init' ) v_init = sym . symbols ( 'v_init' ) cte_init = sym . symbols ( 'cte_init' ) e\u03c8_init = sym . symbols ( 'e\u03c8_init' ) init = ( x_init , y_init , \u03c8_init , v_init , cte_init , e\u03c8_init ) # State variables x = self . create_array_of_symbols ( 'x' , self . steps_ahead ) y = self . create_array_of_symbols ( 'y' , self . steps_ahead ) \u03c8 = self . create_array_of_symbols ( '\u03c8' , self . steps_ahead ) v = self . create_array_of_symbols ( 'v' , self . steps_ahead ) cte = self . create_array_of_symbols ( 'cte' , self . steps_ahead ) e\u03c8 = self . create_array_of_symbols ( 'e\u03c8' , self . steps_ahead ) # Actuators a = self . create_array_of_symbols ( 'a' , self . steps_ahead ) \u03b4 = self . create_array_of_symbols ( '\u03b4' , self . steps_ahead ) vars_ = ( # Symbolic arrays (but NOT actuators) * x , * y , * \u03c8 , * v , * cte , * e\u03c8 , # Symbolic arrays (actuators) * a , * \u03b4 , ) cost = 0 for t in range ( self . steps_ahead ): cost += ( # Reference state penalties self . cte_coeff * cte [ t ] ** 2 + self . epsi_coeff * e\u03c8 [ t ] ** 2 + + self . speed_coeff * ( v [ t ] - self . target_speed ) ** 2 # Actuator penalties + self . acc_coeff * a [ t ] ** 2 + self . steer_coeff * \u03b4 [ t ] ** 2 ) # Penalty for differences in consecutive actuators for t in range ( self . steps_ahead - 1 ): cost += ( self . consec_acc_coeff * ( a [ t + 1 ] - a [ t ]) ** 2 + self . consec_steer_coeff * ( \u03b4 [ t + 1 ] - \u03b4 [ t ]) ** 2 ) # Initialize constraints eq_constr = _EqualityConstraints ( self . steps_ahead , self . state_vars ) eq_constr [ 'x' ][ 0 ] = x [ 0 ] - x_init eq_constr [ 'y' ][ 0 ] = y [ 0 ] - y_init eq_constr [ '\u03c8' ][ 0 ] = \u03c8 [ 0 ] - \u03c8_init eq_constr [ 'v' ][ 0 ] = v [ 0 ] - v_init eq_constr [ 'cte' ][ 0 ] = cte [ 0 ] - cte_init eq_constr [ 'e\u03c8' ][ 0 ] = e\u03c8 [ 0 ] - e\u03c8_init for t in range ( 1 , self . steps_ahead ): curve = sum ( poly [ - ( i + 1 )] * x [ t - 1 ] ** i for i in range ( len ( poly ))) # The desired \u03c8 is equal to the derivative of the polynomial # curve at # point x[t-1] \u03c8des = sum ( poly [ - ( i + 1 )] * i * x [ t - 1 ] ** ( i - 1 ) for i in range ( 1 , len ( poly ))) eq_constr [ 'x' ][ t ] = x [ t ] - ( x [ t - 1 ] + v [ t - 1 ] * sym . cos ( \u03c8 [ t - 1 ]) * self . dt ) eq_constr [ 'y' ][ t ] = y [ t ] - ( y [ t - 1 ] + v [ t - 1 ] * sym . sin ( \u03c8 [ t - 1 ]) * self . dt ) eq_constr [ '\u03c8' ][ t ] = \u03c8 [ t ] - ( \u03c8 [ t - 1 ] - v [ t - 1 ] * \u03b4 [ t - 1 ] / self . Lf * self . dt ) eq_constr [ 'v' ][ t ] = v [ t ] - ( v [ t - 1 ] + a [ t - 1 ] * self . dt ) eq_constr [ 'cte' ][ t ] = cte [ t ] - ( curve - y [ t - 1 ] + v [ t - 1 ] * sym . sin ( e\u03c8 [ t - 1 ]) * self . dt ) eq_constr [ 'e\u03c8' ][ t ] = e\u03c8 [ t ] - ( \u03c8 [ t - 1 ] - \u03c8des - v [ t - 1 ] * \u03b4 [ t - 1 ] / self . Lf * self . dt ) # Generate actual functions from cost_func = self . generate_fun ( cost , vars_ , init , poly ) cost_grad_func = self . generate_grad ( cost , vars_ , init , poly ) constr_funcs = [] for symbol in self . state_vars : for t in range ( self . steps_ahead ): func = self . generate_fun ( eq_constr [ symbol ][ t ], vars_ , init , poly ) grad_func = self . generate_grad ( eq_constr [ symbol ][ t ], vars_ , init , poly ) constr_funcs . append ( { 'type' : 'eq' , 'fun' : func , 'jac' : grad_func , 'args' : None }, ) return cost_func , cost_grad_func , constr_funcs","title":"get_func_constraints_and_bounds()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.mpc_controller.VehicleMPCController.get_state0","text":"Source code in ROAR/control_module/mpc_controller.py def get_state0 ( self , v , cte , epsi , a , delta , poly ): a = a or 0 delta = delta or 0 x = np . linspace ( 0 , 1 , self . steps_ahead ) y = np . polyval ( poly , x ) psi = 0 self . state0 [: self . steps_ahead ] = x self . state0 [ self . steps_ahead : 2 * self . steps_ahead ] = y self . state0 [ 2 * self . steps_ahead : 3 * self . steps_ahead ] = psi self . state0 [ 3 * self . steps_ahead : 4 * self . steps_ahead ] = v self . state0 [ 4 * self . steps_ahead : 5 * self . steps_ahead ] = cte self . state0 [ 5 * self . steps_ahead : 6 * self . steps_ahead ] = epsi self . state0 [ 6 * self . steps_ahead : 7 * self . steps_ahead ] = a self . state0 [ 7 * self . steps_ahead : 8 * self . steps_ahead ] = delta return self . state0","title":"get_state0()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.mpc_controller.VehicleMPCController.minimize_cost","text":"Source code in ROAR/control_module/mpc_controller.py def minimize_cost ( self , bounds , x0 , init ): for constr_func in self . constr_funcs : constr_func [ 'args' ] = init return minimize ( fun = self . cost_func , x0 = x0 , args = init , jac = self . cost_grad_func , bounds = bounds , constraints = self . constr_funcs , method = 'SLSQP' , tol = self . tolerance , )","title":"minimize_cost()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.mpc_controller.VehicleMPCController.run_in_series","text":"Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs required Returns: Type Description VehicleControl VehicleControl Source code in ROAR/control_module/mpc_controller.py def run_in_series ( self , next_waypoint : Transform ) -> VehicleControl : super ( VehicleMPCController , self ) . run_in_series ( next_waypoint ) # get vehicle location (x, y) # location = self.vehicle.transform.location location = self . agent . vehicle . transform . location x , y = location . x , location . y # get vehicle rotation # rotation = self.vehicle.transform.rotation rotation = self . agent . vehicle . transform . rotation \u03c8 = rotation . yaw / 180 * np . pi # transform into radient cos_\u03c8 = np . cos ( \u03c8 ) sin_\u03c8 = np . sin ( \u03c8 ) # get vehicle speed # v = Vehicle.get_speed(self.vehicle) v = Vehicle . get_speed ( self . agent . vehicle ) # get next waypoint location wx , wy = next_waypoint . location . x , next_waypoint . location . y # debug logging # self.logger.debug(f\"car location: ({x}, {y})\") # self.logger.debug(f\"car \u03c8: {\u03c8}\") # self.logger.debug(f\"car speed: {v}\") # self.logger.debug(f\"next waypoint: ({wx}, {wy})\") ### 3D ### # get the index of next waypoint # waypoint_index = self.get_closest_waypoint_index_3D(location, # next_waypoint.location) # # find more waypoints index to fit a polynomial # waypoint_index_shifted = waypoint_index - 2 # indeces = waypoint_index_shifted + self.steps_poly * np.arange( # self.poly_degree + 1) # indeces = indeces % self.track_DF.shape[0] # # get waypoints for polynomial fitting # pts = np.array([[self.track_DF.iloc[i][0], self.track_DF.iloc[i][ # 1]] for i in indeces]) ### 2D ### index_2D = self . get_closest_waypoint_index_2D ( location , next_waypoint . location ) index_2D_shifted = index_2D - 5 indeces_2D = index_2D_shifted + self . steps_poly * np . arange ( self . poly_degree + 1 ) indeces_2D = indeces_2D % self . pts_2D . shape [ 0 ] pts = self . pts_2D [ indeces_2D ] # self.logger.debug(f'\\nwaypoint index:\\n {index_2D}') # self.logger.debug(f'\\nindeces:\\n {indeces_2D}') # transform waypoints from world to car coorinate pts_car = VehicleMPCController . transform_into_cars_coordinate_system ( pts , x , y , cos_\u03c8 , sin_\u03c8 ) # fit the polynomial poly = np . polyfit ( pts_car [:, 0 ], pts_car [:, 1 ], self . poly_degree ) # Debug # self.logger.debug(f'\\nwaypoint index:\\n {waypoint_index}') # self.logger.debug(f'\\nindeces:\\n {indeces}') # self.logger.debug(f'\\npts for poly_fit:\\n {pts}') # self.logger.debug(f'\\npts_car:\\n {pts_car}') ########### cte = poly [ - 1 ] e\u03c8 = - np . arctan ( poly [ - 2 ]) init = ( 0 , 0 , 0 , v , cte , e\u03c8 , * poly ) self . state0 = self . get_state0 ( v , cte , e\u03c8 , self . steer , self . throttle , poly ) result = self . minimize_cost ( self . bounds , self . state0 , init ) # self.steer = -0.6 * cte - 5.5 * (cte - self.prev_cte) # self.prev_cte = cte # self.throttle = VehicleMPCController.clip_throttle(self.throttle, # v, self.target_speed) control = VehicleControl () if 'success' in result . message : self . steer = result . x [ - self . steps_ahead ] self . throttle = result . x [ - 2 * self . steps_ahead ] else : self . logger . debug ( 'Unsuccessful optimization' ) control . steering = self . steer control . throttle = self . throttle return control","title":"run_in_series()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.mpc_controller.VehicleMPCController.transform_into_cars_coordinate_system","text":"Source code in ROAR/control_module/mpc_controller.py @staticmethod def transform_into_cars_coordinate_system ( pts , x , y , cos_\u03c8 , sin_\u03c8 ): diff = ( pts - [ x , y ]) pts_car = np . zeros_like ( diff ) pts_car [:, 0 ] = cos_\u03c8 * diff [:, 0 ] + sin_\u03c8 * diff [:, 1 ] pts_car [:, 1 ] = sin_\u03c8 * diff [:, 0 ] - cos_\u03c8 * diff [:, 1 ] return pts_car","title":"transform_into_cars_coordinate_system()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pid_controller.LatPIDController","text":"","title":"LatPIDController"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pid_controller.LatPIDController.__init__","text":"Source code in ROAR/control_module/pid_controller.py def __init__ ( self , agent , config : dict , steering_boundary : Tuple [ float , float ], dt : float = 0.03 , ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . config = config self . steering_boundary = steering_boundary self . _error_buffer = deque ( maxlen = 10 ) self . _dt = dt","title":"__init__()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pid_controller.LatPIDController.run_in_series","text":"Calculates a vector that represent where you are going. Parameters: Name Type Description Default next_waypoint Transform required **kwargs {} Returns: Type Description float lat_control Source code in ROAR/control_module/pid_controller.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> float : \"\"\" Calculates a vector that represent where you are going. Args: next_waypoint (): **kwargs (): Returns: lat_control \"\"\" # calculate a vector that represent where you are going v_begin = self . agent . vehicle . transform . location . to_array () direction_vector = np . array ([ - np . sin ( np . deg2rad ( self . agent . vehicle . transform . rotation . yaw )), 0 , - np . cos ( np . deg2rad ( self . agent . vehicle . transform . rotation . yaw ))]) v_end = v_begin + direction_vector v_vec = np . array ([( v_end [ 0 ] - v_begin [ 0 ]), 0 , ( v_end [ 2 ] - v_begin [ 2 ])]) # calculate error projection w_vec = np . array ( [ next_waypoint . location . x - v_begin [ 0 ], 0 , next_waypoint . location . z - v_begin [ 2 ], ] ) v_vec_normed = v_vec / np . linalg . norm ( v_vec ) w_vec_normed = w_vec / np . linalg . norm ( w_vec ) error = np . arccos ( v_vec_normed @ w_vec_normed . T ) _cross = np . cross ( v_vec_normed , w_vec_normed ) if _cross [ 1 ] > 0 : error *= - 1 self . _error_buffer . append ( error ) if len ( self . _error_buffer ) >= 2 : _de = ( self . _error_buffer [ - 1 ] - self . _error_buffer [ - 2 ]) / self . _dt _ie = sum ( self . _error_buffer ) * self . _dt else : _de = 0.0 _ie = 0.0 k_p , k_d , k_i = PIDController . find_k_values ( config = self . config , vehicle = self . agent . vehicle ) lat_control = float ( np . clip (( k_p * error ) + ( k_d * _de ) + ( k_i * _ie ), self . steering_boundary [ 0 ], self . steering_boundary [ 1 ]) ) return lat_control","title":"run_in_series()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pid_controller.LongPIDController","text":"","title":"LongPIDController"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pid_controller.LongPIDController.__init__","text":"Source code in ROAR/control_module/pid_controller.py def __init__ ( self , agent , config : dict , throttle_boundary : Tuple [ float , float ], max_speed : float , dt : float = 0.03 , ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . config = config self . max_speed = max_speed self . throttle_boundary = throttle_boundary self . _error_buffer = deque ( maxlen = 10 ) self . _dt = dt","title":"__init__()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pid_controller.LongPIDController.run_in_series","text":"Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description float VehicleControl Source code in ROAR/control_module/pid_controller.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> float : target_speed = min ( self . max_speed , kwargs . get ( \"target_speed\" , self . max_speed )) current_speed = Vehicle . get_speed ( self . agent . vehicle ) k_p , k_d , k_i = PIDController . find_k_values ( vehicle = self . agent . vehicle , config = self . config ) error = target_speed - current_speed self . _error_buffer . append ( error ) if len ( self . _error_buffer ) >= 2 : # print(self._error_buffer[-1], self._error_buffer[-2]) _de = ( self . _error_buffer [ - 2 ] - self . _error_buffer [ - 1 ]) / self . _dt _ie = sum ( self . _error_buffer ) * self . _dt else : _de = 0.0 _ie = 0.0 output = float ( np . clip (( k_p * error ) + ( k_d * _de ) + ( k_i * _ie ), self . throttle_boundary [ 0 ], self . throttle_boundary [ 1 ])) # self.logger.debug(f\"curr_speed: {round(current_speed, 2)} | kp: {round(k_p, 2)} | kd: {k_d} | ki = {k_i} | \" # f\"err = {round(error, 2)} | de = {round(_de, 2)} | ie = {round(_ie, 2)}\") # f\"self._error_buffer[-1] {self._error_buffer[-1]} | self._error_buffer[-2] = {self._error_buffer[-2]}\") return output","title":"run_in_series()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pid_controller.PIDController","text":"","title":"PIDController"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pid_controller.PIDController.__init__","text":"Source code in ROAR/control_module/pid_controller.py def __init__ ( self , agent , steering_boundary : Tuple [ float , float ], throttle_boundary : Tuple [ float , float ], ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . max_speed = self . agent . agent_settings . max_speed self . throttle_boundary = throttle_boundary self . steering_boundary = steering_boundary self . config = json . load ( Path ( agent . agent_settings . pid_config_file_path ) . open ( mode = 'r' )) self . long_pid_controller = LongPIDController ( agent = agent , throttle_boundary = throttle_boundary , max_speed = self . max_speed , config = self . config [ \"longitudinal_controller\" ]) self . lat_pid_controller = LatPIDController ( agent = agent , config = self . config [ \"latitudinal_controller\" ], steering_boundary = steering_boundary ) self . logger = logging . getLogger ( __name__ )","title":"__init__()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pid_controller.PIDController.find_k_values","text":"Source code in ROAR/control_module/pid_controller.py @staticmethod def find_k_values ( vehicle : Vehicle , config : dict ) -> np . array : current_speed = Vehicle . get_speed ( vehicle = vehicle ) k_p , k_d , k_i = 1 , 0 , 0 for speed_upper_bound , kvalues in config . items (): speed_upper_bound = float ( speed_upper_bound ) if current_speed < speed_upper_bound : k_p , k_d , k_i = kvalues [ \"Kp\" ], kvalues [ \"Kd\" ], kvalues [ \"Ki\" ] break return np . clip ([ k_p , k_d , k_i ], a_min = 0 , a_max = 1 )","title":"find_k_values()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pid_controller.PIDController.run_in_series","text":"Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description VehicleControl VehicleControl Source code in ROAR/control_module/pid_controller.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> VehicleControl : throttle = self . long_pid_controller . run_in_series ( next_waypoint = next_waypoint , target_speed = kwargs . get ( \"target_speed\" , self . max_speed )) steering = self . lat_pid_controller . run_in_series ( next_waypoint = next_waypoint ) return VehicleControl ( throttle = throttle , steering = steering )","title":"run_in_series()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pure_pursuit_control.LatitunalPurePursuitController","text":"","title":"LatitunalPurePursuitController"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pure_pursuit_control.LatitunalPurePursuitController.__init__","text":"Source code in ROAR/control_module/pure_pursuit_control.py def __init__ ( self , agent : Agent , look_ahead_gain : float , look_ahead_distance : float ): self . agent = agent self . look_ahead_gain = look_ahead_gain self . look_ahead_distance = look_ahead_distance","title":"__init__()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pure_pursuit_control.LatitunalPurePursuitController.run_step","text":"Parameters: Name Type Description Default next_waypoint Transform required Returns: Type Description float VehicleControl.clamp Source code in ROAR/control_module/pure_pursuit_control.py def run_step ( self , next_waypoint : Transform ) -> float : \"\"\" Args: next_waypoint (): Returns: VehicleControl.clamp \"\"\" target_z = next_waypoint . location . z target_x = next_waypoint . location . x angle_difference = math . atan2 ( target_z - self . agent . vehicle . transform . location . z , target_x - self . agent . vehicle . transform . location . x ) - np . radians ( self . agent . vehicle . transform . rotation . pitch ) curr_look_forward = ( self . look_ahead_gain * Vehicle . get_speed ( vehicle = self . agent . vehicle ) + self . look_ahead_distance ) lateral_difference = math . atan2 ( 2.0 * self . agent . vehicle . wheel_base * math . sin ( angle_difference ) / curr_look_forward , 1.0 , ) return VehicleControl . clamp ( lateral_difference , - 1 , 1 )","title":"run_step()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pure_pursuit_control.LongitunalPurePursuitController","text":"","title":"LongitunalPurePursuitController"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pure_pursuit_control.LongitunalPurePursuitController.__init__","text":"Source code in ROAR/control_module/pure_pursuit_control.py def __init__ ( self , agent : Agent , target_speed = 60 , kp = 0.1 ): self . agent = agent self . target_speed = target_speed self . kp = kp","title":"__init__()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pure_pursuit_control.LongitunalPurePursuitController.run_step","text":"Source code in ROAR/control_module/pure_pursuit_control.py def run_step ( self ) -> float : return float ( VehicleControl . clamp ( self . kp * ( self . target_speed - Vehicle . get_speed ( self . agent . vehicle )), 0 , 1 ) )","title":"run_step()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pure_pursuit_control.PurePursuitController","text":"","title":"PurePursuitController"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pure_pursuit_control.PurePursuitController.__init__","text":"Parameters: Name Type Description Default vehicle Vehicle information required look_ahead_gain float Look ahead factor 0.1 look_ahead_distance float look ahead distance 2 target_speed desired longitudinal speed to maintain 60 Source code in ROAR/control_module/pure_pursuit_control.py def __init__ ( self , agent : Agent , look_ahead_gain : float = 0.1 , look_ahead_distance : float = 2 , target_speed = 60 , ): \"\"\" Args: vehicle: Vehicle information look_ahead_gain: Look ahead factor look_ahead_distance: look ahead distance target_speed: desired longitudinal speed to maintain \"\"\" super ( PurePursuitController , self ) . __init__ ( agent = agent ) self . target_speed = self . agent . agent_config . max_speed \\ if self . agent . agent_config . max_speed else target_speed self . look_ahead_gain = look_ahead_gain self . look_ahead_distance = look_ahead_distance self . latitunal_controller = LatitunalPurePursuitController ( agent = self . agent , look_ahead_gain = look_ahead_gain , look_ahead_distance = look_ahead_distance , ) self . longitunal_controller = LongitunalPurePursuitController ( agent = self . agent , target_speed = target_speed )","title":"__init__()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.pure_pursuit_control.PurePursuitController.run_in_series","text":"run one step of Pure Pursuit Control Parameters: Name Type Description Default vehicle current vehicle state required next_waypoint Transform Next waypoint, Transform required **kwargs {} Returns: Type Description VehicleControl Vehicle Control Source code in ROAR/control_module/pure_pursuit_control.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> VehicleControl : \"\"\" run one step of Pure Pursuit Control Args: vehicle: current vehicle state next_waypoint: Next waypoint, Transform **kwargs: Returns: Vehicle Control \"\"\" control = VehicleControl ( throttle = self . longitunal_controller . run_step (), steering = self . latitunal_controller . run_step ( next_waypoint = next_waypoint ), ) return control","title":"run_in_series()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.rl_pid_controller.LatPIDController","text":"","title":"LatPIDController"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.rl_pid_controller.LatPIDController.__init__","text":"Source code in ROAR/control_module/rl_pid_controller.py def __init__ ( self , agent , steering_boundary : Tuple [ float , float ], dt : float = 0.03 , ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . steering_boundary = steering_boundary self . _error_buffer = deque ( maxlen = 10 ) self . _dt = dt","title":"__init__()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.rl_pid_controller.LatPIDController.find_k_values","text":"Source code in ROAR/control_module/rl_pid_controller.py def find_k_values ( self ) -> Tuple [ float , float , float ]: k_p = self . agent . kwargs . get ( \"lat_k_p\" , 1 ) k_d = self . agent . kwargs . get ( \"lat_k_d\" , 0 ) k_i = self . agent . kwargs . get ( \"lat_k_i\" , 0 ) return k_p , k_d , k_i","title":"find_k_values()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.rl_pid_controller.LatPIDController.run_in_series","text":"Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description float VehicleControl Source code in ROAR/control_module/rl_pid_controller.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> float : # calculate a vector that represent where you are going v_begin = self . agent . vehicle . transform . location v_end = v_begin + Location ( x = math . cos ( math . radians ( self . agent . vehicle . transform . rotation . pitch )), y = 0 , z = math . sin ( math . radians ( self . agent . vehicle . transform . rotation . pitch )), ) v_vec = np . array ([ v_end . x - v_begin . x , 0 , v_end . z - v_begin . z ]) # calculate error projection w_vec = np . array ( [ next_waypoint . location . x - v_begin . x , 0 , next_waypoint . location . z - v_begin . z , ] ) _dot = math . acos ( np . clip ( np . dot ( v_vec , w_vec ) / ( np . linalg . norm ( w_vec ) * np . linalg . norm ( v_vec )), - 1.0 , 1.0 , ) ) _cross = np . cross ( v_vec , w_vec ) if _cross [ 1 ] > 0 : _dot *= - 1 self . _error_buffer . append ( _dot ) if len ( self . _error_buffer ) >= 2 : _de = ( self . _error_buffer [ - 1 ] - self . _error_buffer [ - 2 ]) / self . _dt _ie = sum ( self . _error_buffer ) * self . _dt else : _de = 0.0 _ie = 0.0 k_p , k_d , k_i = self . find_k_values () lat_control = float ( np . clip (( k_p * _dot ) + ( k_d * _de ) + ( k_i * _ie ), self . steering_boundary [ 0 ], self . steering_boundary [ 1 ]) ) return lat_control","title":"run_in_series()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.rl_pid_controller.LongPIDController","text":"","title":"LongPIDController"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.rl_pid_controller.LongPIDController.__init__","text":"Source code in ROAR/control_module/rl_pid_controller.py def __init__ ( self , agent , throttle_boundary : Tuple [ float , float ], max_speed : float , dt : float = 0.03 , ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . max_speed = max_speed self . throttle_boundary = throttle_boundary self . _error_buffer = deque ( maxlen = 10 ) self . _dt = dt","title":"__init__()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.rl_pid_controller.LongPIDController.find_k_values","text":"Source code in ROAR/control_module/rl_pid_controller.py def find_k_values ( self ) -> Tuple [ float , float , float ]: k_p = self . agent . kwargs . get ( \"long_k_p\" , 1 ) k_d = self . agent . kwargs . get ( \"long_k_d\" , 0 ) k_i = self . agent . kwargs . get ( \"long_k_i\" , 0 ) return k_p , k_d , k_i","title":"find_k_values()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.rl_pid_controller.LongPIDController.run_in_series","text":"Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description float VehicleControl Source code in ROAR/control_module/rl_pid_controller.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> float : target_speed = min ( self . max_speed , self . agent . kwargs . get ( \"target_speed\" , self . max_speed )) self . logger . debug ( f \"Target_Speed: { target_speed } | max_speed = { self . max_speed } \" ) current_speed = Vehicle . get_speed ( self . agent . vehicle ) k_p , k_d , k_i = self . find_k_values () error = target_speed - current_speed self . _error_buffer . append ( error ) if len ( self . _error_buffer ) >= 2 : # print(self._error_buffer[-1], self._error_buffer[-2]) _de = ( self . _error_buffer [ - 2 ] - self . _error_buffer [ - 1 ]) / self . _dt _ie = sum ( self . _error_buffer ) * self . _dt else : _de = 0.0 _ie = 0.0 output = float ( np . clip (( k_p * error ) + ( k_d * _de ) + ( k_i * _ie ), self . throttle_boundary [ 0 ], self . throttle_boundary [ 1 ])) # self.logger.debug(f\"curr_speed: {round(current_speed, 2)} | kp: {round(k_p, 2)} | kd: {k_d} | ki = {k_i} | \" # f\"err = {round(error, 2)} | de = {round(_de, 2)} | ie = {round(_ie, 2)}\") # f\"self._error_buffer[-1] {self._error_buffer[-1]} | self._error_buffer[-2] = {self._error_buffer[-2]}\") return output","title":"run_in_series()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.rl_pid_controller.PIDController","text":"","title":"PIDController"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.rl_pid_controller.PIDController.__init__","text":"Source code in ROAR/control_module/rl_pid_controller.py def __init__ ( self , agent : Agent , steering_boundary : Tuple [ float , float ], throttle_boundary : Tuple [ float , float ], ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . max_speed = self . agent . agent_settings . max_speed self . throttle_boundary = throttle_boundary self . steering_boundary = steering_boundary self . long_pid_controller = LongPIDController ( agent = agent , throttle_boundary = throttle_boundary , max_speed = self . max_speed ) self . lat_pid_controller = LatPIDController ( agent = agent , steering_boundary = steering_boundary ) self . logger = logging . getLogger ( __name__ )","title":"__init__()"},{"location":"code_documentations/ROAR/controller_module/#ROAR.control_module.rl_pid_controller.PIDController.run_in_series","text":"Abstract function for run step Parameters: Name Type Description Default next_waypoint Transform next waypoint required **kwargs {} Returns: Type Description VehicleControl VehicleControl Source code in ROAR/control_module/rl_pid_controller.py def run_in_series ( self , next_waypoint : Transform , ** kwargs ) -> VehicleControl : throttle = self . long_pid_controller . run_in_series ( next_waypoint = next_waypoint ) steering = self . lat_pid_controller . run_in_series ( next_waypoint = next_waypoint ) return VehicleControl ( throttle = throttle , steering = steering )","title":"run_in_series()"},{"location":"code_documentations/ROAR/perception_module/","text":"DepthToPointCloudDetector \u00a4 __init__ ( self , agent , should_compute_global_pointcloud = False , should_sample_points = False , should_filter_by_distance = False , max_detectable_distance = 1 , scale_factor = 1000 , max_points_to_convert = 10000 , ** kwargs ) special \u00a4 Source code in ROAR/perception_module/depth_to_pointcloud_detector.py def __init__ ( self , agent : Agent , should_compute_global_pointcloud : bool = False , should_sample_points : bool = False , should_filter_by_distance : float = False , max_detectable_distance : float = 1 , scale_factor : int = 1000 , max_points_to_convert = 10000 , ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . should_compute_global_pointcloud = should_compute_global_pointcloud self . should_sample_points = should_sample_points self . should_filter_by_distance = should_filter_by_distance self . max_detectable_distance = max_detectable_distance self . max_points_to_convert = max_points_to_convert self . scale_factor = scale_factor find_fps ( t1 , t2 ) staticmethod \u00a4 Source code in ROAR/perception_module/depth_to_pointcloud_detector.py @staticmethod def find_fps ( t1 , t2 ): return 1 / ( t2 - t1 ) run_in_series ( self ) \u00a4 :return: 3 x N array of point cloud Source code in ROAR/perception_module/depth_to_pointcloud_detector.py def run_in_series ( self ) -> Optional [ np . ndarray ]: \"\"\" :return: 3 x N array of point cloud \"\"\" if self . agent . front_depth_camera . data is not None : # depth_img = self.agent.front_depth_camera.data.copy() # pixel_length = self.agent.front_depth_camera.image_size_x * self.agent.front_depth_camera.image_size_y # u_coord = repmat(np.r_[self.agent.front_depth_camera.image_size_x - 1:-1:-1], # self.agent.front_depth_camera.image_size_y, 1).reshape(pixel_length) # v_coord = repmat(np.c_[self.agent.front_depth_camera.image_size_y - 1:-1:-1], # 1, self.agent.front_depth_camera.image_size_x).reshape(pixel_length) # # normalized_depth = np.reshape(depth_img, pixel_length) # p2d = np.array([u_coord, v_coord, np.ones_like(u_coord)]) # p3d = np.dot(np.linalg.inv(self.agent.front_depth_camera.intrinsics_matrix), p2d) # return p3d # p3d *= normalized_depth * 1000 # return p3d depth_img = self . agent . front_depth_camera . data . copy () coords = np . where ( depth_img < 10 ) # it will just return all coordinate pairs raw_p2d = np . reshape ( self . _pix2xyz ( depth_img = depth_img , i = coords [ 0 ], j = coords [ 1 ]), ( 3 , np . shape ( coords )[ 1 ])) . T # N x 3 cords_y_minus_z_x = np . linalg . inv ( self . agent . front_depth_camera . intrinsics_matrix ) @ raw_p2d . T cords_xyz_1 = np . vstack ([ cords_y_minus_z_x [ 0 , :], - cords_y_minus_z_x [ 1 , :], - cords_y_minus_z_x [ 2 , :], np . ones (( 1 , np . shape ( cords_y_minus_z_x )[ 1 ])) ]) points = self . agent . vehicle . transform . get_matrix () @ cords_xyz_1 points = points . T [:, : 3 ] return points return None run_in_threaded ( self , ** kwargs ) \u00a4 This is the threaded function. Parameters: Name Type Description Default **kwargs {} Source code in ROAR/perception_module/depth_to_pointcloud_detector.py def run_in_threaded ( self , ** kwargs ): while True : self . agent . kwargs [ \"point_cloud\" ] = self . run_in_series () Detector \u00a4 __init__ ( self , agent , ** kwargs ) special \u00a4 Source code in ROAR/perception_module/detector.py def __init__ ( self , agent : Agent , ** kwargs ): super () . __init__ ( ** kwargs ) self . agent = agent self . logger = logging . getLogger ( \"Base Detector\" ) GroundPlaneDetector \u00a4 __init__ ( self , agent , knn = 200 , res = 4 , ** kwargs ) special \u00a4 Source code in ROAR/perception_module/ground_plane_detector.py def __init__ ( self , agent : Agent , knn : int = 200 , res : int = 4 , ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . reference_norm : Optional [ np . ndarray ] = np . array ([ - 0.00000283 , - 0.00012446 , 0.99999999 ]) self . knn = knn self . res = res self . f1 , self . f2 , self . f3 , self . f4 = self . compute_vectors_near_me ( res ) self . threshold = 0.15 compute_reference_norm ( self , pcd ) \u00a4 Source code in ROAR/perception_module/ground_plane_detector.py def compute_reference_norm ( self , pcd : o3d . geometry . PointCloud ): pcd_tree = o3d . geometry . KDTreeFlann ( pcd ) # build KD tree for fast computation [ k , idx , _ ] = pcd_tree . search_knn_vector_3d ( self . agent . vehicle . transform . location . to_array (), knn = self . knn ) # find points around me points_near_me = np . asarray ( pcd . points )[ idx , :] # 200 x 3 u , s , vh = np . linalg . svd ( points_near_me , full_matrices = False ) # use svd to find normals of points self . reference_norm = vh [ 2 , :] compute_vectors_near_me ( self , res ) \u00a4 Source code in ROAR/perception_module/ground_plane_detector.py def compute_vectors_near_me ( self , res ): d1 , d2 = self . agent . front_depth_camera . image_size_y , self . agent . front_depth_camera . image_size_x idx , jdx = np . indices (( d1 , d2 )) idx_back = np . clip ( idx - 1 , 0 , idx . max ()) . flatten () idx_front = np . clip ( idx + 1 , 0 , idx . max ()) . flatten () jdx_back = np . clip ( jdx - 1 , 0 , jdx . max ()) . flatten () jdx_front = np . clip ( jdx + 1 , 0 , jdx . max ()) . flatten () idx = idx . flatten () jdx = jdx . flatten () # rand_idx = np.random.choice(np.arange(idx.shape[0]), size=d1*d2, replace=False) f1 = ( idx_front * d2 + jdx )[:: res ** 2 ] # [rand_idx] f2 = ( idx_back * d2 + jdx )[:: res ** 2 ] # [rand_idx] f3 = ( idx * d2 + jdx_front )[:: res ** 2 ] # [rand_idx] f4 = ( idx * d2 + jdx_back )[:: res ** 2 ] # [rand_idx] return f1 , f2 , f3 , f4 construct_pointcloud ( points ) staticmethod \u00a4 Source code in ROAR/perception_module/ground_plane_detector.py @staticmethod def construct_pointcloud ( points ) -> o3d . geometry . PointCloud : pcd = o3d . geometry . PointCloud () pcd . points = o3d . utility . Vector3dVector ( points ) pcd . estimate_normals () return pcd normalize_v3 ( arr ) staticmethod \u00a4 Source code in ROAR/perception_module/ground_plane_detector.py @staticmethod def normalize_v3 ( arr ): lens = np . sqrt ( arr [:, 0 ] ** 2 + arr [:, 1 ] ** 2 + arr [:, 2 ] ** 2 ) lens [ lens <= 0 ] = 1 arr [:, 0 ] /= lens arr [:, 1 ] /= lens arr [:, 2 ] /= lens return arr run_in_series ( self ) \u00a4 :return: 3 x N array of point cloud Source code in ROAR/perception_module/ground_plane_detector.py def run_in_series ( self ) -> Any : if self . agent . kwargs . get ( \"point_cloud\" , None ) is not None : try : points : np . ndarray = self . agent . kwargs . get ( \"point_cloud\" ) . copy () x = points [ self . f3 , :] - points [ self . f4 , :] y = points [ self . f1 , :] - points [ self . f2 , :] normals = self . normalize_v3 ( np . cross ( x , y )) # OpenCV FloodFill d1 = h = self . agent . front_depth_camera . image_size_y d2 = w = self . agent . front_depth_camera . image_size_x curr_img = normals . reshape (( int ( d1 / self . res ), int ( d2 / self . res ), 3 )) . astype ( np . float32 ) min_x , max_x = 0 , h // self . res min_y , max_y = w * 3 // 4 // self . res , w # Y_norm_array: np.ndarray = curr_img[min_x:max_x, min_y:max_y, 1] # x, y = np.unravel_index(np.argmax(Y_norm_array), np.shape(Y_norm_array)) # seed_w, seed_h = y + min_y, x + min_x # print(seed_w, seed_h, np.shape(curr_img)) seed_point = ( int ( d1 / self . res ) - 10 , int ( int ( d2 / self . res ) / 2 )) _ , retval , _ , _ = cv2 . floodFill ( image = curr_img , seedPoint = seed_point , newVal = ( 0 , 0 , 0 ), loDiff = ( self . threshold , self . threshold , self . threshold ), upDiff = ( self . threshold , self . threshold , self . threshold ), mask = None , flags = 8 ) bool_matrix = np . mean ( retval , axis = 2 ) == 0 bool_zeros = np . zeros ( d1 * d2 ) . flatten () bool_indices = np . indices ( bool_zeros . shape )[ 0 ][:: self . res ** 2 ] bool_zeros [ bool_indices ] = bool_matrix . flatten () bool_matrix = bool_zeros . reshape (( d1 , d2 )) color_image = self . agent . front_rgb_camera . data . copy () color_image [ bool_matrix > 0 ] = 255 cv2 . imshow ( 'Color' , color_image ) cv2 . waitKey ( 1 ) except Exception as e : self . logger . error ( e )","title":"Perception Module"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.depth_to_pointcloud_detector.DepthToPointCloudDetector","text":"","title":"DepthToPointCloudDetector"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.depth_to_pointcloud_detector.DepthToPointCloudDetector.__init__","text":"Source code in ROAR/perception_module/depth_to_pointcloud_detector.py def __init__ ( self , agent : Agent , should_compute_global_pointcloud : bool = False , should_sample_points : bool = False , should_filter_by_distance : float = False , max_detectable_distance : float = 1 , scale_factor : int = 1000 , max_points_to_convert = 10000 , ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . should_compute_global_pointcloud = should_compute_global_pointcloud self . should_sample_points = should_sample_points self . should_filter_by_distance = should_filter_by_distance self . max_detectable_distance = max_detectable_distance self . max_points_to_convert = max_points_to_convert self . scale_factor = scale_factor","title":"__init__()"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.depth_to_pointcloud_detector.DepthToPointCloudDetector.find_fps","text":"Source code in ROAR/perception_module/depth_to_pointcloud_detector.py @staticmethod def find_fps ( t1 , t2 ): return 1 / ( t2 - t1 )","title":"find_fps()"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.depth_to_pointcloud_detector.DepthToPointCloudDetector.run_in_series","text":":return: 3 x N array of point cloud Source code in ROAR/perception_module/depth_to_pointcloud_detector.py def run_in_series ( self ) -> Optional [ np . ndarray ]: \"\"\" :return: 3 x N array of point cloud \"\"\" if self . agent . front_depth_camera . data is not None : # depth_img = self.agent.front_depth_camera.data.copy() # pixel_length = self.agent.front_depth_camera.image_size_x * self.agent.front_depth_camera.image_size_y # u_coord = repmat(np.r_[self.agent.front_depth_camera.image_size_x - 1:-1:-1], # self.agent.front_depth_camera.image_size_y, 1).reshape(pixel_length) # v_coord = repmat(np.c_[self.agent.front_depth_camera.image_size_y - 1:-1:-1], # 1, self.agent.front_depth_camera.image_size_x).reshape(pixel_length) # # normalized_depth = np.reshape(depth_img, pixel_length) # p2d = np.array([u_coord, v_coord, np.ones_like(u_coord)]) # p3d = np.dot(np.linalg.inv(self.agent.front_depth_camera.intrinsics_matrix), p2d) # return p3d # p3d *= normalized_depth * 1000 # return p3d depth_img = self . agent . front_depth_camera . data . copy () coords = np . where ( depth_img < 10 ) # it will just return all coordinate pairs raw_p2d = np . reshape ( self . _pix2xyz ( depth_img = depth_img , i = coords [ 0 ], j = coords [ 1 ]), ( 3 , np . shape ( coords )[ 1 ])) . T # N x 3 cords_y_minus_z_x = np . linalg . inv ( self . agent . front_depth_camera . intrinsics_matrix ) @ raw_p2d . T cords_xyz_1 = np . vstack ([ cords_y_minus_z_x [ 0 , :], - cords_y_minus_z_x [ 1 , :], - cords_y_minus_z_x [ 2 , :], np . ones (( 1 , np . shape ( cords_y_minus_z_x )[ 1 ])) ]) points = self . agent . vehicle . transform . get_matrix () @ cords_xyz_1 points = points . T [:, : 3 ] return points return None","title":"run_in_series()"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.depth_to_pointcloud_detector.DepthToPointCloudDetector.run_in_threaded","text":"This is the threaded function. Parameters: Name Type Description Default **kwargs {} Source code in ROAR/perception_module/depth_to_pointcloud_detector.py def run_in_threaded ( self , ** kwargs ): while True : self . agent . kwargs [ \"point_cloud\" ] = self . run_in_series ()","title":"run_in_threaded()"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.detector.Detector","text":"","title":"Detector"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.detector.Detector.__init__","text":"Source code in ROAR/perception_module/detector.py def __init__ ( self , agent : Agent , ** kwargs ): super () . __init__ ( ** kwargs ) self . agent = agent self . logger = logging . getLogger ( \"Base Detector\" )","title":"__init__()"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.ground_plane_detector.GroundPlaneDetector","text":"","title":"GroundPlaneDetector"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.ground_plane_detector.GroundPlaneDetector.__init__","text":"Source code in ROAR/perception_module/ground_plane_detector.py def __init__ ( self , agent : Agent , knn : int = 200 , res : int = 4 , ** kwargs ): super () . __init__ ( agent , ** kwargs ) self . reference_norm : Optional [ np . ndarray ] = np . array ([ - 0.00000283 , - 0.00012446 , 0.99999999 ]) self . knn = knn self . res = res self . f1 , self . f2 , self . f3 , self . f4 = self . compute_vectors_near_me ( res ) self . threshold = 0.15","title":"__init__()"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.ground_plane_detector.GroundPlaneDetector.compute_reference_norm","text":"Source code in ROAR/perception_module/ground_plane_detector.py def compute_reference_norm ( self , pcd : o3d . geometry . PointCloud ): pcd_tree = o3d . geometry . KDTreeFlann ( pcd ) # build KD tree for fast computation [ k , idx , _ ] = pcd_tree . search_knn_vector_3d ( self . agent . vehicle . transform . location . to_array (), knn = self . knn ) # find points around me points_near_me = np . asarray ( pcd . points )[ idx , :] # 200 x 3 u , s , vh = np . linalg . svd ( points_near_me , full_matrices = False ) # use svd to find normals of points self . reference_norm = vh [ 2 , :]","title":"compute_reference_norm()"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.ground_plane_detector.GroundPlaneDetector.compute_vectors_near_me","text":"Source code in ROAR/perception_module/ground_plane_detector.py def compute_vectors_near_me ( self , res ): d1 , d2 = self . agent . front_depth_camera . image_size_y , self . agent . front_depth_camera . image_size_x idx , jdx = np . indices (( d1 , d2 )) idx_back = np . clip ( idx - 1 , 0 , idx . max ()) . flatten () idx_front = np . clip ( idx + 1 , 0 , idx . max ()) . flatten () jdx_back = np . clip ( jdx - 1 , 0 , jdx . max ()) . flatten () jdx_front = np . clip ( jdx + 1 , 0 , jdx . max ()) . flatten () idx = idx . flatten () jdx = jdx . flatten () # rand_idx = np.random.choice(np.arange(idx.shape[0]), size=d1*d2, replace=False) f1 = ( idx_front * d2 + jdx )[:: res ** 2 ] # [rand_idx] f2 = ( idx_back * d2 + jdx )[:: res ** 2 ] # [rand_idx] f3 = ( idx * d2 + jdx_front )[:: res ** 2 ] # [rand_idx] f4 = ( idx * d2 + jdx_back )[:: res ** 2 ] # [rand_idx] return f1 , f2 , f3 , f4","title":"compute_vectors_near_me()"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.ground_plane_detector.GroundPlaneDetector.construct_pointcloud","text":"Source code in ROAR/perception_module/ground_plane_detector.py @staticmethod def construct_pointcloud ( points ) -> o3d . geometry . PointCloud : pcd = o3d . geometry . PointCloud () pcd . points = o3d . utility . Vector3dVector ( points ) pcd . estimate_normals () return pcd","title":"construct_pointcloud()"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.ground_plane_detector.GroundPlaneDetector.normalize_v3","text":"Source code in ROAR/perception_module/ground_plane_detector.py @staticmethod def normalize_v3 ( arr ): lens = np . sqrt ( arr [:, 0 ] ** 2 + arr [:, 1 ] ** 2 + arr [:, 2 ] ** 2 ) lens [ lens <= 0 ] = 1 arr [:, 0 ] /= lens arr [:, 1 ] /= lens arr [:, 2 ] /= lens return arr","title":"normalize_v3()"},{"location":"code_documentations/ROAR/perception_module/#ROAR.perception_module.ground_plane_detector.GroundPlaneDetector.run_in_series","text":":return: 3 x N array of point cloud Source code in ROAR/perception_module/ground_plane_detector.py def run_in_series ( self ) -> Any : if self . agent . kwargs . get ( \"point_cloud\" , None ) is not None : try : points : np . ndarray = self . agent . kwargs . get ( \"point_cloud\" ) . copy () x = points [ self . f3 , :] - points [ self . f4 , :] y = points [ self . f1 , :] - points [ self . f2 , :] normals = self . normalize_v3 ( np . cross ( x , y )) # OpenCV FloodFill d1 = h = self . agent . front_depth_camera . image_size_y d2 = w = self . agent . front_depth_camera . image_size_x curr_img = normals . reshape (( int ( d1 / self . res ), int ( d2 / self . res ), 3 )) . astype ( np . float32 ) min_x , max_x = 0 , h // self . res min_y , max_y = w * 3 // 4 // self . res , w # Y_norm_array: np.ndarray = curr_img[min_x:max_x, min_y:max_y, 1] # x, y = np.unravel_index(np.argmax(Y_norm_array), np.shape(Y_norm_array)) # seed_w, seed_h = y + min_y, x + min_x # print(seed_w, seed_h, np.shape(curr_img)) seed_point = ( int ( d1 / self . res ) - 10 , int ( int ( d2 / self . res ) / 2 )) _ , retval , _ , _ = cv2 . floodFill ( image = curr_img , seedPoint = seed_point , newVal = ( 0 , 0 , 0 ), loDiff = ( self . threshold , self . threshold , self . threshold ), upDiff = ( self . threshold , self . threshold , self . threshold ), mask = None , flags = 8 ) bool_matrix = np . mean ( retval , axis = 2 ) == 0 bool_zeros = np . zeros ( d1 * d2 ) . flatten () bool_indices = np . indices ( bool_zeros . shape )[ 0 ][:: self . res ** 2 ] bool_zeros [ bool_indices ] = bool_matrix . flatten () bool_matrix = bool_zeros . reshape (( d1 , d2 )) color_image = self . agent . front_rgb_camera . data . copy () color_image [ bool_matrix > 0 ] = 255 cv2 . imshow ( 'Color' , color_image ) cv2 . waitKey ( 1 ) except Exception as e : self . logger . error ( e )","title":"run_in_series()"},{"location":"code_documentations/ROAR/planning_module/","text":"abstract_planner \u00a4 AbstractPlanner \u00a4 __init__ ( self , agent , ** kwargs ) special \u00a4 Source code in ROAR/planning_module/abstract_planner.py def __init__ ( self , agent , ** kwargs ): super () . __init__ ( ** kwargs ) self . logger = logging self . logger = logging . getLogger ( __name__ ) self . agent = agent run_in_series ( self , ** kwargs ) \u00a4 On every step, produce an actionable plan Returns: Type Description Any Source code in ROAR/planning_module/abstract_planner.py @abstractmethod def run_in_series ( self , ** kwargs ) -> Any : \"\"\" On every step, produce an actionable plan Returns: \"\"\" return None run_in_threaded ( self , ** kwargs ) \u00a4 This is the threaded function. Parameters: Name Type Description Default **kwargs {} Source code in ROAR/planning_module/abstract_planner.py def run_in_threaded ( self , ** kwargs ): pass save ( self , ** kwargs ) \u00a4 Source code in ROAR/planning_module/abstract_planner.py def save ( self , ** kwargs ): pass behavior_planner special \u00a4 behavior_planner \u00a4 BehaviorPlanner \u00a4 __init__ ( self , agent , ** kwargs ) special \u00a4 Source code in ROAR/planning_module/behavior_planner/behavior_planner.py def __init__ ( self , agent , ** kwargs ): super () . __init__ ( agent , ** kwargs ) run_in_series ( self ) \u00a4 On every step, produce an actionable plan Returns: Type Description Any Source code in ROAR/planning_module/behavior_planner/behavior_planner.py def run_in_series ( self ) -> Any : pass local_planner special \u00a4 floodfill_based_planner \u00a4 FloodfillBasedPlanner \u00a4 run_in_series ( self ) \u00a4 On every step, produce an actionable plan Returns: Type Description VehicleControl Source code in ROAR/planning_module/local_planner/floodfill_based_planner.py def run_in_series ( self ) -> VehicleControl : pass local_planner \u00a4 LocalPlanner \u00a4 __init__ ( self , agent , controller = None , behavior_planner = None , mission_planner = None , ** kwargs ) special \u00a4 Source code in ROAR/planning_module/local_planner/local_planner.py def __init__ ( self , agent , controller : Optional [ Controller ] = None , behavior_planner : Optional [ BehaviorPlanner ] = None , mission_planner : Optional [ MissionPlanner ] = None , ** kwargs ): super () . __init__ ( agent = agent , ** kwargs ) self . controller = ( Controller ( agent = agent ) if controller is None else controller ) self . behavior_planner = ( BehaviorPlanner ( agent = agent ) if behavior_planner is None else behavior_planner ) self . mission_planner = ( MissionPlanner ( agent = agent ) if mission_planner is None else mission_planner ) self . way_points_queue = deque () is_done ( self ) \u00a4 Source code in ROAR/planning_module/local_planner/local_planner.py @abstractmethod def is_done ( self ): return False run_in_series ( self ) \u00a4 On every step, produce an actionable plan Returns: Type Description VehicleControl Source code in ROAR/planning_module/local_planner/local_planner.py @abstractmethod def run_in_series ( self ) -> VehicleControl : return VehicleControl () rl_local_planner \u00a4 RLLocalPlanner \u00a4 __init__ ( self , agent , controller ) special \u00a4 Initialize Simple Waypoint Following Planner Parameters: Name Type Description Default agent Agent newest agent state required controller Controller Control module used required Source code in ROAR/planning_module/local_planner/rl_local_planner.py def __init__ ( self , agent : Agent , controller : Controller , ): \"\"\" Initialize Simple Waypoint Following Planner Args: agent: newest agent state controller: Control module used \"\"\" super () . __init__ ( agent = agent , controller = controller ) self . logger = logging . getLogger ( \"SimplePathFollowingLocalPlanner\" ) self . logger . debug ( \"Simple Path Following Local Planner Initiated\" ) self . way_points_queue = deque ( maxlen = 10 ) is_done ( self ) \u00a4 If there are nothing in self.way_points_queue, that means you have finished a lap, you are done Returns: Type Description bool True if Done, False otherwise Source code in ROAR/planning_module/local_planner/rl_local_planner.py def is_done ( self ) -> bool : \"\"\" If there are nothing in self.way_points_queue, that means you have finished a lap, you are done Returns: True if Done, False otherwise \"\"\" return False run_in_series ( self ) \u00a4 On every step, produce an actionable plan Returns: Type Description VehicleControl Source code in ROAR/planning_module/local_planner/rl_local_planner.py def run_in_series ( self ) -> VehicleControl : next_waypoint : Transform = self . agent . kwargs . get ( \"next_waypoint\" , self . agent . vehicle . transform ) self . way_points_queue . append ( next_waypoint ) control = self . controller . run_in_series ( next_waypoint = next_waypoint ) return control simple_waypoint_following_local_planner \u00a4 SimpleWaypointFollowingLocalPlanner \u00a4 __init__ ( self , agent , controller , mission_planner , behavior_planner , closeness_threshold = 0.5 ) special \u00a4 Initialize Simple Waypoint Following Planner Parameters: Name Type Description Default agent Agent newest agent state required controller Controller Control module used required mission_planner MissionPlanner mission planner used required behavior_planner BehaviorPlanner behavior planner used required closeness_threshold how close can a waypoint be with the vehicle 0.5 Source code in ROAR/planning_module/local_planner/simple_waypoint_following_local_planner.py def __init__ ( self , agent : Agent , controller : Controller , mission_planner : MissionPlanner , behavior_planner : BehaviorPlanner , closeness_threshold = 0.5 , ): \"\"\" Initialize Simple Waypoint Following Planner Args: agent: newest agent state controller: Control module used mission_planner: mission planner used behavior_planner: behavior planner used closeness_threshold: how close can a waypoint be with the vehicle \"\"\" super () . __init__ ( agent = agent , controller = controller , mission_planner = mission_planner , behavior_planner = behavior_planner , ) self . logger = logging . getLogger ( \"SimplePathFollowingLocalPlanner\" ) self . set_mission_plan () self . logger . debug ( \"Simple Path Following Local Planner Initiated\" ) self . closeness_threshold = closeness_threshold self . closeness_threshold_config = json . load ( Path ( agent . agent_settings . simple_waypoint_local_planner_config_file_path ) . open ( mode = 'r' )) is_done ( self ) \u00a4 If there are nothing in self.way_points_queue, that means you have finished a lap, you are done Returns: Type Description bool True if Done, False otherwise Source code in ROAR/planning_module/local_planner/simple_waypoint_following_local_planner.py def is_done ( self ) -> bool : \"\"\" If there are nothing in self.way_points_queue, that means you have finished a lap, you are done Returns: True if Done, False otherwise \"\"\" return len ( self . way_points_queue ) == 0 run_in_series ( self ) \u00a4 Procedure Sync data get the correct look ahead for current speed get the correct next waypoint feed waypoint into controller return result from controller Returns: Type Description VehicleControl next control that the local think the agent should execute. Source code in ROAR/planning_module/local_planner/simple_waypoint_following_local_planner.py def run_in_series ( self ) -> VehicleControl : \"\"\" Run step for the local planner Procedure: 1. Sync data 2. get the correct look ahead for current speed 3. get the correct next waypoint 4. feed waypoint into controller 5. return result from controller Returns: next control that the local think the agent should execute. \"\"\" if ( len ( self . mission_planner . mission_plan ) == 0 and len ( self . way_points_queue ) == 0 ): return VehicleControl () # get vehicle's location vehicle_transform : Union [ Transform , None ] = self . agent . vehicle . transform if vehicle_transform is None : raise AgentException ( \"I do not know where I am, I cannot proceed forward\" ) # redefine closeness level based on speed self . set_closeness_threhold ( self . closeness_threshold_config ) # get current waypoint curr_closest_dist = float ( \"inf\" ) while True : if len ( self . way_points_queue ) == 0 : self . logger . info ( \"Destination reached\" ) return VehicleControl () waypoint : Transform = self . way_points_queue [ 0 ] curr_dist = vehicle_transform . location . distance ( waypoint . location ) if curr_dist < curr_closest_dist : # if i find a waypoint that is closer to me than before # note that i will always enter here to start the calculation for curr_closest_dist curr_closest_dist = curr_dist elif curr_dist < self . closeness_threshold : # i have moved onto a waypoint, remove that waypoint from the queue self . way_points_queue . popleft () else : break target_waypoint = self . way_points_queue [ 0 ] control : VehicleControl = self . controller . run_in_series ( next_waypoint = target_waypoint ) # self.logger.debug(f\"\\n\" # f\"Curr Transform: {self.agent.vehicle.transform}\\n\" # f\"Target Location: {target_waypoint.location}\\n\" # f\"Control: {control} | Speed: {Vehicle.get_speed(self.agent.vehicle)}\\n\") return control set_closeness_threhold ( self , config ) \u00a4 Source code in ROAR/planning_module/local_planner/simple_waypoint_following_local_planner.py def set_closeness_threhold ( self , config : dict ): curr_speed = Vehicle . get_speed ( self . agent . vehicle ) for speed_upper_bound , closeness_threshold in config . items (): speed_upper_bound = float ( speed_upper_bound ) if curr_speed < speed_upper_bound : self . closeness_threshold = closeness_threshold break set_mission_plan ( self ) \u00a4 Clears current waypoints, and reset mission plan from start I am simply transferring the mission plan into my waypoint queue. Assuming that this current run will run all the way to the end Returns: Type Description None None Source code in ROAR/planning_module/local_planner/simple_waypoint_following_local_planner.py def set_mission_plan ( self ) -> None : \"\"\" Clears current waypoints, and reset mission plan from start I am simply transferring the mission plan into my waypoint queue. Assuming that this current run will run all the way to the end Returns: None \"\"\" self . way_points_queue . clear () while ( self . mission_planner . mission_plan ): # this actually clears the mission plan!! self . way_points_queue . append ( self . mission_planner . mission_plan . popleft ()) smooth_waypoint_following_local_planner \u00a4 SmoothWaypointFollowingLocalPlanner \u00a4 Waypoint following local planner with waypoint lookahead for smoothing and target speed reduction. next_waypoint_smooth_and_speed ( self , smooth_lookahead = 400 , speed_lookahead = 600 , min_speed_multiplier = 0.6 , speed_multiplier_slope = 1.3 ) \u00a4 Calculate the next target waypoint and speed for the controller. Parameters smooth_lookahead : int Number of waypoints ahead to look at to compute the smoothed waypoint. speed_lookahead : int Number of waypoint to look ahaed to compute speed factor. min_speed_multiplier : float The minimum value for the speed multiplier. speed_multiplier_slope : float The rate of speed multiplier decrease for every 180 degrees of angle error. Returns target_waypoint : Transform The next target waypoint for the controller speed_multiplier : float The speed multiplier for the controller's target speed. Source code in ROAR/planning_module/local_planner/smooth_waypoint_following_local_planner.py def next_waypoint_smooth_and_speed ( self , smooth_lookahead = 400 , speed_lookahead = 600 , min_speed_multiplier = 0.6 , speed_multiplier_slope = 1.3 ) -> ( Transform , float ): \"\"\" Calculate the next target waypoint and speed for the controller. Parameters smooth_lookahead : int Number of waypoints ahead to look at to compute the smoothed waypoint. speed_lookahead : int Number of waypoint to look ahaed to compute speed factor. min_speed_multiplier : float The minimum value for the speed multiplier. speed_multiplier_slope : float The rate of speed multiplier decrease for every 180 degrees of angle error. Returns target_waypoint : Transform The next target waypoint for the controller speed_multiplier : float The speed multiplier for the controller's target speed. \"\"\" smooth_lookahead = min ( smooth_lookahead , len ( self . way_points_queue ) - 1 ) speed_lookahead = min ( speed_lookahead , len ( self . way_points_queue ) - 1 ) if smooth_lookahead > 10 : # Reduce computation by only looking at every 10 steps ahead sample_points = range ( 0 , smooth_lookahead , smooth_lookahead // 10 ) location_sum = reduce ( lambda x , y : x + y , ( self . way_points_queue [ i ] . location for i in sample_points )) rotation_sum = reduce ( lambda x , y : x + y , ( self . way_points_queue [ i ] . rotation for i in sample_points )) num_points = len ( sample_points ) target_waypoint = Transform ( location = location_sum / num_points , rotation = rotation_sum / num_points ) else : target_waypoint = self . way_points_queue [ - 1 ] if speed_lookahead > 0 : angle_difference = self . _calculate_angle_error ( self . way_points_queue [ speed_lookahead ]) # Angle difference is between 0 and 180, but unlikely to be more than 90 speed_multiplier = max ( min_speed_multiplier , ( 1.0 - speed_multiplier_slope * angle_difference / np . pi )) else : speed_multiplier = 1.0 return target_waypoint , speed_multiplier run_in_series ( self ) \u00a4 Procedure Sync data get the correct look ahead for current speed get the correct next waypoint feed waypoint into controller return result from controller Returns: Type Description VehicleControl next control that the local think the agent should execute. Source code in ROAR/planning_module/local_planner/smooth_waypoint_following_local_planner.py def run_in_series ( self ) -> VehicleControl : \"\"\" Run step for the local planner Procedure: 1. Sync data 2. get the correct look ahead for current speed 3. get the correct next waypoint 4. feed waypoint into controller 5. return result from controller Returns: next control that the local think the agent should execute. \"\"\" if ( len ( self . mission_planner . mission_plan ) == 0 and len ( self . way_points_queue ) == 0 ): return VehicleControl () # get vehicle's location vehicle_transform : Union [ Transform , None ] = self . agent . vehicle . transform if vehicle_transform is None : raise AgentException ( \"I do not know where I am, I cannot proceed forward\" ) # redefine closeness level based on speed self . set_closeness_threhold ( self . closeness_threshold_config ) # get current waypoint curr_closest_dist = float ( \"inf\" ) while True : if len ( self . way_points_queue ) == 0 : self . logger . info ( \"Destination reached\" ) return VehicleControl () # waypoint: Transform = self.way_points_queue[0] waypoint , speed_factor = self . next_waypoint_smooth_and_speed () curr_dist = vehicle_transform . location . distance ( waypoint . location ) if curr_dist < curr_closest_dist : # if i find a waypoint that is closer to me than before # note that i will always enter here to start the calculation for curr_closest_dist curr_closest_dist = curr_dist elif curr_dist < self . closeness_threshold : # i have moved onto a waypoint, remove that waypoint from the queue self . way_points_queue . popleft () else : break target_waypoint , speed_factor = self . next_waypoint_smooth_and_speed () control : VehicleControl = self . controller . run_in_series ( next_waypoint = target_waypoint , speed_multiplier = speed_factor ) self . logger . debug ( f \" \\n \" f \"Curr Transform: { self . agent . vehicle . transform } \\n \" f \"Target Location: { target_waypoint . location } \\n \" f \"Control: { control } | Speed: { Vehicle . get_speed ( self . agent . vehicle ) } \\n \" ) return control mission_planner special \u00a4 json_waypoint_planner \u00a4 JSONWaypointPlanner \u00a4 __init__ ( self , agent ) special \u00a4 Source code in ROAR/planning_module/mission_planner/json_waypoint_planner.py def __init__ ( self , agent : Agent ): super () . __init__ ( agent = agent ) self . file_path : Path = Path ( self . agent . agent_config . json_waypoint_file_path ) self . mission_plan : deque = self . run_in_series () run_in_series ( self ) \u00a4 Abstract run step function for Mission Planner Parameters: Name Type Description Default vehicle new vehicle state required Returns: Type Description deque Plan for next steps Source code in ROAR/planning_module/mission_planner/json_waypoint_planner.py def run_in_series ( self ) -> deque : result = deque () map_entries = self . _read_data_file () for m in map_entries : result . append ( self . _map_entry_to_transform ( map_entry = m )) return result mission_planner \u00a4 MissionPlanner \u00a4 __init__ ( self , agent , ** kwargs ) special \u00a4 Source code in ROAR/planning_module/mission_planner/mission_planner.py def __init__ ( self , agent , ** kwargs ): super () . __init__ ( agent = agent , ** kwargs ) self . logger = logging . getLogger ( __name__ ) self . mission_plan : deque = deque () run_in_series ( self ) \u00a4 Abstract run step function for Mission Planner Parameters: Name Type Description Default vehicle new vehicle state required Returns: Type Description List[ROAR.utilities_module.data_structures_models.Transform] Plan for next steps Source code in ROAR/planning_module/mission_planner/mission_planner.py def run_in_series ( self ) -> List [ Transform ]: \"\"\" Abstract run step function for Mission Planner Args: vehicle: new vehicle state Returns: Plan for next steps \"\"\" return [] waypoint_following_mission_planner \u00a4 WaypointFollowingMissionPlanner \u00a4 A mission planner that takes in a file that contains x,y,z coordinates, formulate into carla.Transform __init__ ( self , agent ) special \u00a4 Source code in ROAR/planning_module/mission_planner/waypoint_following_mission_planner.py def __init__ ( self , agent : Agent ): super () . __init__ ( agent = agent ) self . logger = logging . getLogger ( __name__ ) self . file_path : Path = Path ( self . agent . agent_settings . waypoint_file_path ) self . mission_plan = self . produce_mission_plan () self . logger . debug ( \"Path Following Mission Planner Initiated.\" ) produce_mission_plan ( self ) \u00a4 Generates a list of waypoints based on the input file path :return a list of waypoint Source code in ROAR/planning_module/mission_planner/waypoint_following_mission_planner.py def produce_mission_plan ( self ) -> deque : \"\"\" Generates a list of waypoints based on the input file path :return a list of waypoint \"\"\" raw_path : List [ List [ float ]] = self . _read_data_file () length = self . agent . agent_settings . num_laps * len ( raw_path ) mission_plan = deque ( maxlen = length ) for coord in np . tile ( raw_path , ( self . agent . agent_settings . num_laps , 1 )): if len ( coord ) == 3 or len ( coord ) == 6 : mission_plan . append ( self . _raw_coord_to_transform ( coord )) self . logger . debug ( f \"Computed Mission path of length [ { len ( mission_plan ) } ]\" ) return mission_plan produce_single_lap_mission_plan ( self ) \u00a4 Source code in ROAR/planning_module/mission_planner/waypoint_following_mission_planner.py def produce_single_lap_mission_plan ( self ): raw_path : List [ List [ float ]] = self . _read_data_file () mission_plan = deque ( maxlen = len ( raw_path )) for coord in raw_path : if len ( coord ) == 3 or len ( coord ) == 6 : mission_plan . append ( self . _raw_coord_to_transform ( coord )) self . logger . debug ( f \"Computed Mission path of length [ { len ( mission_plan ) } ]\" ) return mission_plan run_in_series ( self ) \u00a4 Regenerate waypoints from file Find the waypoint that is closest to the current vehicle location. return a mission plan starting from that waypoint Parameters: Name Type Description Default vehicle current state of the vehicle required Returns: Type Description deque mission plan that start from the current vehicle location Source code in ROAR/planning_module/mission_planner/waypoint_following_mission_planner.py def run_in_series ( self ) -> deque : \"\"\" Regenerate waypoints from file Find the waypoint that is closest to the current vehicle location. return a mission plan starting from that waypoint Args: vehicle: current state of the vehicle Returns: mission plan that start from the current vehicle location \"\"\" super ( WaypointFollowingMissionPlanner , self ) . run_in_series () return self . produce_mission_plan ()","title":"Planning Module"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.abstract_planner","text":"","title":"abstract_planner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.abstract_planner.AbstractPlanner","text":"","title":"AbstractPlanner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.abstract_planner.AbstractPlanner.__init__","text":"Source code in ROAR/planning_module/abstract_planner.py def __init__ ( self , agent , ** kwargs ): super () . __init__ ( ** kwargs ) self . logger = logging self . logger = logging . getLogger ( __name__ ) self . agent = agent","title":"__init__()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.abstract_planner.AbstractPlanner.run_in_series","text":"On every step, produce an actionable plan Returns: Type Description Any Source code in ROAR/planning_module/abstract_planner.py @abstractmethod def run_in_series ( self , ** kwargs ) -> Any : \"\"\" On every step, produce an actionable plan Returns: \"\"\" return None","title":"run_in_series()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.abstract_planner.AbstractPlanner.run_in_threaded","text":"This is the threaded function. Parameters: Name Type Description Default **kwargs {} Source code in ROAR/planning_module/abstract_planner.py def run_in_threaded ( self , ** kwargs ): pass","title":"run_in_threaded()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.abstract_planner.AbstractPlanner.save","text":"Source code in ROAR/planning_module/abstract_planner.py def save ( self , ** kwargs ): pass","title":"save()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.behavior_planner","text":"","title":"behavior_planner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.behavior_planner.behavior_planner","text":"","title":"behavior_planner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.behavior_planner.behavior_planner.BehaviorPlanner","text":"","title":"BehaviorPlanner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.behavior_planner.behavior_planner.BehaviorPlanner.__init__","text":"Source code in ROAR/planning_module/behavior_planner/behavior_planner.py def __init__ ( self , agent , ** kwargs ): super () . __init__ ( agent , ** kwargs )","title":"__init__()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.behavior_planner.behavior_planner.BehaviorPlanner.run_in_series","text":"On every step, produce an actionable plan Returns: Type Description Any Source code in ROAR/planning_module/behavior_planner/behavior_planner.py def run_in_series ( self ) -> Any : pass","title":"run_in_series()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner","text":"","title":"local_planner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.floodfill_based_planner","text":"","title":"floodfill_based_planner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.floodfill_based_planner.FloodfillBasedPlanner","text":"","title":"FloodfillBasedPlanner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.floodfill_based_planner.FloodfillBasedPlanner.run_in_series","text":"On every step, produce an actionable plan Returns: Type Description VehicleControl Source code in ROAR/planning_module/local_planner/floodfill_based_planner.py def run_in_series ( self ) -> VehicleControl : pass","title":"run_in_series()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.local_planner","text":"","title":"local_planner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.local_planner.LocalPlanner","text":"","title":"LocalPlanner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.local_planner.LocalPlanner.__init__","text":"Source code in ROAR/planning_module/local_planner/local_planner.py def __init__ ( self , agent , controller : Optional [ Controller ] = None , behavior_planner : Optional [ BehaviorPlanner ] = None , mission_planner : Optional [ MissionPlanner ] = None , ** kwargs ): super () . __init__ ( agent = agent , ** kwargs ) self . controller = ( Controller ( agent = agent ) if controller is None else controller ) self . behavior_planner = ( BehaviorPlanner ( agent = agent ) if behavior_planner is None else behavior_planner ) self . mission_planner = ( MissionPlanner ( agent = agent ) if mission_planner is None else mission_planner ) self . way_points_queue = deque ()","title":"__init__()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.local_planner.LocalPlanner.is_done","text":"Source code in ROAR/planning_module/local_planner/local_planner.py @abstractmethod def is_done ( self ): return False","title":"is_done()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.local_planner.LocalPlanner.run_in_series","text":"On every step, produce an actionable plan Returns: Type Description VehicleControl Source code in ROAR/planning_module/local_planner/local_planner.py @abstractmethod def run_in_series ( self ) -> VehicleControl : return VehicleControl ()","title":"run_in_series()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.rl_local_planner","text":"","title":"rl_local_planner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.rl_local_planner.RLLocalPlanner","text":"","title":"RLLocalPlanner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.rl_local_planner.RLLocalPlanner.__init__","text":"Initialize Simple Waypoint Following Planner Parameters: Name Type Description Default agent Agent newest agent state required controller Controller Control module used required Source code in ROAR/planning_module/local_planner/rl_local_planner.py def __init__ ( self , agent : Agent , controller : Controller , ): \"\"\" Initialize Simple Waypoint Following Planner Args: agent: newest agent state controller: Control module used \"\"\" super () . __init__ ( agent = agent , controller = controller ) self . logger = logging . getLogger ( \"SimplePathFollowingLocalPlanner\" ) self . logger . debug ( \"Simple Path Following Local Planner Initiated\" ) self . way_points_queue = deque ( maxlen = 10 )","title":"__init__()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.rl_local_planner.RLLocalPlanner.is_done","text":"If there are nothing in self.way_points_queue, that means you have finished a lap, you are done Returns: Type Description bool True if Done, False otherwise Source code in ROAR/planning_module/local_planner/rl_local_planner.py def is_done ( self ) -> bool : \"\"\" If there are nothing in self.way_points_queue, that means you have finished a lap, you are done Returns: True if Done, False otherwise \"\"\" return False","title":"is_done()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.rl_local_planner.RLLocalPlanner.run_in_series","text":"On every step, produce an actionable plan Returns: Type Description VehicleControl Source code in ROAR/planning_module/local_planner/rl_local_planner.py def run_in_series ( self ) -> VehicleControl : next_waypoint : Transform = self . agent . kwargs . get ( \"next_waypoint\" , self . agent . vehicle . transform ) self . way_points_queue . append ( next_waypoint ) control = self . controller . run_in_series ( next_waypoint = next_waypoint ) return control","title":"run_in_series()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.simple_waypoint_following_local_planner","text":"","title":"simple_waypoint_following_local_planner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.simple_waypoint_following_local_planner.SimpleWaypointFollowingLocalPlanner","text":"","title":"SimpleWaypointFollowingLocalPlanner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.simple_waypoint_following_local_planner.SimpleWaypointFollowingLocalPlanner.__init__","text":"Initialize Simple Waypoint Following Planner Parameters: Name Type Description Default agent Agent newest agent state required controller Controller Control module used required mission_planner MissionPlanner mission planner used required behavior_planner BehaviorPlanner behavior planner used required closeness_threshold how close can a waypoint be with the vehicle 0.5 Source code in ROAR/planning_module/local_planner/simple_waypoint_following_local_planner.py def __init__ ( self , agent : Agent , controller : Controller , mission_planner : MissionPlanner , behavior_planner : BehaviorPlanner , closeness_threshold = 0.5 , ): \"\"\" Initialize Simple Waypoint Following Planner Args: agent: newest agent state controller: Control module used mission_planner: mission planner used behavior_planner: behavior planner used closeness_threshold: how close can a waypoint be with the vehicle \"\"\" super () . __init__ ( agent = agent , controller = controller , mission_planner = mission_planner , behavior_planner = behavior_planner , ) self . logger = logging . getLogger ( \"SimplePathFollowingLocalPlanner\" ) self . set_mission_plan () self . logger . debug ( \"Simple Path Following Local Planner Initiated\" ) self . closeness_threshold = closeness_threshold self . closeness_threshold_config = json . load ( Path ( agent . agent_settings . simple_waypoint_local_planner_config_file_path ) . open ( mode = 'r' ))","title":"__init__()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.simple_waypoint_following_local_planner.SimpleWaypointFollowingLocalPlanner.is_done","text":"If there are nothing in self.way_points_queue, that means you have finished a lap, you are done Returns: Type Description bool True if Done, False otherwise Source code in ROAR/planning_module/local_planner/simple_waypoint_following_local_planner.py def is_done ( self ) -> bool : \"\"\" If there are nothing in self.way_points_queue, that means you have finished a lap, you are done Returns: True if Done, False otherwise \"\"\" return len ( self . way_points_queue ) == 0","title":"is_done()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.simple_waypoint_following_local_planner.SimpleWaypointFollowingLocalPlanner.run_in_series","text":"Procedure Sync data get the correct look ahead for current speed get the correct next waypoint feed waypoint into controller return result from controller Returns: Type Description VehicleControl next control that the local think the agent should execute. Source code in ROAR/planning_module/local_planner/simple_waypoint_following_local_planner.py def run_in_series ( self ) -> VehicleControl : \"\"\" Run step for the local planner Procedure: 1. Sync data 2. get the correct look ahead for current speed 3. get the correct next waypoint 4. feed waypoint into controller 5. return result from controller Returns: next control that the local think the agent should execute. \"\"\" if ( len ( self . mission_planner . mission_plan ) == 0 and len ( self . way_points_queue ) == 0 ): return VehicleControl () # get vehicle's location vehicle_transform : Union [ Transform , None ] = self . agent . vehicle . transform if vehicle_transform is None : raise AgentException ( \"I do not know where I am, I cannot proceed forward\" ) # redefine closeness level based on speed self . set_closeness_threhold ( self . closeness_threshold_config ) # get current waypoint curr_closest_dist = float ( \"inf\" ) while True : if len ( self . way_points_queue ) == 0 : self . logger . info ( \"Destination reached\" ) return VehicleControl () waypoint : Transform = self . way_points_queue [ 0 ] curr_dist = vehicle_transform . location . distance ( waypoint . location ) if curr_dist < curr_closest_dist : # if i find a waypoint that is closer to me than before # note that i will always enter here to start the calculation for curr_closest_dist curr_closest_dist = curr_dist elif curr_dist < self . closeness_threshold : # i have moved onto a waypoint, remove that waypoint from the queue self . way_points_queue . popleft () else : break target_waypoint = self . way_points_queue [ 0 ] control : VehicleControl = self . controller . run_in_series ( next_waypoint = target_waypoint ) # self.logger.debug(f\"\\n\" # f\"Curr Transform: {self.agent.vehicle.transform}\\n\" # f\"Target Location: {target_waypoint.location}\\n\" # f\"Control: {control} | Speed: {Vehicle.get_speed(self.agent.vehicle)}\\n\") return control","title":"run_in_series()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.simple_waypoint_following_local_planner.SimpleWaypointFollowingLocalPlanner.set_closeness_threhold","text":"Source code in ROAR/planning_module/local_planner/simple_waypoint_following_local_planner.py def set_closeness_threhold ( self , config : dict ): curr_speed = Vehicle . get_speed ( self . agent . vehicle ) for speed_upper_bound , closeness_threshold in config . items (): speed_upper_bound = float ( speed_upper_bound ) if curr_speed < speed_upper_bound : self . closeness_threshold = closeness_threshold break","title":"set_closeness_threhold()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.simple_waypoint_following_local_planner.SimpleWaypointFollowingLocalPlanner.set_mission_plan","text":"Clears current waypoints, and reset mission plan from start I am simply transferring the mission plan into my waypoint queue. Assuming that this current run will run all the way to the end Returns: Type Description None None Source code in ROAR/planning_module/local_planner/simple_waypoint_following_local_planner.py def set_mission_plan ( self ) -> None : \"\"\" Clears current waypoints, and reset mission plan from start I am simply transferring the mission plan into my waypoint queue. Assuming that this current run will run all the way to the end Returns: None \"\"\" self . way_points_queue . clear () while ( self . mission_planner . mission_plan ): # this actually clears the mission plan!! self . way_points_queue . append ( self . mission_planner . mission_plan . popleft ())","title":"set_mission_plan()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.smooth_waypoint_following_local_planner","text":"","title":"smooth_waypoint_following_local_planner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.smooth_waypoint_following_local_planner.SmoothWaypointFollowingLocalPlanner","text":"Waypoint following local planner with waypoint lookahead for smoothing and target speed reduction.","title":"SmoothWaypointFollowingLocalPlanner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.smooth_waypoint_following_local_planner.SmoothWaypointFollowingLocalPlanner.next_waypoint_smooth_and_speed","text":"Calculate the next target waypoint and speed for the controller. Parameters smooth_lookahead : int Number of waypoints ahead to look at to compute the smoothed waypoint. speed_lookahead : int Number of waypoint to look ahaed to compute speed factor. min_speed_multiplier : float The minimum value for the speed multiplier. speed_multiplier_slope : float The rate of speed multiplier decrease for every 180 degrees of angle error. Returns target_waypoint : Transform The next target waypoint for the controller speed_multiplier : float The speed multiplier for the controller's target speed. Source code in ROAR/planning_module/local_planner/smooth_waypoint_following_local_planner.py def next_waypoint_smooth_and_speed ( self , smooth_lookahead = 400 , speed_lookahead = 600 , min_speed_multiplier = 0.6 , speed_multiplier_slope = 1.3 ) -> ( Transform , float ): \"\"\" Calculate the next target waypoint and speed for the controller. Parameters smooth_lookahead : int Number of waypoints ahead to look at to compute the smoothed waypoint. speed_lookahead : int Number of waypoint to look ahaed to compute speed factor. min_speed_multiplier : float The minimum value for the speed multiplier. speed_multiplier_slope : float The rate of speed multiplier decrease for every 180 degrees of angle error. Returns target_waypoint : Transform The next target waypoint for the controller speed_multiplier : float The speed multiplier for the controller's target speed. \"\"\" smooth_lookahead = min ( smooth_lookahead , len ( self . way_points_queue ) - 1 ) speed_lookahead = min ( speed_lookahead , len ( self . way_points_queue ) - 1 ) if smooth_lookahead > 10 : # Reduce computation by only looking at every 10 steps ahead sample_points = range ( 0 , smooth_lookahead , smooth_lookahead // 10 ) location_sum = reduce ( lambda x , y : x + y , ( self . way_points_queue [ i ] . location for i in sample_points )) rotation_sum = reduce ( lambda x , y : x + y , ( self . way_points_queue [ i ] . rotation for i in sample_points )) num_points = len ( sample_points ) target_waypoint = Transform ( location = location_sum / num_points , rotation = rotation_sum / num_points ) else : target_waypoint = self . way_points_queue [ - 1 ] if speed_lookahead > 0 : angle_difference = self . _calculate_angle_error ( self . way_points_queue [ speed_lookahead ]) # Angle difference is between 0 and 180, but unlikely to be more than 90 speed_multiplier = max ( min_speed_multiplier , ( 1.0 - speed_multiplier_slope * angle_difference / np . pi )) else : speed_multiplier = 1.0 return target_waypoint , speed_multiplier","title":"next_waypoint_smooth_and_speed()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.local_planner.smooth_waypoint_following_local_planner.SmoothWaypointFollowingLocalPlanner.run_in_series","text":"Procedure Sync data get the correct look ahead for current speed get the correct next waypoint feed waypoint into controller return result from controller Returns: Type Description VehicleControl next control that the local think the agent should execute. Source code in ROAR/planning_module/local_planner/smooth_waypoint_following_local_planner.py def run_in_series ( self ) -> VehicleControl : \"\"\" Run step for the local planner Procedure: 1. Sync data 2. get the correct look ahead for current speed 3. get the correct next waypoint 4. feed waypoint into controller 5. return result from controller Returns: next control that the local think the agent should execute. \"\"\" if ( len ( self . mission_planner . mission_plan ) == 0 and len ( self . way_points_queue ) == 0 ): return VehicleControl () # get vehicle's location vehicle_transform : Union [ Transform , None ] = self . agent . vehicle . transform if vehicle_transform is None : raise AgentException ( \"I do not know where I am, I cannot proceed forward\" ) # redefine closeness level based on speed self . set_closeness_threhold ( self . closeness_threshold_config ) # get current waypoint curr_closest_dist = float ( \"inf\" ) while True : if len ( self . way_points_queue ) == 0 : self . logger . info ( \"Destination reached\" ) return VehicleControl () # waypoint: Transform = self.way_points_queue[0] waypoint , speed_factor = self . next_waypoint_smooth_and_speed () curr_dist = vehicle_transform . location . distance ( waypoint . location ) if curr_dist < curr_closest_dist : # if i find a waypoint that is closer to me than before # note that i will always enter here to start the calculation for curr_closest_dist curr_closest_dist = curr_dist elif curr_dist < self . closeness_threshold : # i have moved onto a waypoint, remove that waypoint from the queue self . way_points_queue . popleft () else : break target_waypoint , speed_factor = self . next_waypoint_smooth_and_speed () control : VehicleControl = self . controller . run_in_series ( next_waypoint = target_waypoint , speed_multiplier = speed_factor ) self . logger . debug ( f \" \\n \" f \"Curr Transform: { self . agent . vehicle . transform } \\n \" f \"Target Location: { target_waypoint . location } \\n \" f \"Control: { control } | Speed: { Vehicle . get_speed ( self . agent . vehicle ) } \\n \" ) return control","title":"run_in_series()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner","text":"","title":"mission_planner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.json_waypoint_planner","text":"","title":"json_waypoint_planner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.json_waypoint_planner.JSONWaypointPlanner","text":"","title":"JSONWaypointPlanner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.json_waypoint_planner.JSONWaypointPlanner.__init__","text":"Source code in ROAR/planning_module/mission_planner/json_waypoint_planner.py def __init__ ( self , agent : Agent ): super () . __init__ ( agent = agent ) self . file_path : Path = Path ( self . agent . agent_config . json_waypoint_file_path ) self . mission_plan : deque = self . run_in_series ()","title":"__init__()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.json_waypoint_planner.JSONWaypointPlanner.run_in_series","text":"Abstract run step function for Mission Planner Parameters: Name Type Description Default vehicle new vehicle state required Returns: Type Description deque Plan for next steps Source code in ROAR/planning_module/mission_planner/json_waypoint_planner.py def run_in_series ( self ) -> deque : result = deque () map_entries = self . _read_data_file () for m in map_entries : result . append ( self . _map_entry_to_transform ( map_entry = m )) return result","title":"run_in_series()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.mission_planner","text":"","title":"mission_planner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.mission_planner.MissionPlanner","text":"","title":"MissionPlanner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.mission_planner.MissionPlanner.__init__","text":"Source code in ROAR/planning_module/mission_planner/mission_planner.py def __init__ ( self , agent , ** kwargs ): super () . __init__ ( agent = agent , ** kwargs ) self . logger = logging . getLogger ( __name__ ) self . mission_plan : deque = deque ()","title":"__init__()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.mission_planner.MissionPlanner.run_in_series","text":"Abstract run step function for Mission Planner Parameters: Name Type Description Default vehicle new vehicle state required Returns: Type Description List[ROAR.utilities_module.data_structures_models.Transform] Plan for next steps Source code in ROAR/planning_module/mission_planner/mission_planner.py def run_in_series ( self ) -> List [ Transform ]: \"\"\" Abstract run step function for Mission Planner Args: vehicle: new vehicle state Returns: Plan for next steps \"\"\" return []","title":"run_in_series()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.waypoint_following_mission_planner","text":"","title":"waypoint_following_mission_planner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.waypoint_following_mission_planner.WaypointFollowingMissionPlanner","text":"A mission planner that takes in a file that contains x,y,z coordinates, formulate into carla.Transform","title":"WaypointFollowingMissionPlanner"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.waypoint_following_mission_planner.WaypointFollowingMissionPlanner.__init__","text":"Source code in ROAR/planning_module/mission_planner/waypoint_following_mission_planner.py def __init__ ( self , agent : Agent ): super () . __init__ ( agent = agent ) self . logger = logging . getLogger ( __name__ ) self . file_path : Path = Path ( self . agent . agent_settings . waypoint_file_path ) self . mission_plan = self . produce_mission_plan () self . logger . debug ( \"Path Following Mission Planner Initiated.\" )","title":"__init__()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.waypoint_following_mission_planner.WaypointFollowingMissionPlanner.produce_mission_plan","text":"Generates a list of waypoints based on the input file path :return a list of waypoint Source code in ROAR/planning_module/mission_planner/waypoint_following_mission_planner.py def produce_mission_plan ( self ) -> deque : \"\"\" Generates a list of waypoints based on the input file path :return a list of waypoint \"\"\" raw_path : List [ List [ float ]] = self . _read_data_file () length = self . agent . agent_settings . num_laps * len ( raw_path ) mission_plan = deque ( maxlen = length ) for coord in np . tile ( raw_path , ( self . agent . agent_settings . num_laps , 1 )): if len ( coord ) == 3 or len ( coord ) == 6 : mission_plan . append ( self . _raw_coord_to_transform ( coord )) self . logger . debug ( f \"Computed Mission path of length [ { len ( mission_plan ) } ]\" ) return mission_plan","title":"produce_mission_plan()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.waypoint_following_mission_planner.WaypointFollowingMissionPlanner.produce_single_lap_mission_plan","text":"Source code in ROAR/planning_module/mission_planner/waypoint_following_mission_planner.py def produce_single_lap_mission_plan ( self ): raw_path : List [ List [ float ]] = self . _read_data_file () mission_plan = deque ( maxlen = len ( raw_path )) for coord in raw_path : if len ( coord ) == 3 or len ( coord ) == 6 : mission_plan . append ( self . _raw_coord_to_transform ( coord )) self . logger . debug ( f \"Computed Mission path of length [ { len ( mission_plan ) } ]\" ) return mission_plan","title":"produce_single_lap_mission_plan()"},{"location":"code_documentations/ROAR/planning_module/#ROAR.planning_module.mission_planner.waypoint_following_mission_planner.WaypointFollowingMissionPlanner.run_in_series","text":"Regenerate waypoints from file Find the waypoint that is closest to the current vehicle location. return a mission plan starting from that waypoint Parameters: Name Type Description Default vehicle current state of the vehicle required Returns: Type Description deque mission plan that start from the current vehicle location Source code in ROAR/planning_module/mission_planner/waypoint_following_mission_planner.py def run_in_series ( self ) -> deque : \"\"\" Regenerate waypoints from file Find the waypoint that is closest to the current vehicle location. return a mission plan starting from that waypoint Args: vehicle: current state of the vehicle Returns: mission plan that start from the current vehicle location \"\"\" super ( WaypointFollowingMissionPlanner , self ) . run_in_series () return self . produce_mission_plan ()","title":"run_in_series()"},{"location":"code_documentations/ROAR/utilities_module/","text":"camera_models \u00a4 Camera pydantic-model \u00a4 data : ndarray pydantic-field \u00a4 distortion_coefficient : ndarray pydantic-field \u00a4 fov : int pydantic-field \u00a4 image_size_x : int pydantic-field \u00a4 image_size_y : int pydantic-field \u00a4 intrinsics_matrix : ndarray pydantic-field \u00a4 transform : Transform pydantic-field \u00a4 __config__ \u00a4 Config \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 calculate_default_intrinsics_matrix ( self ) \u00a4 Calculate intrinsics matrix Will set the attribute intrinsic matrix so that re-calculation is not necessary. https://github.com/carla-simulator/carla/issues/56 [ ax, 0, cx, 0, ay, cy, 0 , 0, 1 ] Returns: Type Description ndarray Intrinsics_matrix Source code in ROAR/utilities_module/camera_models.py def calculate_default_intrinsics_matrix ( self ) -> np . ndarray : \"\"\" Calculate intrinsics matrix Will set the attribute intrinsic matrix so that re-calculation is not necessary. https://github.com/carla-simulator/carla/issues/56 [ ax, 0, cx, 0, ay, cy, 0 , 0, 1 ] Returns: Intrinsics_matrix \"\"\" intrinsics_matrix = np . identity ( 3 ) intrinsics_matrix [ 0 , 2 ] = self . image_size_x / 2.0 intrinsics_matrix [ 1 , 2 ] = self . image_size_y / 2.0 intrinsics_matrix [ 0 , 0 ] = self . image_size_x / ( 2.0 * np . tan ( self . fov * np . pi / 360.0 ) ) intrinsics_matrix [ 1 , 1 ] = self . image_size_y / ( 2.0 * np . tan ( self . fov * np . pi / 360.0 ) ) self . intrinsics_matrix = intrinsics_matrix return intrinsics_matrix visualize ( self , title = 'CameraData' , duration = 1 ) \u00a4 Visualize camera data. Parameters: Name Type Description Default title title of cv2 image 'CameraData' duration in milisecond 1 Returns: Type Description None None Source code in ROAR/utilities_module/camera_models.py def visualize ( self , title = \"CameraData\" , duration = 1 ) -> None : \"\"\" Visualize camera data. Args: title: title of cv2 image duration: in milisecond Returns: None \"\"\" if self . data is not None : cv2 . imshow ( title , self . data . data ) cv2 . waitKey ( duration ) data_structures_models \u00a4 DepthData pydantic-model \u00a4 data : ndarray pydantic-field required \u00a4 Array of size (WIDTH, HEIGHT, 3) __config__ \u00a4 Config \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 IMUData pydantic-model \u00a4 accelerometer : Vector3D pydantic-field \u00a4 Linear acceleration in m/s^2 gyroscope : Vector3D pydantic-field \u00a4 Angular velocity in rad/sec __config__ \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 Location pydantic-model \u00a4 x : float pydantic-field required \u00a4 Distance in meters from origin to spot on X axis y : float pydantic-field required \u00a4 Distance in meters from origin to spot on Y axis z : float pydantic-field required \u00a4 Distance in meters from origin to spot on Z axis __config__ \u00a4 __add__ ( self , other ) special \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def __add__ ( self , other ): \"\"\"\"\"\" return Location ( x = self . x + other . x , y = self . y + other . y , z = self . z + other . z ) __json_encoder__ ( obj ) special staticmethod \u00a4 __str__ ( self ) special \u00a4 Return str(self). Source code in ROAR/utilities_module/data_structures_models.py def __str__ ( self ): return f \"x: { self . x : .3 } , y: { self . y : .3 } , z: { self . z : .3 } \" __truediv__ ( self , scalar ) special \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def __truediv__ ( self , scalar ): return Location ( x = self . x / scalar , y = self . y / scalar , z = self . z / scalar ) distance ( self , other_location ) \u00a4 Euclidean distance between current location and other location Source code in ROAR/utilities_module/data_structures_models.py def distance ( self , other_location ): \"\"\"Euclidean distance between current location and other location\"\"\" return distance . euclidean ( ( self . x , self . y , self . z ), ( other_location . x , other_location . y , other_location . z ), ) from_array ( array ) staticmethod \u00a4 Source code in ROAR/utilities_module/data_structures_models.py @staticmethod def from_array ( array ): return Location ( x = array [ 0 ], y = array [ 1 ], z = array [ 2 ]) to_array ( self ) \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def to_array ( self ) -> np . array : return np . array ([ self . x , self . y , self . z ]) MapEntry pydantic-model \u00a4 point_a : float pydantic-field required \u00a4 point_b : float pydantic-field required \u00a4 __config__ \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 RGBData pydantic-model \u00a4 data : ndarray pydantic-field required \u00a4 Array of size (WIDTH, HEIGHT, 3) __config__ \u00a4 Config \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 Rotation pydantic-model \u00a4 pitch : float pydantic-field required \u00a4 Degree around the Y-axis roll : float pydantic-field required \u00a4 Degree around the X-axis yaw : float pydantic-field required \u00a4 Degree around the Z-axis __config__ \u00a4 __add__ ( self , other ) special \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def __add__ ( self , other ): \"\"\"\"\"\" return Rotation ( pitch = self . pitch + other . pitch , yaw = self . yaw + other . yaw , roll = self . roll + other . roll ) __json_encoder__ ( obj ) special staticmethod \u00a4 __mul__ ( self , scalar ) special \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def __rmul__ ( self , scalar ): return Rotation ( pitch = self . pitch * scalar , yaw = self . yaw * scalar , roll = self . roll * scalar ) __rmul__ ( self , scalar ) special \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def __rmul__ ( self , scalar ): return Rotation ( pitch = self . pitch * scalar , yaw = self . yaw * scalar , roll = self . roll * scalar ) __str__ ( self ) special \u00a4 Return str(self). Source code in ROAR/utilities_module/data_structures_models.py def __str__ ( self ): return f \"Roll: { round ( self . roll , 2 ) } , Pitch: { round ( self . pitch , 2 ) } , Yaw: { round ( self . yaw , 2 ) } \" __truediv__ ( self , scalar ) special \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def __truediv__ ( self , scalar ): return Rotation ( pitch = self . pitch / scalar , yaw = self . yaw / scalar , roll = self . roll / scalar ) from_array ( array ) staticmethod \u00a4 Source code in ROAR/utilities_module/data_structures_models.py @staticmethod def from_array ( array ): return Rotation ( pitch = array [ 0 ], yaw = array [ 1 ], roll = array [ 2 ]) to_array ( self ) \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def to_array ( self ) -> np . array : return np . array ([ self . pitch , self . yaw , self . roll ]) SensorsData pydantic-model \u00a4 front_depth : DepthData pydantic-field \u00a4 front_rgb : RGBData pydantic-field \u00a4 imu_data : IMUData pydantic-field \u00a4 location : Location pydantic-field \u00a4 rear_rgb : RGBData pydantic-field \u00a4 rotation : Rotation pydantic-field \u00a4 velocity : Vector3D pydantic-field \u00a4 __config__ \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 TrackingData pydantic-model \u00a4 transform : Transform pydantic-field \u00a4 velocity : Vector3D pydantic-field required \u00a4 __config__ \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 Transform pydantic-model \u00a4 location : Location pydantic-field \u00a4 rotation : Rotation pydantic-field \u00a4 __config__ \u00a4 __add__ ( self , other ) special \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def __add__ ( self , other ): return Transform . from_array ( self . to_array () + other . to_array ()) __json_encoder__ ( obj ) special staticmethod \u00a4 __mul__ ( self , scalar ) special \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def __rmul__ ( self , scalar ): return Transform . from_array ( self . to_array () * scalar ) __rmul__ ( self , scalar ) special \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def __rmul__ ( self , scalar ): return Transform . from_array ( self . to_array () * scalar ) __str__ ( self ) special \u00a4 Return str(self). Source code in ROAR/utilities_module/data_structures_models.py def __str__ ( self ): return f \"Location: { self . location . __str__ () } | Rotation: { self . rotation . __str__ () } \" __truediv__ ( self , scalar ) special \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def __truediv__ ( self , scalar ): return Transform . from_array ( self . to_array () / scalar ) from_array ( array ) staticmethod \u00a4 Source code in ROAR/utilities_module/data_structures_models.py @staticmethod def from_array ( array ): return Transform ( location = Location . from_array ( array [: 3 ]), rotation = Rotation . from_array ( array [ 3 :])) get_matrix ( self ) \u00a4 Calculate extrinsics matrix with respect to parent object http://planning.cs.uiuc.edu/node104.html Returns: Type Description ndarray Extrinsics matrix [R, T] [0 1] Source code in ROAR/utilities_module/data_structures_models.py def get_matrix ( self ) -> np . ndarray : \"\"\" Calculate extrinsics matrix with respect to parent object http://planning.cs.uiuc.edu/node104.html Returns: Extrinsics matrix [R, T] [0 1] \"\"\" location = self . location rotation = self . rotation roll , pitch , yaw = rotation . roll , rotation . pitch , rotation . yaw rotation_matrix = rotation_matrix_from_euler ( roll = roll , pitch = pitch , yaw = yaw ) matrix = np . identity ( 4 ) matrix [ 0 , 3 ] = location . x matrix [ 1 , 3 ] = location . y matrix [ 2 , 3 ] = location . z matrix [ 0 : 3 , 0 : 3 ] = rotation_matrix return matrix record ( self ) \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def record ( self ): return f \" { self . location . x } , { self . location . y } , { self . location . z } , { self . rotation . roll } , { self . rotation . pitch } , { self . rotation . yaw } \" to_array ( self ) \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def to_array ( self ) -> np . ndarray : return np . array ([ self . location . x , self . location . y , self . location . z , self . rotation . roll , self . rotation . pitch , self . rotation . yaw ]) Vector3D pydantic-model \u00a4 x : float pydantic-field \u00a4 y : float pydantic-field \u00a4 z : float pydantic-field \u00a4 __config__ \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 to_array ( self ) \u00a4 Source code in ROAR/utilities_module/data_structures_models.py def to_array ( self ): return np . array ([ self . x , self . y , self . z ]) ViveTrackerData pydantic-model \u00a4 location : Location pydantic-field \u00a4 rotation : Rotation pydantic-field \u00a4 tracker_name : str pydantic-field \u00a4 velocity : Vector3D pydantic-field required \u00a4 __config__ \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 errors \u00a4 AgentException \u00a4 localization_map \u00a4 module \u00a4 Module \u00a4 __init__ ( self , threaded = False , update_interval = 0.5 , should_save = False , name = 'module' , ** kwargs ) special \u00a4 Source code in ROAR/utilities_module/module.py def __init__ ( self , threaded = False , update_interval : float = 0.5 , should_save : bool = False , name : str = \"module\" , ** kwargs ): self . threaded = threaded self . update_interval = update_interval self . should_continue_threaded = True self . should_save = should_save self . saving_dir_path : Path = Path ( f \"data/output/ { name } \" ) if should_save and self . saving_dir_path . exists () is False : self . saving_dir_path . mkdir ( exist_ok = True , parents = True ) run_in_series ( self , ** kwargs ) \u00a4 This is the none-threaded function. It run in series! Parameters: Name Type Description Default **kwargs {} Source code in ROAR/utilities_module/module.py @abstractmethod def run_in_series ( self , ** kwargs ): \"\"\" This is the none-threaded function. It run in series! Args: **kwargs: Returns: \"\"\" pass run_in_threaded ( self , ** kwargs ) \u00a4 This is the threaded function. Parameters: Name Type Description Default **kwargs {} Source code in ROAR/utilities_module/module.py def run_in_threaded ( self , ** kwargs ): \"\"\" This is the threaded function. Args: **kwargs: Returns: \"\"\" while self . should_continue_threaded : self . run_in_series () if self . should_save : self . save () time . sleep ( self . update_interval ) save ( self , ** kwargs ) \u00a4 Source code in ROAR/utilities_module/module.py @abstractmethod def save ( self , ** kwargs ): pass shutdown ( self ) \u00a4 Source code in ROAR/utilities_module/module.py def shutdown ( self ): self . should_continue_threaded = False occupancy_map \u00a4 OccupancyGridMap \u00a4 A 2D Occupancy Grid Map representing the world Should be able to handle 1. Transformation of coordinate from world to grid cord 2. Transformation of cord from grid cord to world cord 3. Represent the vehicle size and position, vehicle is represented as 0 Note that this class does NOT remember the vehicle position, in order to visualize vehicle, vehicle position has to be passed in 4. Represent the obstacles' position once its world coordinate is given 5. Represent free space's position, once its world coordinate is given 6. visualize itself, including zoom to a certain area so that not the entire map is visualized 7. The range of values should be bewteen 0 - 1 - 0 = obstacles, 1 = free space 8 Failure tolerant, if I pass in a wrong world coordinate, it will prompt it, but do not fail. Similar with other functions in this class 9. Fixed map size for enhanced performance __init__ ( self , absolute_maximum_map_size = 10000 , map_padding = 40 , vehicle_width = 2 , vehicle_height = 2 , world_coord_resolution = 1 , occu_prob = 0.95 , free_prob = 0.05 , max_points_to_convert = 1000 , ** kwargs ) special \u00a4 Parameters: Name Type Description Default absolute_maximum_map_size Absolute maximum size of the map, will be used to compute a square occupancy map 10000 map_padding int additional padding intended to add. 40 Note: This method pad to both sides, for example, it create padding to the left of min_x, and to the right of max_x Note: map_padding is for when when visualizing, we have to take a whole block and just in case the route is to the edge of the map, it will not error out Source code in ROAR/utilities_module/occupancy_map.py def __init__ ( self , absolute_maximum_map_size = 10000 , map_padding : int = 40 , vehicle_width = 2 , vehicle_height = 2 , world_coord_resolution = 1 , occu_prob : float = 0.95 , free_prob : float = 0.05 , max_points_to_convert : int = 1000 , ** kwargs ): \"\"\" Args: absolute_maximum_map_size: Absolute maximum size of the map, will be used to compute a square occupancy map map_padding: additional padding intended to add. Note: This method pad to both sides, for example, it create padding to the left of min_x, and to the right of max_x Note: map_padding is for when when visualizing, we have to take a whole block and just in case the route is to the edge of the map, it will not error out \"\"\" super () . __init__ ( name = \"occupancy_map\" , ** kwargs ) self . logger = logging . getLogger ( __name__ ) self . _map : Optional [ np . ndarray ] = None self . _world_coord_resolution = world_coord_resolution self . _absolute_maximum_map_size = absolute_maximum_map_size self . _min_x = - math . floor ( self . _absolute_maximum_map_size ) self . _min_y = - math . floor ( self . _absolute_maximum_map_size ) self . _max_x = math . ceil ( self . _absolute_maximum_map_size ) self . _max_y = math . ceil ( self . _absolute_maximum_map_size ) self . _map_additiona_padding = map_padding self . _vehicle_width = vehicle_width self . _vehicle_height = vehicle_height self . _initialize_map () self . _occu_prob = np . log ( occu_prob / ( 1 - occu_prob )) self . _free_prob = 1 - self . _occu_prob self . _max_points_to_convert = max_points_to_convert self . curr_obstacle_world_coords = None self . _curr_obstacle_occu_coords = None self . _static_obstacles : Optional [ np . ndarray ] = None cord_translation_from_world ( self , world_cords_xy ) \u00a4 Translate from world coordinate to occupancy coordinate If the given world coord is less than min or greater than maximum, then do not execute the translation, log error message Parameters: Name Type Description Default world_cords_xy ndarray Numpy array of shape (N, 2) representing [[x, y], [x, y], ...] required Returns: Type Description ndarray occupancy grid map coordinate for this world coordinate of shape (N, 2) [ [x, y], [x, y] ] Source code in ROAR/utilities_module/occupancy_map.py def cord_translation_from_world ( self , world_cords_xy : np . ndarray ) -> np . ndarray : \"\"\" Translate from world coordinate to occupancy coordinate If the given world coord is less than min or greater than maximum, then do not execute the translation, log error message Args: world_cords_xy: Numpy array of shape (N, 2) representing [[x, y], [x, y], ...] Returns: occupancy grid map coordinate for this world coordinate of shape (N, 2) [ [x, y], [x, y] ] \"\"\" transformed = np . round ( world_cords_xy - [ self . _min_x , self . _min_y ]) . astype ( np . int64 ) return transformed get_map ( self , transform = None , view_size = ( 10 , 10 )) \u00a4 Source code in ROAR/utilities_module/occupancy_map.py def get_map ( self , transform : Optional [ Transform ] = None , view_size : Tuple [ int , int ] = ( 10 , 10 )): if transform is None : return np . float32 ( self . _map ) else : occu_cord = self . location_to_occu_cord ( location = transform . location ) map_to_view = self . _map . copy () x , y = occu_cord [ 0 ] map_to_view [ y - math . floor ( self . _vehicle_height / 2 ): y + math . ceil ( self . _vehicle_height / 2 ), x - math . floor ( self . _vehicle_width / 2 ): x + math . ceil ( self . _vehicle_width / 2 )] = 1 map_to_view = map_to_view [ y - view_size [ 1 ] // 2 : y + 10 , x - view_size [ 0 ] // 2 : x + view_size [ 0 ] // 2 ] return map_to_view load_from_file ( self , file_path ) \u00a4 Load a map from file_path. Expected to be the same size as the map Parameters: Name Type Description Default file_path Path a npy file that stores the static map required Source code in ROAR/utilities_module/occupancy_map.py def load_from_file ( self , file_path : Path ): \"\"\" Load a map from file_path. Expected to be the same size as the map Args: file_path: a npy file that stores the static map Returns: \"\"\" m = np . load ( file_path . as_posix ()) assert m . shape == self . _map . shape , f \"Loaded map is of shape [ { m . shape } ], \" \\ f \"does not match the expected shape [ { self . _map . shape } ]\" self . _map = m self . _static_obstacles = np . vstack ([ np . where ( self . _map == 1 )]) . T location_to_occu_cord ( self , location ) \u00a4 Source code in ROAR/utilities_module/occupancy_map.py def location_to_occu_cord ( self , location : Location ): return self . cord_translation_from_world ( world_cords_xy = np . array ([[ location . x , location . z ]]) * self . _world_coord_resolution ) record ( self , map_xs , map_ys ) \u00a4 Source code in ROAR/utilities_module/occupancy_map.py def record ( self , map_xs , map_ys ): m : np . ndarray = np . zeros ( shape = np . shape ( self . _map )) m [ map_ys , map_xs ] = 1 run_in_series ( self , ** kwargs ) \u00a4 This is the none-threaded function. It run in series! Parameters: Name Type Description Default **kwargs {} Source code in ROAR/utilities_module/occupancy_map.py def run_in_series ( self , ** kwargs ): if self . curr_obstacle_world_coords is not None : self . update ( world_coords = self . curr_obstacle_world_coords ) save ( self , ** kwargs ) \u00a4 Source code in ROAR/utilities_module/occupancy_map.py def save ( self , ** kwargs ): if self . _curr_obstacle_occu_coords is not None : m = np . zeros ( shape = self . _map . shape ) occu_cords_x , occu_cords_y = self . _curr_obstacle_occu_coords [:, 0 ], self . _curr_obstacle_occu_coords [:, 1 ] m [ occu_cords_y , occu_cords_x ] = 1 sA = sparse . csr_matrix ( m ) # np.save(f\"{self.saving_dir_path}/{datetime.now().strftime('%m_%d_%Y_%H_%M_%S')}\", m) sparse . save_npz ( f \" { self . saving_dir_path } / { datetime . now () . strftime ( '%m_ %d _%Y_%H_%M_%S' ) } \" , sA ) meta_data_fpath = Path ( f \" { self . saving_dir_path } /meta_data.npy\" ) if meta_data_fpath . exists () is False : meta_data = np . array ([ self . _min_x , self . _min_y , self . _max_x , self . _max_y , self . _map_additiona_padding ]) np . save ( meta_data_fpath . as_posix (), meta_data ) update ( self , world_coords ) \u00a4 This is an easier to use update_grid_map method that can be directly called by an agent It will update grid map using the update_grid_map_from_world_cord method Parameters: Name Type Description Default world_coords ndarray N x 3 array of points required Returns: Type Description None Source code in ROAR/utilities_module/occupancy_map.py def update ( self , world_coords : np . ndarray ): \"\"\" This is an easier to use update_grid_map method that can be directly called by an agent It will update grid map using the update_grid_map_from_world_cord method Args: world_coords: N x 3 array of points Returns: None \"\"\" indices_to_select = np . random . choice ( np . shape ( world_coords )[ 0 ], size = min ( self . _max_points_to_convert , np . shape ( world_coords )[ 0 ])) world_coords = world_coords [ indices_to_select ] world_coords_xy = world_coords [:, [ 0 , 2 ]] * self . _world_coord_resolution self . _update_grid_map_from_world_cord ( world_cords_xy = world_coords_xy ) update_async ( self , world_coords ) \u00a4 This is an easier to use update_grid_map method that can be directly called by an agent It will update grid map using the update_grid_map_from_world_cord method Parameters: Name Type Description Default world_coords ndarray N x 3 array of points required Returns: Type Description None Source code in ROAR/utilities_module/occupancy_map.py def update_async ( self , world_coords : np . ndarray ): \"\"\" This is an easier to use update_grid_map method that can be directly called by an agent It will update grid map using the update_grid_map_from_world_cord method Args: world_coords: N x 3 array of points Returns: None \"\"\" self . curr_obstacle_world_coords = world_coords visualize ( self , transform = None , view_size = ( 10 , 10 )) \u00a4 Else Visualize an ego centric view, output size constraint to (500,500) Parameters: Name Type Description Default transform Optional[ROAR.utilities_module.data_structures_models.Transform] vehicle transform None view_size Tuple[int, int] size of the view (10, 10) Source code in ROAR/utilities_module/occupancy_map.py def visualize ( self , transform : Optional [ Transform ] = None , view_size : Tuple [ int , int ] = ( 10 , 10 )): \"\"\" if transform is None: Visualize the entire map, output size constraint to (500,500) else: Visualize an ego centric view, output size constraint to (500,500) Args: transform: vehicle transform view_size: size of the view Returns: \"\"\" if transform is None : cv2 . imshow ( \"Occupancy Grid Map\" , cv2 . resize ( np . float32 ( self . _map ), dsize = ( 500 , 500 ))) else : occu_cord = self . location_to_occu_cord ( location = transform . location ) map_copy = self . _map . copy () x , y = occu_cord [ 0 ] map_copy [ y - math . floor ( self . _vehicle_height / 2 ): y + math . ceil ( self . _vehicle_height / 2 ), x - math . floor ( self . _vehicle_width / 2 ): x + math . ceil ( self . _vehicle_width / 2 )] = 1 map_to_view = np . float32 ( map_copy [ y - view_size [ 1 ] // 2 : y + view_size [ 1 ] // 2 , x - view_size [ 0 ] // 2 : x + view_size [ 0 ] // 2 ]) # angle = np.deg2rad(transform.rotation.yaw) # rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], # [np.sin(angle), np.cos(angle)]]) # obstacles = np.where(map_to_view == 1) # obstacles: np.ndarray = np.vstack([obstacles[0], obstacles[1]]).T # obstacles = (obstacles @ rotation_matrix).astype(np.int) # TODO will rotate it out of screen # map_to_view = np.zeros(shape=(1000, 1000)) # map_to_view[obstacles[:, 0], obstacles[:, 1]] = 1 cv2 . imshow ( \"Occupancy Grid Map\" , cv2 . resize ( map_to_view , ( 500 , 500 ))) # cv2.imshow(\"Occupancy Grid Map\", cv2.resize(np.float32(map_to_view), (500, 500))) cv2 . waitKey ( 1 ) track_visualizer \u00a4 The purpose of this file is to take in a txt file in containing data x,y,z,roll,pitch,yaw or x,y,z ... and visualize the track read_txt ( file_path ) \u00a4 Source code in ROAR/utilities_module/track_visualizer.py def read_txt ( file_path : Path ) -> List [ List [ float ]]: if file_path . exists () is False : raise FileNotFoundError ( f \" { file_path } is not found. Please double check\" ) file = file_path . open ( 'r' ) result : List [ List [ float ]] = [] for line in file . readlines (): try : x , y , z = line . split ( sep = ',' ) except Exception as e : x , y , z , roll , pitch , yaw = line . split ( sep = ',' ) result . append ([ float ( x ), float ( y ), float ( z )]) return result visualize_track_data ( track_data ) \u00a4 Source code in ROAR/utilities_module/track_visualizer.py def visualize_track_data ( track_data : List [ List [ float ]]): print ( f \"Visualizing [ { len ( track_data ) } ] data points\" ) track_data = np . asarray ( track_data ) fig = go . Figure ( data = [ go . Scatter3d ( x = track_data [:, 0 ], y = [ 0 ] * len ( track_data ), z = track_data [:, 2 ], mode = 'markers' )]) fig . show () utilities \u00a4 img_to_world ( scaled_depth_image , intrinsics_matrix , veh_world_matrix , cam_veh_matrix ) \u00a4 Compute image to world translation using the formula below ((R_world_veh)^(-1) @ (R_veh_cam)^(-1) @ ((intrinsics)^(-1) @ scaled_depth_image).pad_with_1)[:3, :] = [X Y Z] Parameters: Name Type Description Default scaled_depth_image ndarray 3 x n numpy array required intrinsics_matrix ndarray 3 x 3 intrinsics required veh_world_matrix ndarray 4 x 4 vehicle to world transformation matrix required cam_veh_matrix ndarray 4 x 4 camera to vehicle transformation matrix required Returns: Type Description ndarray n x 3 array of n points Source code in ROAR/utilities_module/utilities.py def img_to_world ( scaled_depth_image : np . ndarray , intrinsics_matrix : np . ndarray , veh_world_matrix : np . ndarray , cam_veh_matrix : np . ndarray ) -> np . ndarray : \"\"\" Compute image to world translation using the formula below ((R_world_veh)^(-1) @ (R_veh_cam)^(-1) @ ((intrinsics)^(-1) @ scaled_depth_image).pad_with_1)[:3, :] = [X Y Z] Args: scaled_depth_image: 3 x n numpy array intrinsics_matrix: 3 x 3 intrinsics veh_world_matrix: 4 x 4 vehicle to world transformation matrix cam_veh_matrix: 4 x 4 camera to vehicle transformation matrix Returns: n x 3 array of n points \"\"\" assert scaled_depth_image . shape [ 0 ] == 3 , f \"scaled depth image has incorrect shape [ { scaled_depth_image . shape } ]\" assert intrinsics_matrix . shape == ( 3 , 3 ), f \"Intrinsics matrix has incorrect shape [ { intrinsics_matrix . shape } ]\" assert veh_world_matrix . shape == ( 4 , 4 ), f \"Intrinsics matrix has incorrect shape [ { intrinsics_matrix . shape } ]\" assert cam_veh_matrix . shape == ( 4 , 4 ), f \"Intrinsics matrix has incorrect shape [ { intrinsics_matrix . shape } ]\" # extrinsics @ inv(K) @ [u, v,1] = [X,Y,Z] k_inv = np . linalg . inv ( intrinsics_matrix ) raw_p3d = k_inv @ scaled_depth_image ones = np . ones ( shape = np . shape ( raw_p3d )[ 1 ]) # raw_p3d_padded = np.vstack([raw_p3d, ones]) raw_p3d_padded = np . vstack ([ raw_p3d [ 2 , :], raw_p3d [ 0 , :], - raw_p3d [ 1 , :], ones ]) points : np . ndarray = ( veh_world_matrix @ cam_veh_matrix @ raw_p3d_padded )[: 3 , :] . T return points img_to_world2 ( depth_img , intrinsics_matrix , extrinsics_matrix , segmentation , criteria , depth_scaling_factor = 1000 ) \u00a4 Source code in ROAR/utilities_module/utilities.py def img_to_world2 ( depth_img , intrinsics_matrix , extrinsics_matrix , segmentation : np . ndarray , criteria , depth_scaling_factor = 1000 ) -> np . ndarray : # get a 2 x N array for their indices ground_loc = np . where ( segmentation == criteria )[: 2 ] # print(ground) # ground_loc = np.where(depth_img == criteria) depth_val = depth_img [ ground_loc ] * depth_scaling_factor ground_loc = ground_loc * depth_val # compute raw_points raw_points = np . vstack ([ ground_loc , depth_val ]) # convert to cords_y_minus_z_x cords_y_minus_z_x = np . linalg . inv ( intrinsics_matrix ) @ raw_points # convert to cords_xyz_1 ones = np . ones (( 1 , np . shape ( cords_y_minus_z_x )[ 1 ])) cords_xyz_1 = np . vstack ([ cords_y_minus_z_x [ 2 , :], cords_y_minus_z_x [ 0 , :], - cords_y_minus_z_x [ 1 , :], ones ]) # multiply by cam_world_matrix points = extrinsics_matrix @ cords_xyz_1 # i have all points now return points png_to_depth ( im ) \u00a4 Takes in an image read from cv2.imread(), whose output is simply a numpy array, turn it into a depth image according to carla's method of (R + G * 256 + B * 256 * 256) / (256 * 256 * 256 - 1). Parameters: Name Type Description Default im <built-in function array> input image, read from cv2.imread() required Returns: Type Description <built-in function array> depth image Source code in ROAR/utilities_module/utilities.py def png_to_depth ( im : np . array ) -> np . array : \"\"\" Takes in an image read from cv2.imread(), whose output is simply a numpy array, turn it into a depth image according to carla's method of (R + G * 256 + B * 256 * 256) / (256 * 256 * 256 - 1). Args: im: input image, read from cv2.imread() Returns: depth image \"\"\" im = im . astype ( np . float64 ) normalized_depth = np . dot ( im [:, :, : 3 ], [ 1 , 256 , 65536.0 ]) normalized_depth /= 16777215.0 return normalized_depth rotation_matrix_from_euler ( roll , pitch , yaw ) \u00a4 Takes in roll pitch yaw and compute rotation matrix using the order of R = R_yaw * R_pitch * R_roll http://planning.cs.uiuc.edu/node104.html Parameters: Name Type Description Default roll float float of roll in degree required pitch float float of pitch in degree required yaw float float of yaw in degree required Returns: Type Description ndarray 3 x 3 array rotation matrix Source code in ROAR/utilities_module/utilities.py def rotation_matrix_from_euler ( roll : float , pitch : float , yaw : float ) -> np . ndarray : \"\"\" Takes in roll pitch yaw and compute rotation matrix using the order of R = R_yaw * R_pitch * R_roll http://planning.cs.uiuc.edu/node104.html Args: roll: float of roll in degree pitch: float of pitch in degree yaw: float of yaw in degree Returns: 3 x 3 array rotation matrix \"\"\" ry , rx , rz = np . radians ( yaw ), np . radians ( pitch ), np . radians ( roll ) Rx = np . array ([ [ 1 , 0 , 0 ], [ 0 , np . cos ( rx ), - np . sin ( rx )], [ 0 , np . sin ( rx ), np . cos ( rx )] ]) Ry = np . array ([ [ np . cos ( ry ), 0 , np . sin ( ry )], [ 0 , 1 , 0 ], [ - np . sin ( ry ), 0 , np . cos ( ry )] ]) Rz = np . array ([ [ np . cos ( rz ), - np . sin ( rz ), 0 ], [ np . sin ( rz ), np . cos ( rz ), 0 ], [ 0 , 0 , 1 ] ]) return Rx @ Ry @ Rz vehicle_models \u00a4 Vehicle pydantic-model \u00a4 Encodes the Vehicle's state at the last tick control : VehicleControl pydantic-field \u00a4 transform : Transform pydantic-field \u00a4 velocity : Vector3D pydantic-field \u00a4 wheel_base : float pydantic-field \u00a4 Default to tesla model 3's wheel base __config__ \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 get_speed ( vehicle ) staticmethod \u00a4 Compute speed of a vehicle in Km/h. :param vehicle: the vehicle for which speed is calculated :return: speed as a float in Km/h Source code in ROAR/utilities_module/vehicle_models.py @staticmethod def get_speed ( vehicle ): # TODO consider the jetson case \"\"\" Compute speed of a vehicle in Km/h. :param vehicle: the vehicle for which speed is calculated :return: speed as a float in Km/h \"\"\" vel = vehicle . velocity return 3.6 * math . sqrt ( vel . x ** 2 + vel . y ** 2 + vel . z ** 2 ) to_array ( self ) \u00a4 Source code in ROAR/utilities_module/vehicle_models.py def to_array ( self ): return np . concatenate ([ self . velocity . to_array (), self . transform . to_array (), self . control . to_array ()]) VehicleControl pydantic-model \u00a4 steering : float pydantic-field \u00a4 throttle : float pydantic-field \u00a4 __config__ \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 clamp ( n , minn , maxn ) staticmethod \u00a4 Source code in ROAR/utilities_module/vehicle_models.py @staticmethod def clamp ( n , minn , maxn ): return max ( min ( maxn , n ), minn ) get_steering ( self ) \u00a4 Cap it between -1 and 1 :return: Source code in ROAR/utilities_module/vehicle_models.py def get_steering ( self ) -> float : \"\"\" Cap it between -1 and 1 :return: \"\"\" return self . clamp ( self . steering , - 1 , 1 ) get_throttle ( self ) \u00a4 Cap it between -1 and 1 :return: Source code in ROAR/utilities_module/vehicle_models.py def get_throttle ( self ) -> float : \"\"\" Cap it between -1 and 1 :return: \"\"\" return self . clamp ( self . throttle , - 1 , 1 ) to_array ( self ) \u00a4 Source code in ROAR/utilities_module/vehicle_models.py def to_array ( self ) -> np . ndarray : return np . array ([ self . throttle , self . steering ])","title":"Utilities Module"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models","text":"","title":"camera_models"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models.Camera","text":"","title":"Camera"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models.Camera.data","text":"","title":"data"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models.Camera.distortion_coefficient","text":"","title":"distortion_coefficient"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models.Camera.fov","text":"","title":"fov"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models.Camera.image_size_x","text":"","title":"image_size_x"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models.Camera.image_size_y","text":"","title":"image_size_y"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models.Camera.intrinsics_matrix","text":"","title":"intrinsics_matrix"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models.Camera.transform","text":"","title":"transform"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models.Camera.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models.Camera.Config","text":"","title":"Config"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models.Camera.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models.Camera.calculate_default_intrinsics_matrix","text":"Calculate intrinsics matrix Will set the attribute intrinsic matrix so that re-calculation is not necessary. https://github.com/carla-simulator/carla/issues/56 [ ax, 0, cx, 0, ay, cy, 0 , 0, 1 ] Returns: Type Description ndarray Intrinsics_matrix Source code in ROAR/utilities_module/camera_models.py def calculate_default_intrinsics_matrix ( self ) -> np . ndarray : \"\"\" Calculate intrinsics matrix Will set the attribute intrinsic matrix so that re-calculation is not necessary. https://github.com/carla-simulator/carla/issues/56 [ ax, 0, cx, 0, ay, cy, 0 , 0, 1 ] Returns: Intrinsics_matrix \"\"\" intrinsics_matrix = np . identity ( 3 ) intrinsics_matrix [ 0 , 2 ] = self . image_size_x / 2.0 intrinsics_matrix [ 1 , 2 ] = self . image_size_y / 2.0 intrinsics_matrix [ 0 , 0 ] = self . image_size_x / ( 2.0 * np . tan ( self . fov * np . pi / 360.0 ) ) intrinsics_matrix [ 1 , 1 ] = self . image_size_y / ( 2.0 * np . tan ( self . fov * np . pi / 360.0 ) ) self . intrinsics_matrix = intrinsics_matrix return intrinsics_matrix","title":"calculate_default_intrinsics_matrix()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.camera_models.Camera.visualize","text":"Visualize camera data. Parameters: Name Type Description Default title title of cv2 image 'CameraData' duration in milisecond 1 Returns: Type Description None None Source code in ROAR/utilities_module/camera_models.py def visualize ( self , title = \"CameraData\" , duration = 1 ) -> None : \"\"\" Visualize camera data. Args: title: title of cv2 image duration: in milisecond Returns: None \"\"\" if self . data is not None : cv2 . imshow ( title , self . data . data ) cv2 . waitKey ( duration )","title":"visualize()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models","text":"","title":"data_structures_models"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.DepthData","text":"","title":"DepthData"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.DepthData.data","text":"Array of size (WIDTH, HEIGHT, 3)","title":"data"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.DepthData.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.DepthData.Config","text":"","title":"Config"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.DepthData.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.IMUData","text":"","title":"IMUData"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.IMUData.accelerometer","text":"Linear acceleration in m/s^2","title":"accelerometer"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.IMUData.gyroscope","text":"Angular velocity in rad/sec","title":"gyroscope"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.IMUData.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.IMUData.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Location","text":"","title":"Location"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Location.x","text":"Distance in meters from origin to spot on X axis","title":"x"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Location.y","text":"Distance in meters from origin to spot on Y axis","title":"y"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Location.z","text":"Distance in meters from origin to spot on Z axis","title":"z"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Location.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Location.__add__","text":"Source code in ROAR/utilities_module/data_structures_models.py def __add__ ( self , other ): \"\"\"\"\"\" return Location ( x = self . x + other . x , y = self . y + other . y , z = self . z + other . z )","title":"__add__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Location.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Location.__str__","text":"Return str(self). Source code in ROAR/utilities_module/data_structures_models.py def __str__ ( self ): return f \"x: { self . x : .3 } , y: { self . y : .3 } , z: { self . z : .3 } \"","title":"__str__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Location.__truediv__","text":"Source code in ROAR/utilities_module/data_structures_models.py def __truediv__ ( self , scalar ): return Location ( x = self . x / scalar , y = self . y / scalar , z = self . z / scalar )","title":"__truediv__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Location.distance","text":"Euclidean distance between current location and other location Source code in ROAR/utilities_module/data_structures_models.py def distance ( self , other_location ): \"\"\"Euclidean distance between current location and other location\"\"\" return distance . euclidean ( ( self . x , self . y , self . z ), ( other_location . x , other_location . y , other_location . z ), )","title":"distance()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Location.from_array","text":"Source code in ROAR/utilities_module/data_structures_models.py @staticmethod def from_array ( array ): return Location ( x = array [ 0 ], y = array [ 1 ], z = array [ 2 ])","title":"from_array()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Location.to_array","text":"Source code in ROAR/utilities_module/data_structures_models.py def to_array ( self ) -> np . array : return np . array ([ self . x , self . y , self . z ])","title":"to_array()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.MapEntry","text":"","title":"MapEntry"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.MapEntry.point_a","text":"","title":"point_a"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.MapEntry.point_b","text":"","title":"point_b"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.MapEntry.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.MapEntry.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.RGBData","text":"","title":"RGBData"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.RGBData.data","text":"Array of size (WIDTH, HEIGHT, 3)","title":"data"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.RGBData.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.RGBData.Config","text":"","title":"Config"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.RGBData.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Rotation","text":"","title":"Rotation"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Rotation.pitch","text":"Degree around the Y-axis","title":"pitch"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Rotation.roll","text":"Degree around the X-axis","title":"roll"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Rotation.yaw","text":"Degree around the Z-axis","title":"yaw"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Rotation.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Rotation.__add__","text":"Source code in ROAR/utilities_module/data_structures_models.py def __add__ ( self , other ): \"\"\"\"\"\" return Rotation ( pitch = self . pitch + other . pitch , yaw = self . yaw + other . yaw , roll = self . roll + other . roll )","title":"__add__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Rotation.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Rotation.__mul__","text":"Source code in ROAR/utilities_module/data_structures_models.py def __rmul__ ( self , scalar ): return Rotation ( pitch = self . pitch * scalar , yaw = self . yaw * scalar , roll = self . roll * scalar )","title":"__mul__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Rotation.__rmul__","text":"Source code in ROAR/utilities_module/data_structures_models.py def __rmul__ ( self , scalar ): return Rotation ( pitch = self . pitch * scalar , yaw = self . yaw * scalar , roll = self . roll * scalar )","title":"__rmul__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Rotation.__str__","text":"Return str(self). Source code in ROAR/utilities_module/data_structures_models.py def __str__ ( self ): return f \"Roll: { round ( self . roll , 2 ) } , Pitch: { round ( self . pitch , 2 ) } , Yaw: { round ( self . yaw , 2 ) } \"","title":"__str__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Rotation.__truediv__","text":"Source code in ROAR/utilities_module/data_structures_models.py def __truediv__ ( self , scalar ): return Rotation ( pitch = self . pitch / scalar , yaw = self . yaw / scalar , roll = self . roll / scalar )","title":"__truediv__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Rotation.from_array","text":"Source code in ROAR/utilities_module/data_structures_models.py @staticmethod def from_array ( array ): return Rotation ( pitch = array [ 0 ], yaw = array [ 1 ], roll = array [ 2 ])","title":"from_array()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Rotation.to_array","text":"Source code in ROAR/utilities_module/data_structures_models.py def to_array ( self ) -> np . array : return np . array ([ self . pitch , self . yaw , self . roll ])","title":"to_array()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.SensorsData","text":"","title":"SensorsData"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.SensorsData.front_depth","text":"","title":"front_depth"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.SensorsData.front_rgb","text":"","title":"front_rgb"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.SensorsData.imu_data","text":"","title":"imu_data"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.SensorsData.location","text":"","title":"location"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.SensorsData.rear_rgb","text":"","title":"rear_rgb"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.SensorsData.rotation","text":"","title":"rotation"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.SensorsData.velocity","text":"","title":"velocity"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.SensorsData.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.SensorsData.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.TrackingData","text":"","title":"TrackingData"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.TrackingData.transform","text":"","title":"transform"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.TrackingData.velocity","text":"","title":"velocity"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.TrackingData.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.TrackingData.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform","text":"","title":"Transform"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform.location","text":"","title":"location"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform.rotation","text":"","title":"rotation"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform.__add__","text":"Source code in ROAR/utilities_module/data_structures_models.py def __add__ ( self , other ): return Transform . from_array ( self . to_array () + other . to_array ())","title":"__add__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform.__mul__","text":"Source code in ROAR/utilities_module/data_structures_models.py def __rmul__ ( self , scalar ): return Transform . from_array ( self . to_array () * scalar )","title":"__mul__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform.__rmul__","text":"Source code in ROAR/utilities_module/data_structures_models.py def __rmul__ ( self , scalar ): return Transform . from_array ( self . to_array () * scalar )","title":"__rmul__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform.__str__","text":"Return str(self). Source code in ROAR/utilities_module/data_structures_models.py def __str__ ( self ): return f \"Location: { self . location . __str__ () } | Rotation: { self . rotation . __str__ () } \"","title":"__str__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform.__truediv__","text":"Source code in ROAR/utilities_module/data_structures_models.py def __truediv__ ( self , scalar ): return Transform . from_array ( self . to_array () / scalar )","title":"__truediv__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform.from_array","text":"Source code in ROAR/utilities_module/data_structures_models.py @staticmethod def from_array ( array ): return Transform ( location = Location . from_array ( array [: 3 ]), rotation = Rotation . from_array ( array [ 3 :]))","title":"from_array()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform.get_matrix","text":"Calculate extrinsics matrix with respect to parent object http://planning.cs.uiuc.edu/node104.html Returns: Type Description ndarray Extrinsics matrix [R, T] [0 1] Source code in ROAR/utilities_module/data_structures_models.py def get_matrix ( self ) -> np . ndarray : \"\"\" Calculate extrinsics matrix with respect to parent object http://planning.cs.uiuc.edu/node104.html Returns: Extrinsics matrix [R, T] [0 1] \"\"\" location = self . location rotation = self . rotation roll , pitch , yaw = rotation . roll , rotation . pitch , rotation . yaw rotation_matrix = rotation_matrix_from_euler ( roll = roll , pitch = pitch , yaw = yaw ) matrix = np . identity ( 4 ) matrix [ 0 , 3 ] = location . x matrix [ 1 , 3 ] = location . y matrix [ 2 , 3 ] = location . z matrix [ 0 : 3 , 0 : 3 ] = rotation_matrix return matrix","title":"get_matrix()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform.record","text":"Source code in ROAR/utilities_module/data_structures_models.py def record ( self ): return f \" { self . location . x } , { self . location . y } , { self . location . z } , { self . rotation . roll } , { self . rotation . pitch } , { self . rotation . yaw } \"","title":"record()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Transform.to_array","text":"Source code in ROAR/utilities_module/data_structures_models.py def to_array ( self ) -> np . ndarray : return np . array ([ self . location . x , self . location . y , self . location . z , self . rotation . roll , self . rotation . pitch , self . rotation . yaw ])","title":"to_array()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Vector3D","text":"","title":"Vector3D"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Vector3D.x","text":"","title":"x"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Vector3D.y","text":"","title":"y"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Vector3D.z","text":"","title":"z"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Vector3D.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Vector3D.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.Vector3D.to_array","text":"Source code in ROAR/utilities_module/data_structures_models.py def to_array ( self ): return np . array ([ self . x , self . y , self . z ])","title":"to_array()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.ViveTrackerData","text":"","title":"ViveTrackerData"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.ViveTrackerData.location","text":"","title":"location"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.ViveTrackerData.rotation","text":"","title":"rotation"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.ViveTrackerData.tracker_name","text":"","title":"tracker_name"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.ViveTrackerData.velocity","text":"","title":"velocity"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.ViveTrackerData.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.data_structures_models.ViveTrackerData.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.errors","text":"","title":"errors"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.errors.AgentException","text":"","title":"AgentException"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.localization_map","text":"","title":"localization_map"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.module","text":"","title":"module"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.module.Module","text":"","title":"Module"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.module.Module.__init__","text":"Source code in ROAR/utilities_module/module.py def __init__ ( self , threaded = False , update_interval : float = 0.5 , should_save : bool = False , name : str = \"module\" , ** kwargs ): self . threaded = threaded self . update_interval = update_interval self . should_continue_threaded = True self . should_save = should_save self . saving_dir_path : Path = Path ( f \"data/output/ { name } \" ) if should_save and self . saving_dir_path . exists () is False : self . saving_dir_path . mkdir ( exist_ok = True , parents = True )","title":"__init__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.module.Module.run_in_series","text":"This is the none-threaded function. It run in series! Parameters: Name Type Description Default **kwargs {} Source code in ROAR/utilities_module/module.py @abstractmethod def run_in_series ( self , ** kwargs ): \"\"\" This is the none-threaded function. It run in series! Args: **kwargs: Returns: \"\"\" pass","title":"run_in_series()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.module.Module.run_in_threaded","text":"This is the threaded function. Parameters: Name Type Description Default **kwargs {} Source code in ROAR/utilities_module/module.py def run_in_threaded ( self , ** kwargs ): \"\"\" This is the threaded function. Args: **kwargs: Returns: \"\"\" while self . should_continue_threaded : self . run_in_series () if self . should_save : self . save () time . sleep ( self . update_interval )","title":"run_in_threaded()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.module.Module.save","text":"Source code in ROAR/utilities_module/module.py @abstractmethod def save ( self , ** kwargs ): pass","title":"save()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.module.Module.shutdown","text":"Source code in ROAR/utilities_module/module.py def shutdown ( self ): self . should_continue_threaded = False","title":"shutdown()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.occupancy_map","text":"","title":"occupancy_map"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.occupancy_map.OccupancyGridMap","text":"A 2D Occupancy Grid Map representing the world Should be able to handle 1. Transformation of coordinate from world to grid cord 2. Transformation of cord from grid cord to world cord 3. Represent the vehicle size and position, vehicle is represented as 0 Note that this class does NOT remember the vehicle position, in order to visualize vehicle, vehicle position has to be passed in 4. Represent the obstacles' position once its world coordinate is given 5. Represent free space's position, once its world coordinate is given 6. visualize itself, including zoom to a certain area so that not the entire map is visualized 7. The range of values should be bewteen 0 - 1 - 0 = obstacles, 1 = free space 8 Failure tolerant, if I pass in a wrong world coordinate, it will prompt it, but do not fail. Similar with other functions in this class 9. Fixed map size for enhanced performance","title":"OccupancyGridMap"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.occupancy_map.OccupancyGridMap.__init__","text":"Parameters: Name Type Description Default absolute_maximum_map_size Absolute maximum size of the map, will be used to compute a square occupancy map 10000 map_padding int additional padding intended to add. 40 Note: This method pad to both sides, for example, it create padding to the left of min_x, and to the right of max_x Note: map_padding is for when when visualizing, we have to take a whole block and just in case the route is to the edge of the map, it will not error out Source code in ROAR/utilities_module/occupancy_map.py def __init__ ( self , absolute_maximum_map_size = 10000 , map_padding : int = 40 , vehicle_width = 2 , vehicle_height = 2 , world_coord_resolution = 1 , occu_prob : float = 0.95 , free_prob : float = 0.05 , max_points_to_convert : int = 1000 , ** kwargs ): \"\"\" Args: absolute_maximum_map_size: Absolute maximum size of the map, will be used to compute a square occupancy map map_padding: additional padding intended to add. Note: This method pad to both sides, for example, it create padding to the left of min_x, and to the right of max_x Note: map_padding is for when when visualizing, we have to take a whole block and just in case the route is to the edge of the map, it will not error out \"\"\" super () . __init__ ( name = \"occupancy_map\" , ** kwargs ) self . logger = logging . getLogger ( __name__ ) self . _map : Optional [ np . ndarray ] = None self . _world_coord_resolution = world_coord_resolution self . _absolute_maximum_map_size = absolute_maximum_map_size self . _min_x = - math . floor ( self . _absolute_maximum_map_size ) self . _min_y = - math . floor ( self . _absolute_maximum_map_size ) self . _max_x = math . ceil ( self . _absolute_maximum_map_size ) self . _max_y = math . ceil ( self . _absolute_maximum_map_size ) self . _map_additiona_padding = map_padding self . _vehicle_width = vehicle_width self . _vehicle_height = vehicle_height self . _initialize_map () self . _occu_prob = np . log ( occu_prob / ( 1 - occu_prob )) self . _free_prob = 1 - self . _occu_prob self . _max_points_to_convert = max_points_to_convert self . curr_obstacle_world_coords = None self . _curr_obstacle_occu_coords = None self . _static_obstacles : Optional [ np . ndarray ] = None","title":"__init__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.occupancy_map.OccupancyGridMap.cord_translation_from_world","text":"Translate from world coordinate to occupancy coordinate If the given world coord is less than min or greater than maximum, then do not execute the translation, log error message Parameters: Name Type Description Default world_cords_xy ndarray Numpy array of shape (N, 2) representing [[x, y], [x, y], ...] required Returns: Type Description ndarray occupancy grid map coordinate for this world coordinate of shape (N, 2) [ [x, y], [x, y] ] Source code in ROAR/utilities_module/occupancy_map.py def cord_translation_from_world ( self , world_cords_xy : np . ndarray ) -> np . ndarray : \"\"\" Translate from world coordinate to occupancy coordinate If the given world coord is less than min or greater than maximum, then do not execute the translation, log error message Args: world_cords_xy: Numpy array of shape (N, 2) representing [[x, y], [x, y], ...] Returns: occupancy grid map coordinate for this world coordinate of shape (N, 2) [ [x, y], [x, y] ] \"\"\" transformed = np . round ( world_cords_xy - [ self . _min_x , self . _min_y ]) . astype ( np . int64 ) return transformed","title":"cord_translation_from_world()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.occupancy_map.OccupancyGridMap.get_map","text":"Source code in ROAR/utilities_module/occupancy_map.py def get_map ( self , transform : Optional [ Transform ] = None , view_size : Tuple [ int , int ] = ( 10 , 10 )): if transform is None : return np . float32 ( self . _map ) else : occu_cord = self . location_to_occu_cord ( location = transform . location ) map_to_view = self . _map . copy () x , y = occu_cord [ 0 ] map_to_view [ y - math . floor ( self . _vehicle_height / 2 ): y + math . ceil ( self . _vehicle_height / 2 ), x - math . floor ( self . _vehicle_width / 2 ): x + math . ceil ( self . _vehicle_width / 2 )] = 1 map_to_view = map_to_view [ y - view_size [ 1 ] // 2 : y + 10 , x - view_size [ 0 ] // 2 : x + view_size [ 0 ] // 2 ] return map_to_view","title":"get_map()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.occupancy_map.OccupancyGridMap.load_from_file","text":"Load a map from file_path. Expected to be the same size as the map Parameters: Name Type Description Default file_path Path a npy file that stores the static map required Source code in ROAR/utilities_module/occupancy_map.py def load_from_file ( self , file_path : Path ): \"\"\" Load a map from file_path. Expected to be the same size as the map Args: file_path: a npy file that stores the static map Returns: \"\"\" m = np . load ( file_path . as_posix ()) assert m . shape == self . _map . shape , f \"Loaded map is of shape [ { m . shape } ], \" \\ f \"does not match the expected shape [ { self . _map . shape } ]\" self . _map = m self . _static_obstacles = np . vstack ([ np . where ( self . _map == 1 )]) . T","title":"load_from_file()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.occupancy_map.OccupancyGridMap.location_to_occu_cord","text":"Source code in ROAR/utilities_module/occupancy_map.py def location_to_occu_cord ( self , location : Location ): return self . cord_translation_from_world ( world_cords_xy = np . array ([[ location . x , location . z ]]) * self . _world_coord_resolution )","title":"location_to_occu_cord()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.occupancy_map.OccupancyGridMap.record","text":"Source code in ROAR/utilities_module/occupancy_map.py def record ( self , map_xs , map_ys ): m : np . ndarray = np . zeros ( shape = np . shape ( self . _map )) m [ map_ys , map_xs ] = 1","title":"record()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.occupancy_map.OccupancyGridMap.run_in_series","text":"This is the none-threaded function. It run in series! Parameters: Name Type Description Default **kwargs {} Source code in ROAR/utilities_module/occupancy_map.py def run_in_series ( self , ** kwargs ): if self . curr_obstacle_world_coords is not None : self . update ( world_coords = self . curr_obstacle_world_coords )","title":"run_in_series()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.occupancy_map.OccupancyGridMap.save","text":"Source code in ROAR/utilities_module/occupancy_map.py def save ( self , ** kwargs ): if self . _curr_obstacle_occu_coords is not None : m = np . zeros ( shape = self . _map . shape ) occu_cords_x , occu_cords_y = self . _curr_obstacle_occu_coords [:, 0 ], self . _curr_obstacle_occu_coords [:, 1 ] m [ occu_cords_y , occu_cords_x ] = 1 sA = sparse . csr_matrix ( m ) # np.save(f\"{self.saving_dir_path}/{datetime.now().strftime('%m_%d_%Y_%H_%M_%S')}\", m) sparse . save_npz ( f \" { self . saving_dir_path } / { datetime . now () . strftime ( '%m_ %d _%Y_%H_%M_%S' ) } \" , sA ) meta_data_fpath = Path ( f \" { self . saving_dir_path } /meta_data.npy\" ) if meta_data_fpath . exists () is False : meta_data = np . array ([ self . _min_x , self . _min_y , self . _max_x , self . _max_y , self . _map_additiona_padding ]) np . save ( meta_data_fpath . as_posix (), meta_data )","title":"save()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.occupancy_map.OccupancyGridMap.update","text":"This is an easier to use update_grid_map method that can be directly called by an agent It will update grid map using the update_grid_map_from_world_cord method Parameters: Name Type Description Default world_coords ndarray N x 3 array of points required Returns: Type Description None Source code in ROAR/utilities_module/occupancy_map.py def update ( self , world_coords : np . ndarray ): \"\"\" This is an easier to use update_grid_map method that can be directly called by an agent It will update grid map using the update_grid_map_from_world_cord method Args: world_coords: N x 3 array of points Returns: None \"\"\" indices_to_select = np . random . choice ( np . shape ( world_coords )[ 0 ], size = min ( self . _max_points_to_convert , np . shape ( world_coords )[ 0 ])) world_coords = world_coords [ indices_to_select ] world_coords_xy = world_coords [:, [ 0 , 2 ]] * self . _world_coord_resolution self . _update_grid_map_from_world_cord ( world_cords_xy = world_coords_xy )","title":"update()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.occupancy_map.OccupancyGridMap.update_async","text":"This is an easier to use update_grid_map method that can be directly called by an agent It will update grid map using the update_grid_map_from_world_cord method Parameters: Name Type Description Default world_coords ndarray N x 3 array of points required Returns: Type Description None Source code in ROAR/utilities_module/occupancy_map.py def update_async ( self , world_coords : np . ndarray ): \"\"\" This is an easier to use update_grid_map method that can be directly called by an agent It will update grid map using the update_grid_map_from_world_cord method Args: world_coords: N x 3 array of points Returns: None \"\"\" self . curr_obstacle_world_coords = world_coords","title":"update_async()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.occupancy_map.OccupancyGridMap.visualize","text":"Else Visualize an ego centric view, output size constraint to (500,500) Parameters: Name Type Description Default transform Optional[ROAR.utilities_module.data_structures_models.Transform] vehicle transform None view_size Tuple[int, int] size of the view (10, 10) Source code in ROAR/utilities_module/occupancy_map.py def visualize ( self , transform : Optional [ Transform ] = None , view_size : Tuple [ int , int ] = ( 10 , 10 )): \"\"\" if transform is None: Visualize the entire map, output size constraint to (500,500) else: Visualize an ego centric view, output size constraint to (500,500) Args: transform: vehicle transform view_size: size of the view Returns: \"\"\" if transform is None : cv2 . imshow ( \"Occupancy Grid Map\" , cv2 . resize ( np . float32 ( self . _map ), dsize = ( 500 , 500 ))) else : occu_cord = self . location_to_occu_cord ( location = transform . location ) map_copy = self . _map . copy () x , y = occu_cord [ 0 ] map_copy [ y - math . floor ( self . _vehicle_height / 2 ): y + math . ceil ( self . _vehicle_height / 2 ), x - math . floor ( self . _vehicle_width / 2 ): x + math . ceil ( self . _vehicle_width / 2 )] = 1 map_to_view = np . float32 ( map_copy [ y - view_size [ 1 ] // 2 : y + view_size [ 1 ] // 2 , x - view_size [ 0 ] // 2 : x + view_size [ 0 ] // 2 ]) # angle = np.deg2rad(transform.rotation.yaw) # rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], # [np.sin(angle), np.cos(angle)]]) # obstacles = np.where(map_to_view == 1) # obstacles: np.ndarray = np.vstack([obstacles[0], obstacles[1]]).T # obstacles = (obstacles @ rotation_matrix).astype(np.int) # TODO will rotate it out of screen # map_to_view = np.zeros(shape=(1000, 1000)) # map_to_view[obstacles[:, 0], obstacles[:, 1]] = 1 cv2 . imshow ( \"Occupancy Grid Map\" , cv2 . resize ( map_to_view , ( 500 , 500 ))) # cv2.imshow(\"Occupancy Grid Map\", cv2.resize(np.float32(map_to_view), (500, 500))) cv2 . waitKey ( 1 )","title":"visualize()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.track_visualizer","text":"The purpose of this file is to take in a txt file in containing data x,y,z,roll,pitch,yaw or x,y,z ... and visualize the track","title":"track_visualizer"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.track_visualizer.read_txt","text":"Source code in ROAR/utilities_module/track_visualizer.py def read_txt ( file_path : Path ) -> List [ List [ float ]]: if file_path . exists () is False : raise FileNotFoundError ( f \" { file_path } is not found. Please double check\" ) file = file_path . open ( 'r' ) result : List [ List [ float ]] = [] for line in file . readlines (): try : x , y , z = line . split ( sep = ',' ) except Exception as e : x , y , z , roll , pitch , yaw = line . split ( sep = ',' ) result . append ([ float ( x ), float ( y ), float ( z )]) return result","title":"read_txt()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.track_visualizer.visualize_track_data","text":"Source code in ROAR/utilities_module/track_visualizer.py def visualize_track_data ( track_data : List [ List [ float ]]): print ( f \"Visualizing [ { len ( track_data ) } ] data points\" ) track_data = np . asarray ( track_data ) fig = go . Figure ( data = [ go . Scatter3d ( x = track_data [:, 0 ], y = [ 0 ] * len ( track_data ), z = track_data [:, 2 ], mode = 'markers' )]) fig . show ()","title":"visualize_track_data()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.utilities","text":"","title":"utilities"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.utilities.img_to_world","text":"Compute image to world translation using the formula below ((R_world_veh)^(-1) @ (R_veh_cam)^(-1) @ ((intrinsics)^(-1) @ scaled_depth_image).pad_with_1)[:3, :] = [X Y Z] Parameters: Name Type Description Default scaled_depth_image ndarray 3 x n numpy array required intrinsics_matrix ndarray 3 x 3 intrinsics required veh_world_matrix ndarray 4 x 4 vehicle to world transformation matrix required cam_veh_matrix ndarray 4 x 4 camera to vehicle transformation matrix required Returns: Type Description ndarray n x 3 array of n points Source code in ROAR/utilities_module/utilities.py def img_to_world ( scaled_depth_image : np . ndarray , intrinsics_matrix : np . ndarray , veh_world_matrix : np . ndarray , cam_veh_matrix : np . ndarray ) -> np . ndarray : \"\"\" Compute image to world translation using the formula below ((R_world_veh)^(-1) @ (R_veh_cam)^(-1) @ ((intrinsics)^(-1) @ scaled_depth_image).pad_with_1)[:3, :] = [X Y Z] Args: scaled_depth_image: 3 x n numpy array intrinsics_matrix: 3 x 3 intrinsics veh_world_matrix: 4 x 4 vehicle to world transformation matrix cam_veh_matrix: 4 x 4 camera to vehicle transformation matrix Returns: n x 3 array of n points \"\"\" assert scaled_depth_image . shape [ 0 ] == 3 , f \"scaled depth image has incorrect shape [ { scaled_depth_image . shape } ]\" assert intrinsics_matrix . shape == ( 3 , 3 ), f \"Intrinsics matrix has incorrect shape [ { intrinsics_matrix . shape } ]\" assert veh_world_matrix . shape == ( 4 , 4 ), f \"Intrinsics matrix has incorrect shape [ { intrinsics_matrix . shape } ]\" assert cam_veh_matrix . shape == ( 4 , 4 ), f \"Intrinsics matrix has incorrect shape [ { intrinsics_matrix . shape } ]\" # extrinsics @ inv(K) @ [u, v,1] = [X,Y,Z] k_inv = np . linalg . inv ( intrinsics_matrix ) raw_p3d = k_inv @ scaled_depth_image ones = np . ones ( shape = np . shape ( raw_p3d )[ 1 ]) # raw_p3d_padded = np.vstack([raw_p3d, ones]) raw_p3d_padded = np . vstack ([ raw_p3d [ 2 , :], raw_p3d [ 0 , :], - raw_p3d [ 1 , :], ones ]) points : np . ndarray = ( veh_world_matrix @ cam_veh_matrix @ raw_p3d_padded )[: 3 , :] . T return points","title":"img_to_world()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.utilities.img_to_world2","text":"Source code in ROAR/utilities_module/utilities.py def img_to_world2 ( depth_img , intrinsics_matrix , extrinsics_matrix , segmentation : np . ndarray , criteria , depth_scaling_factor = 1000 ) -> np . ndarray : # get a 2 x N array for their indices ground_loc = np . where ( segmentation == criteria )[: 2 ] # print(ground) # ground_loc = np.where(depth_img == criteria) depth_val = depth_img [ ground_loc ] * depth_scaling_factor ground_loc = ground_loc * depth_val # compute raw_points raw_points = np . vstack ([ ground_loc , depth_val ]) # convert to cords_y_minus_z_x cords_y_minus_z_x = np . linalg . inv ( intrinsics_matrix ) @ raw_points # convert to cords_xyz_1 ones = np . ones (( 1 , np . shape ( cords_y_minus_z_x )[ 1 ])) cords_xyz_1 = np . vstack ([ cords_y_minus_z_x [ 2 , :], cords_y_minus_z_x [ 0 , :], - cords_y_minus_z_x [ 1 , :], ones ]) # multiply by cam_world_matrix points = extrinsics_matrix @ cords_xyz_1 # i have all points now return points","title":"img_to_world2()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.utilities.png_to_depth","text":"Takes in an image read from cv2.imread(), whose output is simply a numpy array, turn it into a depth image according to carla's method of (R + G * 256 + B * 256 * 256) / (256 * 256 * 256 - 1). Parameters: Name Type Description Default im <built-in function array> input image, read from cv2.imread() required Returns: Type Description <built-in function array> depth image Source code in ROAR/utilities_module/utilities.py def png_to_depth ( im : np . array ) -> np . array : \"\"\" Takes in an image read from cv2.imread(), whose output is simply a numpy array, turn it into a depth image according to carla's method of (R + G * 256 + B * 256 * 256) / (256 * 256 * 256 - 1). Args: im: input image, read from cv2.imread() Returns: depth image \"\"\" im = im . astype ( np . float64 ) normalized_depth = np . dot ( im [:, :, : 3 ], [ 1 , 256 , 65536.0 ]) normalized_depth /= 16777215.0 return normalized_depth","title":"png_to_depth()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.utilities.rotation_matrix_from_euler","text":"Takes in roll pitch yaw and compute rotation matrix using the order of R = R_yaw * R_pitch * R_roll http://planning.cs.uiuc.edu/node104.html Parameters: Name Type Description Default roll float float of roll in degree required pitch float float of pitch in degree required yaw float float of yaw in degree required Returns: Type Description ndarray 3 x 3 array rotation matrix Source code in ROAR/utilities_module/utilities.py def rotation_matrix_from_euler ( roll : float , pitch : float , yaw : float ) -> np . ndarray : \"\"\" Takes in roll pitch yaw and compute rotation matrix using the order of R = R_yaw * R_pitch * R_roll http://planning.cs.uiuc.edu/node104.html Args: roll: float of roll in degree pitch: float of pitch in degree yaw: float of yaw in degree Returns: 3 x 3 array rotation matrix \"\"\" ry , rx , rz = np . radians ( yaw ), np . radians ( pitch ), np . radians ( roll ) Rx = np . array ([ [ 1 , 0 , 0 ], [ 0 , np . cos ( rx ), - np . sin ( rx )], [ 0 , np . sin ( rx ), np . cos ( rx )] ]) Ry = np . array ([ [ np . cos ( ry ), 0 , np . sin ( ry )], [ 0 , 1 , 0 ], [ - np . sin ( ry ), 0 , np . cos ( ry )] ]) Rz = np . array ([ [ np . cos ( rz ), - np . sin ( rz ), 0 ], [ np . sin ( rz ), np . cos ( rz ), 0 ], [ 0 , 0 , 1 ] ]) return Rx @ Ry @ Rz","title":"rotation_matrix_from_euler()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models","text":"","title":"vehicle_models"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.Vehicle","text":"Encodes the Vehicle's state at the last tick","title":"Vehicle"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.Vehicle.control","text":"","title":"control"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.Vehicle.transform","text":"","title":"transform"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.Vehicle.velocity","text":"","title":"velocity"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.Vehicle.wheel_base","text":"Default to tesla model 3's wheel base","title":"wheel_base"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.Vehicle.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.Vehicle.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.Vehicle.get_speed","text":"Compute speed of a vehicle in Km/h. :param vehicle: the vehicle for which speed is calculated :return: speed as a float in Km/h Source code in ROAR/utilities_module/vehicle_models.py @staticmethod def get_speed ( vehicle ): # TODO consider the jetson case \"\"\" Compute speed of a vehicle in Km/h. :param vehicle: the vehicle for which speed is calculated :return: speed as a float in Km/h \"\"\" vel = vehicle . velocity return 3.6 * math . sqrt ( vel . x ** 2 + vel . y ** 2 + vel . z ** 2 )","title":"get_speed()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.Vehicle.to_array","text":"Source code in ROAR/utilities_module/vehicle_models.py def to_array ( self ): return np . concatenate ([ self . velocity . to_array (), self . transform . to_array (), self . control . to_array ()])","title":"to_array()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.VehicleControl","text":"","title":"VehicleControl"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.VehicleControl.steering","text":"","title":"steering"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.VehicleControl.throttle","text":"","title":"throttle"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.VehicleControl.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.VehicleControl.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.VehicleControl.clamp","text":"Source code in ROAR/utilities_module/vehicle_models.py @staticmethod def clamp ( n , minn , maxn ): return max ( min ( maxn , n ), minn )","title":"clamp()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.VehicleControl.get_steering","text":"Cap it between -1 and 1 :return: Source code in ROAR/utilities_module/vehicle_models.py def get_steering ( self ) -> float : \"\"\" Cap it between -1 and 1 :return: \"\"\" return self . clamp ( self . steering , - 1 , 1 )","title":"get_steering()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.VehicleControl.get_throttle","text":"Cap it between -1 and 1 :return: Source code in ROAR/utilities_module/vehicle_models.py def get_throttle ( self ) -> float : \"\"\" Cap it between -1 and 1 :return: \"\"\" return self . clamp ( self . throttle , - 1 , 1 )","title":"get_throttle()"},{"location":"code_documentations/ROAR/utilities_module/#ROAR.utilities_module.vehicle_models.VehicleControl.to_array","text":"Source code in ROAR/utilities_module/vehicle_models.py def to_array ( self ) -> np . ndarray : return np . array ([ self . throttle , self . steering ])","title":"to_array()"},{"location":"code_documentations/ROAR/visualization/","text":"visualizer \u00a4 Visualizer \u00a4 GREEN \u00a4 GROUND \u00a4 __init__ ( self , agent , occupancy_grid_map = None ) special \u00a4 Source code in ROAR/visualization_module/visualizer.py def __init__ ( self , agent : Agent , occupancy_grid_map : Optional [ OccupancyGridMap ] = None , ): self . logger = logging . getLogger ( __name__ ) self . agent = agent self . occupancy_grid_map = occupancy_grid_map calculate_img_pos ( self , waypoint_transform , camera ) \u00a4 Calculate the 2D image coordinate from 3D world space Parameters: Name Type Description Default camera Camera required waypoint_transform Transform Desired point in 3D world space required Returns: Type Description ndarray Array if integers [X, Y, depth] Source code in ROAR/visualization_module/visualizer.py @deprecated ( reason = \"Will no longer support single image to world calculation.\" ) def calculate_img_pos ( self , waypoint_transform : Transform , camera : Camera ) -> np . ndarray : \"\"\" Calculate the 2D image coordinate from 3D world space Args: camera: waypoint_transform: Desired point in 3D world space Returns: Array if integers [X, Y, depth] \"\"\" waypoint_location = waypoint_transform . location . to_array () # [x, y, z] waypoint_location = np . concatenate ( [ waypoint_location , [ 1 ]] ) # 4 x 1 array [X, Y, Z, 1] veh_cam_matrix = camera . transform . get_matrix () # 4 x 4 world_veh_matrix = self . agent . vehicle . transform . get_matrix () # 4 x 4 world_cam_matrix = np . linalg . inv ( np . dot ( world_veh_matrix , veh_cam_matrix )) cords_xyz = world_cam_matrix @ waypoint_location # print(cords_xyz) cords_y_minus_z_x = np . array ([ cords_xyz [ 1 ], - cords_xyz [ 2 ], cords_xyz [ 0 ]]) # cords_y_minus_z_x = np.array([cords_xyz[0], cords_xyz[1], -cords_xyz[2]]) raw_p2d = camera . intrinsics_matrix @ cords_y_minus_z_x print ( camera . intrinsics_matrix ) # print(raw_p2d) cam_cords = np . array ( [ raw_p2d [ 0 ] / raw_p2d [ 2 ], raw_p2d [ 1 ] / raw_p2d [ 2 ], raw_p2d [ 2 ]] ) result = np . round ( cam_cords , 0 ) . astype ( np . int64 ) # print(result) return result show_birds_eye_visualization ( self , focus_on_vehicle = True , view_size = 200 ) \u00a4 Visualizes top down image of Agent. Parameters: Name Type Description Default focus_on_vehicle bool True view_size int 200 Returns: Type Description None Source code in ROAR/visualization_module/visualizer.py def show_birds_eye_visualization ( self , focus_on_vehicle : bool = True , view_size : int = 200 ): \"\"\" Visualizes top down image of Agent. Args: focus_on_vehicle (): view_size (): Returns: None \"\"\" if self . occupancy_grid_map is None : self . logger . error ( \"No Occupancy Grid Map is connected\" ) else : if focus_on_vehicle : occu_cord = self . occupancy_grid_map . location_to_occu_cord ( location = self . agent . vehicle . transform . location ) map_copy = self . occupancy_grid_map . _map . copy () x , y = occu_cord [ 0 ] map_copy [ y - self . occupancy_grid_map . _vehicle_height // 2 : y + self . occupancy_grid_map . _vehicle_height // 2 , x - self . occupancy_grid_map . _vehicle_width // 2 : x + self . occupancy_grid_map . _vehicle_width // 2 ] = 0 cv2 . imshow ( \"Occupancy Grid Map\" , map_copy [ y - view_size // 2 : y + view_size // 2 :, x - view_size // 2 : x + view_size // 2 ]) else : cv2 . imshow ( \"Occupancy Grid Map\" , self . occupancy_grid_map . _map ) cv2 . waitKey ( 1 ) show_first_person_visualization ( self , show_num_waypoints = 0 , show_point_cloud_ground = False , ground_points = None ) \u00a4 Visualizes image from Front RGB Camera. Parameters: Name Type Description Default show_num_waypoints int 0 show_semantic_segmentation_obstacle required show_semantic_segmentation_sky required show_semantic_segmentation_ground required show_point_cloud_ground bool False ground_points Optional[numpy.ndarray] None Returns: Type Description None Source code in ROAR/visualization_module/visualizer.py def show_first_person_visualization ( self , show_num_waypoints : int = 0 , show_point_cloud_ground : bool = False , ground_points : Optional [ np . ndarray ] = None ): \"\"\" Visualizes image from Front RGB Camera. Args: show_num_waypoints (): show_semantic_segmentation_obstacle (): show_semantic_segmentation_sky (): show_semantic_segmentation_ground (): show_point_cloud_ground (): ground_points (): Returns: None \"\"\" rgb_img = self . agent . front_rgb_camera . data . copy () if show_point_cloud_ground and ground_points is not None : img_cords : np . ndarray = self . world_to_img_transform ( ground_points )[:, : 2 ] # ys = [342, 278, 271, 413 ,327 ,169 ,415, 747 ,507 ,311,311,311,311,311,311] # xs = [577, 513 ,531, 522 ,372 ,581, 470 ,484, 587, 523,524,525,526,527,528] # rgb_img[xs, ys] = [0, 0, 0] rgb_img [ img_cords [:, 1 ], img_cords [:, 0 ]] = [ 0 , 0 , 0 ] # TODO this aint working lol if self . agent . local_planner is not None and \\ 0 < show_num_waypoints < len ( self . agent . local_planner . way_points_queue ): img_positions = self . world_to_img_transform ( np . array ( [ self . agent . local_planner . way_points_queue [ i ] . location . to_array () for i in range ( show_num_waypoints )])) for y , x , _ in img_positions : rgb_img [ x - 2 : x + 2 , y - 2 : y + 2 ] = self . GREEN cv2 . imshow ( \"First Person View\" , rgb_img ) cv2 . waitKey ( 1 ) visualize ( self , next_waypoint_transform ) \u00a4 This function will allow multiple objects to be drawn on here. Parameters: Name Type Description Default next_waypoint_transform Transform Next Waypoint's Transform information required Returns: Type Description None None Source code in ROAR/visualization_module/visualizer.py @deprecated ( reason = \"Will no longer support next waypoint visualization on a single display\" ) def visualize ( self , next_waypoint_transform : Transform ) -> None : \"\"\" This function will allow multiple objects to be drawn on here. Args: next_waypoint_transform: Next Waypoint's Transform information Returns: None \"\"\" next_waypoint_cam_pos = self . calculate_img_pos ( waypoint_transform = next_waypoint_transform , camera = self . agent . front_depth_camera , ) img = self . agent . front_rgb_camera . data . copy () start_point = ( 400 , 600 ) img = cv2 . arrowedLine ( img = img , pt1 = start_point , pt2 = ( next_waypoint_cam_pos [ 0 ], next_waypoint_cam_pos [ 1 ]), color = ( 0 , 255 , 0 ), thickness = 2 , ) cv2 . imshow ( \"Visualization\" , img ) cv2 . waitKey ( 1 ) visualize_semantic_segmentation ( cls , semantic_segmetation ) classmethod \u00a4 Parameters: Name Type Description Default semantic_segmetation Width x Height x 3 array with white = obstacles, black = ground, blue = sky required Returns: Type Description None None Source code in ROAR/visualization_module/visualizer.py @classmethod @deprecated ( reason = \"will no longer support single semantic segmentation visualization\" ) def visualize_semantic_segmentation ( cls , semantic_segmetation ) -> None : \"\"\" Args: semantic_segmetation: Width x Height x 3 array with white = obstacles, black = ground, blue = sky Returns: None \"\"\" if semantic_segmetation is not None : cv2 . imshow ( \"Semantic Segmentation\" , semantic_segmetation ) cv2 . waitKey ( 1 ) visualize_waypoint ( self , waypoint_transform ) \u00a4 Source code in ROAR/visualization_module/visualizer.py @deprecated ( reason = \"Will no longer support seperate graph visualization\" ) def visualize_waypoint ( self , waypoint_transform : Transform ): coords = self . world_to_img_transform ( xyz = np . array ([[ waypoint_transform . location . x , waypoint_transform . location . y , waypoint_transform . location . z ]])) img = self . agent . front_rgb_camera . data . copy () img = cv2 . arrowedLine ( img , ( 400 , 600 ), ( coords [ 0 ][ 0 ], coords [ 0 ][ 1 ]), ( 0 , 255 , 0 ), 2 ) cv2 . imshow ( \"Next Waypoint\" , img ) cv2 . waitKey ( 1 ) world_to_img_transform ( self , xyz ) \u00a4 Calculate the 2D image coordinate from 3D world space Parameters: Name Type Description Default xyz ndarray (Nx3) array representing X, Y, Z in world coord required Returns: Type Description ndarray Array if integers [u, v, f] Source code in ROAR/visualization_module/visualizer.py def world_to_img_transform ( self , xyz : np . ndarray ) -> np . ndarray : \"\"\" Calculate the 2D image coordinate from 3D world space Args: xyz: (Nx3) array representing X, Y, Z in world coord Returns: Array if integers [u, v, f] \"\"\" xyz1 = np . append ( xyz , np . ones ( shape = ( len ( xyz ), 1 )), axis = 1 ) UVD = self . agent . front_depth_camera . intrinsics_matrix @ \\ self . agent . front_depth_camera . transform . get_matrix ()[: 3 ] @ \\ self . agent . vehicle . transform . get_matrix () @ xyz1 . T uvd = np . array ([ UVD [ 0 , :] / UVD [ 2 , :], UVD [ 1 , :] / UVD [ 2 , :], UVD [ 2 , :] ]) . T result = np . round ( uvd , 0 ) . astype ( np . int64 ) print ( f \"waypoint: { xyz } | Agent = { self . agent . vehicle . transform } | Pixel = { result } \" ) return result","title":"Visualization Module"},{"location":"code_documentations/ROAR/visualization/#ROAR.visualization_module.visualizer","text":"","title":"visualizer"},{"location":"code_documentations/ROAR/visualization/#ROAR.visualization_module.visualizer.Visualizer","text":"","title":"Visualizer"},{"location":"code_documentations/ROAR/visualization/#ROAR.visualization_module.visualizer.Visualizer.GREEN","text":"","title":"GREEN"},{"location":"code_documentations/ROAR/visualization/#ROAR.visualization_module.visualizer.Visualizer.GROUND","text":"","title":"GROUND"},{"location":"code_documentations/ROAR/visualization/#ROAR.visualization_module.visualizer.Visualizer.__init__","text":"Source code in ROAR/visualization_module/visualizer.py def __init__ ( self , agent : Agent , occupancy_grid_map : Optional [ OccupancyGridMap ] = None , ): self . logger = logging . getLogger ( __name__ ) self . agent = agent self . occupancy_grid_map = occupancy_grid_map","title":"__init__()"},{"location":"code_documentations/ROAR/visualization/#ROAR.visualization_module.visualizer.Visualizer.calculate_img_pos","text":"Calculate the 2D image coordinate from 3D world space Parameters: Name Type Description Default camera Camera required waypoint_transform Transform Desired point in 3D world space required Returns: Type Description ndarray Array if integers [X, Y, depth] Source code in ROAR/visualization_module/visualizer.py @deprecated ( reason = \"Will no longer support single image to world calculation.\" ) def calculate_img_pos ( self , waypoint_transform : Transform , camera : Camera ) -> np . ndarray : \"\"\" Calculate the 2D image coordinate from 3D world space Args: camera: waypoint_transform: Desired point in 3D world space Returns: Array if integers [X, Y, depth] \"\"\" waypoint_location = waypoint_transform . location . to_array () # [x, y, z] waypoint_location = np . concatenate ( [ waypoint_location , [ 1 ]] ) # 4 x 1 array [X, Y, Z, 1] veh_cam_matrix = camera . transform . get_matrix () # 4 x 4 world_veh_matrix = self . agent . vehicle . transform . get_matrix () # 4 x 4 world_cam_matrix = np . linalg . inv ( np . dot ( world_veh_matrix , veh_cam_matrix )) cords_xyz = world_cam_matrix @ waypoint_location # print(cords_xyz) cords_y_minus_z_x = np . array ([ cords_xyz [ 1 ], - cords_xyz [ 2 ], cords_xyz [ 0 ]]) # cords_y_minus_z_x = np.array([cords_xyz[0], cords_xyz[1], -cords_xyz[2]]) raw_p2d = camera . intrinsics_matrix @ cords_y_minus_z_x print ( camera . intrinsics_matrix ) # print(raw_p2d) cam_cords = np . array ( [ raw_p2d [ 0 ] / raw_p2d [ 2 ], raw_p2d [ 1 ] / raw_p2d [ 2 ], raw_p2d [ 2 ]] ) result = np . round ( cam_cords , 0 ) . astype ( np . int64 ) # print(result) return result","title":"calculate_img_pos()"},{"location":"code_documentations/ROAR/visualization/#ROAR.visualization_module.visualizer.Visualizer.show_birds_eye_visualization","text":"Visualizes top down image of Agent. Parameters: Name Type Description Default focus_on_vehicle bool True view_size int 200 Returns: Type Description None Source code in ROAR/visualization_module/visualizer.py def show_birds_eye_visualization ( self , focus_on_vehicle : bool = True , view_size : int = 200 ): \"\"\" Visualizes top down image of Agent. Args: focus_on_vehicle (): view_size (): Returns: None \"\"\" if self . occupancy_grid_map is None : self . logger . error ( \"No Occupancy Grid Map is connected\" ) else : if focus_on_vehicle : occu_cord = self . occupancy_grid_map . location_to_occu_cord ( location = self . agent . vehicle . transform . location ) map_copy = self . occupancy_grid_map . _map . copy () x , y = occu_cord [ 0 ] map_copy [ y - self . occupancy_grid_map . _vehicle_height // 2 : y + self . occupancy_grid_map . _vehicle_height // 2 , x - self . occupancy_grid_map . _vehicle_width // 2 : x + self . occupancy_grid_map . _vehicle_width // 2 ] = 0 cv2 . imshow ( \"Occupancy Grid Map\" , map_copy [ y - view_size // 2 : y + view_size // 2 :, x - view_size // 2 : x + view_size // 2 ]) else : cv2 . imshow ( \"Occupancy Grid Map\" , self . occupancy_grid_map . _map ) cv2 . waitKey ( 1 )","title":"show_birds_eye_visualization()"},{"location":"code_documentations/ROAR/visualization/#ROAR.visualization_module.visualizer.Visualizer.show_first_person_visualization","text":"Visualizes image from Front RGB Camera. Parameters: Name Type Description Default show_num_waypoints int 0 show_semantic_segmentation_obstacle required show_semantic_segmentation_sky required show_semantic_segmentation_ground required show_point_cloud_ground bool False ground_points Optional[numpy.ndarray] None Returns: Type Description None Source code in ROAR/visualization_module/visualizer.py def show_first_person_visualization ( self , show_num_waypoints : int = 0 , show_point_cloud_ground : bool = False , ground_points : Optional [ np . ndarray ] = None ): \"\"\" Visualizes image from Front RGB Camera. Args: show_num_waypoints (): show_semantic_segmentation_obstacle (): show_semantic_segmentation_sky (): show_semantic_segmentation_ground (): show_point_cloud_ground (): ground_points (): Returns: None \"\"\" rgb_img = self . agent . front_rgb_camera . data . copy () if show_point_cloud_ground and ground_points is not None : img_cords : np . ndarray = self . world_to_img_transform ( ground_points )[:, : 2 ] # ys = [342, 278, 271, 413 ,327 ,169 ,415, 747 ,507 ,311,311,311,311,311,311] # xs = [577, 513 ,531, 522 ,372 ,581, 470 ,484, 587, 523,524,525,526,527,528] # rgb_img[xs, ys] = [0, 0, 0] rgb_img [ img_cords [:, 1 ], img_cords [:, 0 ]] = [ 0 , 0 , 0 ] # TODO this aint working lol if self . agent . local_planner is not None and \\ 0 < show_num_waypoints < len ( self . agent . local_planner . way_points_queue ): img_positions = self . world_to_img_transform ( np . array ( [ self . agent . local_planner . way_points_queue [ i ] . location . to_array () for i in range ( show_num_waypoints )])) for y , x , _ in img_positions : rgb_img [ x - 2 : x + 2 , y - 2 : y + 2 ] = self . GREEN cv2 . imshow ( \"First Person View\" , rgb_img ) cv2 . waitKey ( 1 )","title":"show_first_person_visualization()"},{"location":"code_documentations/ROAR/visualization/#ROAR.visualization_module.visualizer.Visualizer.visualize","text":"This function will allow multiple objects to be drawn on here. Parameters: Name Type Description Default next_waypoint_transform Transform Next Waypoint's Transform information required Returns: Type Description None None Source code in ROAR/visualization_module/visualizer.py @deprecated ( reason = \"Will no longer support next waypoint visualization on a single display\" ) def visualize ( self , next_waypoint_transform : Transform ) -> None : \"\"\" This function will allow multiple objects to be drawn on here. Args: next_waypoint_transform: Next Waypoint's Transform information Returns: None \"\"\" next_waypoint_cam_pos = self . calculate_img_pos ( waypoint_transform = next_waypoint_transform , camera = self . agent . front_depth_camera , ) img = self . agent . front_rgb_camera . data . copy () start_point = ( 400 , 600 ) img = cv2 . arrowedLine ( img = img , pt1 = start_point , pt2 = ( next_waypoint_cam_pos [ 0 ], next_waypoint_cam_pos [ 1 ]), color = ( 0 , 255 , 0 ), thickness = 2 , ) cv2 . imshow ( \"Visualization\" , img ) cv2 . waitKey ( 1 )","title":"visualize()"},{"location":"code_documentations/ROAR/visualization/#ROAR.visualization_module.visualizer.Visualizer.visualize_semantic_segmentation","text":"Parameters: Name Type Description Default semantic_segmetation Width x Height x 3 array with white = obstacles, black = ground, blue = sky required Returns: Type Description None None Source code in ROAR/visualization_module/visualizer.py @classmethod @deprecated ( reason = \"will no longer support single semantic segmentation visualization\" ) def visualize_semantic_segmentation ( cls , semantic_segmetation ) -> None : \"\"\" Args: semantic_segmetation: Width x Height x 3 array with white = obstacles, black = ground, blue = sky Returns: None \"\"\" if semantic_segmetation is not None : cv2 . imshow ( \"Semantic Segmentation\" , semantic_segmetation ) cv2 . waitKey ( 1 )","title":"visualize_semantic_segmentation()"},{"location":"code_documentations/ROAR/visualization/#ROAR.visualization_module.visualizer.Visualizer.visualize_waypoint","text":"Source code in ROAR/visualization_module/visualizer.py @deprecated ( reason = \"Will no longer support seperate graph visualization\" ) def visualize_waypoint ( self , waypoint_transform : Transform ): coords = self . world_to_img_transform ( xyz = np . array ([[ waypoint_transform . location . x , waypoint_transform . location . y , waypoint_transform . location . z ]])) img = self . agent . front_rgb_camera . data . copy () img = cv2 . arrowedLine ( img , ( 400 , 600 ), ( coords [ 0 ][ 0 ], coords [ 0 ][ 1 ]), ( 0 , 255 , 0 ), 2 ) cv2 . imshow ( \"Next Waypoint\" , img ) cv2 . waitKey ( 1 )","title":"visualize_waypoint()"},{"location":"code_documentations/ROAR/visualization/#ROAR.visualization_module.visualizer.Visualizer.world_to_img_transform","text":"Calculate the 2D image coordinate from 3D world space Parameters: Name Type Description Default xyz ndarray (Nx3) array representing X, Y, Z in world coord required Returns: Type Description ndarray Array if integers [u, v, f] Source code in ROAR/visualization_module/visualizer.py def world_to_img_transform ( self , xyz : np . ndarray ) -> np . ndarray : \"\"\" Calculate the 2D image coordinate from 3D world space Args: xyz: (Nx3) array representing X, Y, Z in world coord Returns: Array if integers [u, v, f] \"\"\" xyz1 = np . append ( xyz , np . ones ( shape = ( len ( xyz ), 1 )), axis = 1 ) UVD = self . agent . front_depth_camera . intrinsics_matrix @ \\ self . agent . front_depth_camera . transform . get_matrix ()[: 3 ] @ \\ self . agent . vehicle . transform . get_matrix () @ xyz1 . T uvd = np . array ([ UVD [ 0 , :] / UVD [ 2 , :], UVD [ 1 , :] / UVD [ 2 , :], UVD [ 2 , :] ]) . T result = np . round ( uvd , 0 ) . astype ( np . int64 ) print ( f \"waypoint: { xyz } | Agent = { self . agent . vehicle . transform } | Pixel = { result } \" ) return result","title":"world_to_img_transform()"},{"location":"code_documentations/ROAR_Sim/camera/","text":"CameraManager \u00a4 __init__ ( self , parent_actor , hud , gamma_correction ) special \u00a4 Source code in carla_client/util/camera_manager.py def __init__ ( self , parent_actor , hud , gamma_correction ): self . sensor = None self . surface = None self . _parent = parent_actor self . hud = hud self . recording = False self . logger = logging . getLogger ( \"Camera Manager\" ) bound_y = 0.5 + self . _parent . bounding_box . extent . y Attachment = carla . AttachmentType self . _camera_transforms = [ ( carla . Transform ( carla . Location ( x =- 5.5 , z = 2.5 ), carla . Rotation ( pitch = 8.0 ) ), Attachment . SpringArm , ), ( carla . Transform ( carla . Location ( x = 1.6 , z = 1.7 )), Attachment . Rigid ), ( carla . Transform ( carla . Location ( x = 5.5 , y = 1.5 , z = 1.5 )), Attachment . SpringArm , ), ( carla . Transform ( carla . Location ( x =- 8.0 , z = 6.0 ), carla . Rotation ( pitch = 6.0 ) ), Attachment . SpringArm , ), ( carla . Transform ( carla . Location ( x =- 1 , y =- bound_y , z = 0.5 )), Attachment . Rigid , ), ] self . transform_index = 1 self . sensors = [ [ \"sensor.camera.rgb\" , cc . Raw , \"Camera RGB\" , {}], [ \"sensor.camera.depth\" , cc . Raw , \"Camera Depth (Raw)\" , {}], [ \"sensor.camera.depth\" , cc . Depth , \"Camera Depth (Gray Scale)\" , {}], [ \"sensor.camera.depth\" , cc . LogarithmicDepth , \"Camera Depth (Logarithmic Gray Scale)\" , {}, ], [ \"sensor.camera.semantic_segmentation\" , cc . Raw , \"Camera Semantic Segmentation (Raw)\" , {}, ], [ \"sensor.camera.semantic_segmentation\" , cc . CityScapesPalette , \"Camera Semantic Segmentation (CityScapes Palette)\" , {}, ], [ \"sensor.lidar.ray_cast\" , None , \"Lidar (Ray-Cast)\" , {}], [ \"sensor.camera.dvs\" , cc . Raw , \"Dynamic Vision Sensor\" , {}], [ \"sensor.camera.rgb\" , cc . Raw , \"Camera RGB Distorted\" , { \"lens_circle_multiplier\" : \"3.0\" , \"lens_circle_falloff\" : \"3.0\" , \"chromatic_aberration_intensity\" : \"0.5\" , \"chromatic_aberration_offset\" : \"0\" , }, ], ] world = self . _parent . get_world () bp_library = world . get_blueprint_library () for item in self . sensors : bp = bp_library . find ( item [ 0 ]) if item [ 0 ] . startswith ( \"sensor.camera\" ): bp . set_attribute ( \"image_size_x\" , str ( hud . dim [ 0 ])) bp . set_attribute ( \"image_size_y\" , str ( hud . dim [ 1 ])) if bp . has_attribute ( \"gamma\" ): bp . set_attribute ( \"gamma\" , str ( gamma_correction )) for attr_name , attr_value in item [ 3 ] . items (): bp . set_attribute ( attr_name , attr_value ) elif item [ 0 ] . startswith ( \"sensor.lidar\" ): bp . set_attribute ( \"range\" , \"50\" ) item . append ( bp ) self . index = None next_sensor ( self ) \u00a4 Source code in carla_client/util/camera_manager.py def next_sensor ( self ): self . set_sensor ( self . index + 1 ) render ( self , display ) \u00a4 Source code in carla_client/util/camera_manager.py def render ( self , display ): if self . surface is not None : display . blit ( self . surface , ( 0 , 0 )) set_sensor ( self , index , notify = True , force_respawn = False ) \u00a4 Source code in carla_client/util/camera_manager.py def set_sensor ( self , index , notify = True , force_respawn = False ): index = index % len ( self . sensors ) needs_respawn = ( True if self . index is None else ( force_respawn or ( self . sensors [ index ][ 2 ] != self . sensors [ self . index ][ 2 ]) ) ) if needs_respawn : if self . sensor is not None : self . sensor . destroy () self . surface = None self . sensor = self . _parent . get_world () . spawn_actor ( self . sensors [ index ][ - 1 ], self . _camera_transforms [ self . transform_index ][ 0 ], attach_to = self . _parent , attachment_type = self . _camera_transforms [ self . transform_index ][ 1 ], ) # We need to pass the lambda a weak reference to self to avoid # circular reference. weak_self = weakref . ref ( self ) self . sensor . listen ( lambda image : CameraManager . _parse_image ( weak_self , image ) ) if notify : self . hud . notification ( self . sensors [ index ][ 2 ]) self . index = index toggle_camera ( self ) \u00a4 Source code in carla_client/util/camera_manager.py def toggle_camera ( self ): self . transform_index = ( self . transform_index + 1 ) % len ( self . _camera_transforms ) self . set_sensor ( self . index , notify = False , force_respawn = True ) toggle_recording ( self ) \u00a4 Source code in carla_client/util/camera_manager.py def toggle_recording ( self ): self . recording = not self . recording self . hud . notification ( \"Recording %s \" % ( \"On\" if self . recording else \"Off\" ))","title":"Camera Manager"},{"location":"code_documentations/ROAR_Sim/camera/#ROAR_Sim.carla_client.util.camera_manager.CameraManager","text":"","title":"CameraManager"},{"location":"code_documentations/ROAR_Sim/camera/#ROAR_Sim.carla_client.util.camera_manager.CameraManager.__init__","text":"Source code in carla_client/util/camera_manager.py def __init__ ( self , parent_actor , hud , gamma_correction ): self . sensor = None self . surface = None self . _parent = parent_actor self . hud = hud self . recording = False self . logger = logging . getLogger ( \"Camera Manager\" ) bound_y = 0.5 + self . _parent . bounding_box . extent . y Attachment = carla . AttachmentType self . _camera_transforms = [ ( carla . Transform ( carla . Location ( x =- 5.5 , z = 2.5 ), carla . Rotation ( pitch = 8.0 ) ), Attachment . SpringArm , ), ( carla . Transform ( carla . Location ( x = 1.6 , z = 1.7 )), Attachment . Rigid ), ( carla . Transform ( carla . Location ( x = 5.5 , y = 1.5 , z = 1.5 )), Attachment . SpringArm , ), ( carla . Transform ( carla . Location ( x =- 8.0 , z = 6.0 ), carla . Rotation ( pitch = 6.0 ) ), Attachment . SpringArm , ), ( carla . Transform ( carla . Location ( x =- 1 , y =- bound_y , z = 0.5 )), Attachment . Rigid , ), ] self . transform_index = 1 self . sensors = [ [ \"sensor.camera.rgb\" , cc . Raw , \"Camera RGB\" , {}], [ \"sensor.camera.depth\" , cc . Raw , \"Camera Depth (Raw)\" , {}], [ \"sensor.camera.depth\" , cc . Depth , \"Camera Depth (Gray Scale)\" , {}], [ \"sensor.camera.depth\" , cc . LogarithmicDepth , \"Camera Depth (Logarithmic Gray Scale)\" , {}, ], [ \"sensor.camera.semantic_segmentation\" , cc . Raw , \"Camera Semantic Segmentation (Raw)\" , {}, ], [ \"sensor.camera.semantic_segmentation\" , cc . CityScapesPalette , \"Camera Semantic Segmentation (CityScapes Palette)\" , {}, ], [ \"sensor.lidar.ray_cast\" , None , \"Lidar (Ray-Cast)\" , {}], [ \"sensor.camera.dvs\" , cc . Raw , \"Dynamic Vision Sensor\" , {}], [ \"sensor.camera.rgb\" , cc . Raw , \"Camera RGB Distorted\" , { \"lens_circle_multiplier\" : \"3.0\" , \"lens_circle_falloff\" : \"3.0\" , \"chromatic_aberration_intensity\" : \"0.5\" , \"chromatic_aberration_offset\" : \"0\" , }, ], ] world = self . _parent . get_world () bp_library = world . get_blueprint_library () for item in self . sensors : bp = bp_library . find ( item [ 0 ]) if item [ 0 ] . startswith ( \"sensor.camera\" ): bp . set_attribute ( \"image_size_x\" , str ( hud . dim [ 0 ])) bp . set_attribute ( \"image_size_y\" , str ( hud . dim [ 1 ])) if bp . has_attribute ( \"gamma\" ): bp . set_attribute ( \"gamma\" , str ( gamma_correction )) for attr_name , attr_value in item [ 3 ] . items (): bp . set_attribute ( attr_name , attr_value ) elif item [ 0 ] . startswith ( \"sensor.lidar\" ): bp . set_attribute ( \"range\" , \"50\" ) item . append ( bp ) self . index = None","title":"__init__()"},{"location":"code_documentations/ROAR_Sim/camera/#ROAR_Sim.carla_client.util.camera_manager.CameraManager.next_sensor","text":"Source code in carla_client/util/camera_manager.py def next_sensor ( self ): self . set_sensor ( self . index + 1 )","title":"next_sensor()"},{"location":"code_documentations/ROAR_Sim/camera/#ROAR_Sim.carla_client.util.camera_manager.CameraManager.render","text":"Source code in carla_client/util/camera_manager.py def render ( self , display ): if self . surface is not None : display . blit ( self . surface , ( 0 , 0 ))","title":"render()"},{"location":"code_documentations/ROAR_Sim/camera/#ROAR_Sim.carla_client.util.camera_manager.CameraManager.set_sensor","text":"Source code in carla_client/util/camera_manager.py def set_sensor ( self , index , notify = True , force_respawn = False ): index = index % len ( self . sensors ) needs_respawn = ( True if self . index is None else ( force_respawn or ( self . sensors [ index ][ 2 ] != self . sensors [ self . index ][ 2 ]) ) ) if needs_respawn : if self . sensor is not None : self . sensor . destroy () self . surface = None self . sensor = self . _parent . get_world () . spawn_actor ( self . sensors [ index ][ - 1 ], self . _camera_transforms [ self . transform_index ][ 0 ], attach_to = self . _parent , attachment_type = self . _camera_transforms [ self . transform_index ][ 1 ], ) # We need to pass the lambda a weak reference to self to avoid # circular reference. weak_self = weakref . ref ( self ) self . sensor . listen ( lambda image : CameraManager . _parse_image ( weak_self , image ) ) if notify : self . hud . notification ( self . sensors [ index ][ 2 ]) self . index = index","title":"set_sensor()"},{"location":"code_documentations/ROAR_Sim/camera/#ROAR_Sim.carla_client.util.camera_manager.CameraManager.toggle_camera","text":"Source code in carla_client/util/camera_manager.py def toggle_camera ( self ): self . transform_index = ( self . transform_index + 1 ) % len ( self . _camera_transforms ) self . set_sensor ( self . index , notify = False , force_respawn = True )","title":"toggle_camera()"},{"location":"code_documentations/ROAR_Sim/camera/#ROAR_Sim.carla_client.util.camera_manager.CameraManager.toggle_recording","text":"Source code in carla_client/util/camera_manager.py def toggle_recording ( self ): self . recording = not self . recording self . hud . notification ( \"Recording %s \" % ( \"On\" if self . recording else \"Off\" ))","title":"toggle_recording()"},{"location":"code_documentations/ROAR_Sim/carla_client/","text":"carla_runner \u00a4 CarlaRunner \u00a4 __init__ ( self , carla_settings , agent_settings , npc_agent_class , competition_mode = False , start_bbox = array ([ 5 , - 5 , 0 , 13 , 5 , 50 ]), lap_count = 10 ) special \u00a4 Parameters: Name Type Description Default carla_settings Configuration CarlaConfig instance required agent_settings Configuration AgentConfig instance required npc_agent_class an agent class required competition_mode [Optional] True/False False max_collision [Optional] int required start_bbox ndarray [Optional] array of [minx, miny, minz, maxx, maxy, maxz] array([ 5, -5, 0, 13, 5, 50]) lap_count [Optional] total lap count 10 Source code in carla_client/carla_runner.py def __init__ ( self , carla_settings : CarlaConfig , agent_settings : AgentConfig , npc_agent_class , competition_mode = False , start_bbox : np . ndarray = np . array ([ 5 , - 5 , 0 , 13 , 5 , 50 ]), lap_count = 10 ): \"\"\" Args: carla_settings: CarlaConfig instance agent_settings: AgentConfig instance npc_agent_class: an agent class competition_mode: [Optional] True/False max_collision: [Optional] int start_bbox: [Optional] array of [minx, miny, minz, maxx, maxy, maxz] lap_count: [Optional] total lap count \"\"\" self . carla_settings = carla_settings self . agent_settings = agent_settings self . carla_bridge = CarlaBridge () self . npc_agent_class = npc_agent_class self . world = None self . client = None self . controller = None self . display = None self . agent = None self . npc_agents : Dict [ npc_agent_class , Any ] = {} self . agent_collision_counter = 0 self . competition_mode = competition_mode self . start_bbox = start_bbox self . lap_count = lap_count self . completed_lap_count = 0 self . start_simulation_time : Optional [ float ] = None self . start_vehicle_position : Optional [ np . array ] = None self . end_simulation_time : Optional [ float ] = None self . end_vehicle_position : Optional [ np . array ] = None self . logger = logging . getLogger ( __name__ ) self . timestep_counter = 0 check_version ( self , client ) \u00a4 Source code in carla_client/carla_runner.py def check_version ( self , client ): return ( \"0.9.9\" in client . get_server_version ()) == ( \"0.9.9\" in client . get_client_version ()) convert_data ( self ) \u00a4 Convert data from source to agent Returns: Type Description Tuple[ROAR.utilities_module.data_structures_models.SensorsData, ROAR.utilities_module.vehicle_models.Vehicle] sensors_data: sensor data for agent new_vehicle: the current player's vehicle state Source code in carla_client/carla_runner.py def convert_data ( self ) -> Tuple [ SensorsData , Vehicle ]: \"\"\" Convert data from source to agent Returns: sensors_data: sensor data for agent new_vehicle: the current player's vehicle state \"\"\" sensor_data : SensorsData = \\ self . carla_bridge . convert_sensor_data_from_source_to_agent ( { \"front_rgb\" : None if self . world . front_rgb_sensor_data is None else self . world . front_rgb_sensor_data , \"rear_rgb\" : None if self . world . rear_rgb_sensor_data is None else self . world . rear_rgb_sensor_data , \"front_depth\" : None if self . world . front_depth_sensor_data is None else self . world . front_depth_sensor_data , \"imu\" : self . world . imu_sensor } ) new_vehicle = self . carla_bridge . convert_vehicle_from_source_to_agent ( self . world . player ) return sensor_data , new_vehicle execute_npcs_step ( self ) \u00a4 Source code in carla_client/carla_runner.py def execute_npcs_step ( self ): # TODO this can be parallelized try : for agent , actor in self . npc_agents . items (): new_vehicle = self . carla_bridge . convert_vehicle_from_source_to_agent ( actor ) curr_control : VehicleControl = agent . run_step ( sensors_data = SensorsData (), vehicle = new_vehicle ) carla_control = self . carla_bridge . convert_control_from_agent_to_source ( curr_control ) actor . apply_control ( carla_control ) except Exception as e : self . logger . error ( f \"Failed to execute step for NPC. \" f \"Error: { e } \" ) get_num_collision ( self ) \u00a4 Source code in carla_client/carla_runner.py def get_num_collision ( self ): collision_sensor : CollisionSensor = self . world . collision_sensor return len ( collision_sensor . history ) is_within_start_finish_bbox ( self , curr_pos ) \u00a4 Source code in carla_client/carla_runner.py def is_within_start_finish_bbox ( self , curr_pos : np . ndarray ) -> bool : min_bounding_box = self . start_bbox [: 3 ] max_bounding_box = self . start_bbox [ 3 :] return all ( np . logical_and ( min_bounding_box < curr_pos , curr_pos < max_bounding_box )) on_finish ( self ) \u00a4 Source code in carla_client/carla_runner.py def on_finish ( self ): self . logger . debug ( \"Ending Game\" ) if self . agent is not None : self . end_vehicle_position = self . agent . vehicle . transform . location . to_array () else : self . end_vehicle_position = self . start_vehicle_position if self . world is not None : self . end_simulation_time = self . world . hud . simulation_time self . world . destroy () self . logger . debug ( \"All actors are destroyed\" ) try : pygame . quit () except Exception as e : self . logger . debug ( f \"Cannot quit pygame normally, force quitting. Error: { e } \" ) self . logger . debug ( \"Game ended\" ) restart_on_lap ( self , agent , use_manual_control , starting_lap_count ) \u00a4 Source code in carla_client/carla_runner.py def restart_on_lap ( self , agent , use_manual_control : bool , starting_lap_count : int ): self . logger . info ( f \"Restarting on Lap { starting_lap_count } \" ) self . on_finish () self . set_carla_world () self . start_game_loop ( agent = agent , use_manual_control = use_manual_control , starting_lap_count = starting_lap_count ) set_carla_world ( self ) \u00a4 Initiating the vehicle with loading messages Returns: Type Description Vehicle Vehicle Information Source code in carla_client/carla_runner.py def set_carla_world ( self ) -> Vehicle : \"\"\" Initiating the vehicle with loading messages Returns: Vehicle Information \"\"\" try : pygame . init () pygame . font . init () self . logger . debug ( f \"Connecting to { self . carla_settings . host } : \" f \" { self . carla_settings . port } \" ) self . client = carla . Client ( self . carla_settings . host , self . carla_settings . port ) if not self . check_version ( client = self . client ): self . logger . error ( f \"Version Mismatch: Client = { self . client . get_client_version () } , \" f \"Server = { self . client . get_server_version () } . \\n \" f \"HINT: Please change carla_version to either 0.9.9 or 0.9.10 \" f \"in ROAR_Sim.configurations.carla_version.txt\" ) exit ( 1 ) self . display = pygame . display . set_mode ( ( self . carla_settings . width , self . carla_settings . height ), pygame . HWSURFACE | pygame . DOUBLEBUF ) self . logger . debug ( f \"Setting HUD\" ) hud = HUD ( self . carla_settings . width , self . carla_settings . height ) self . logger . debug ( \"Setting up world\" ) self . world = World ( carla_world = self . client . get_world (), hud = hud , carla_settings = self . carla_settings , agent_settings = self . agent_settings ) if self . carla_settings . should_spawn_npcs : self . spawn_npcs () self . logger . debug ( f \"Connecting to Keyboard controls\" ) self . controller = KeyboardControl ( world = self . world , carla_setting = self . carla_settings ) self . logger . debug ( \"All settings done\" ) return self . carla_bridge . \\ convert_vehicle_from_source_to_agent ( self . world . player ) except Exception as e : self . logger . error ( f \"Unable to initiate the world due to error: { e } \" ) raise e spawn_npcs ( self ) \u00a4 Source code in carla_client/carla_runner.py def spawn_npcs ( self ): # parse npc file npc_config_file_path = Path ( self . carla_settings . npc_config_file_path ) assert npc_config_file_path . exists (), f \"NPC file path { npc_config_file_path . as_posix () } does not exist\" npc_configs = json . load ( npc_config_file_path . open ( 'r' )) npc_configs : List [ AgentConfig ] = [ AgentConfig . parse_obj ( config ) for config in npc_configs ] self . world . spawn_npcs ( npc_configs ) self . npc_agents = { self . npc_agent_class ( vehicle = actor , agent_settings = npc_config ): actor for actor , npc_config in self . world . npcs_mapping . values () } start_game_loop ( self , agent , use_manual_control = False , starting_lap_count = 0 ) \u00a4 Start running the vehicle and stop when finished running the track Source code in carla_client/carla_runner.py def start_game_loop ( self , agent , use_manual_control = False , starting_lap_count = 0 ): \"\"\"Start running the vehicle and stop when finished running the track\"\"\" self . agent = agent lap_count = starting_lap_count has_entered_bbox = False should_restart_lap = False try : self . logger . debug ( \"Initiating game\" ) self . agent . start_module_threads () clock = pygame . time . Clock () self . start_simulation_time = self . world . hud . simulation_time self . start_vehicle_position = self . agent . vehicle . transform . location . to_array () while True : # make sure the program does not run above 60 frames per second # this allow proper synchrony between server and client clock . tick_busy_loop ( 60 ) should_continue , carla_control = self . controller . parse_events ( client = self . client , world = self . world , clock = clock ) self . agent_collision_counter = self . get_num_collision () if self . competition_mode : is_currently_in_bbox = self . is_within_start_finish_bbox ( curr_pos = self . agent . vehicle . transform . location . to_array ()) if has_entered_bbox is True and is_currently_in_bbox is False : has_entered_bbox = False elif has_entered_bbox is False and is_currently_in_bbox is True : has_entered_bbox = True lap_count += 1 if lap_count > self . lap_count : break else : self . logger . info ( f \"Going onto Lap { lap_count } out of { self . lap_count } \" ) if len ( self . world . collision_sensor . history ) > 0 : should_restart_lap = True if should_restart_lap : should_continue = False # check for exiting condition if should_continue is False : break self . world . tick ( clock ) self . world . render ( display = self . display ) pygame . display . flip () sensor_data , new_vehicle = self . convert_data () if self . carla_settings . save_semantic_segmentation and self . world . semantic_segmentation_sensor_data : Thread ( target = lambda : self . world . semantic_segmentation_sensor_data . save_to_disk (( Path ( \"./data/output\" ) / \"ss\" / f \"frame_ { self . agent . time_counter } .png\" ) . as_posix (), cc . CityScapesPalette ), args = ()) . start () if self . carla_settings . should_spawn_npcs : self . execute_npcs_step () if self . agent_settings . enable_autopilot : if self . agent is None : raise Exception ( \"In autopilot mode, but no agent is defined.\" ) agent_control = self . agent . run_step ( vehicle = new_vehicle , sensors_data = sensor_data ) if not use_manual_control : carla_control = self . carla_bridge . \\ convert_control_from_agent_to_source ( agent_control ) self . world . player . apply_control ( carla_control ) self . timestep_counter += 1 self . completed_lap_count = lap_count - 1 except Exception as e : self . logger . error ( f \"Error happened, exiting safely. Error: { e } \" ) finally : if self . competition_mode : if should_restart_lap : self . restart_on_lap ( agent = agent , use_manual_control = use_manual_control , starting_lap_count = lap_count - 1 ) else : self . on_finish ()","title":"Carla Runner"},{"location":"code_documentations/ROAR_Sim/carla_client/#ROAR_Sim.carla_client.carla_runner","text":"","title":"carla_runner"},{"location":"code_documentations/ROAR_Sim/carla_client/#ROAR_Sim.carla_client.carla_runner.CarlaRunner","text":"","title":"CarlaRunner"},{"location":"code_documentations/ROAR_Sim/carla_client/#ROAR_Sim.carla_client.carla_runner.CarlaRunner.__init__","text":"Parameters: Name Type Description Default carla_settings Configuration CarlaConfig instance required agent_settings Configuration AgentConfig instance required npc_agent_class an agent class required competition_mode [Optional] True/False False max_collision [Optional] int required start_bbox ndarray [Optional] array of [minx, miny, minz, maxx, maxy, maxz] array([ 5, -5, 0, 13, 5, 50]) lap_count [Optional] total lap count 10 Source code in carla_client/carla_runner.py def __init__ ( self , carla_settings : CarlaConfig , agent_settings : AgentConfig , npc_agent_class , competition_mode = False , start_bbox : np . ndarray = np . array ([ 5 , - 5 , 0 , 13 , 5 , 50 ]), lap_count = 10 ): \"\"\" Args: carla_settings: CarlaConfig instance agent_settings: AgentConfig instance npc_agent_class: an agent class competition_mode: [Optional] True/False max_collision: [Optional] int start_bbox: [Optional] array of [minx, miny, minz, maxx, maxy, maxz] lap_count: [Optional] total lap count \"\"\" self . carla_settings = carla_settings self . agent_settings = agent_settings self . carla_bridge = CarlaBridge () self . npc_agent_class = npc_agent_class self . world = None self . client = None self . controller = None self . display = None self . agent = None self . npc_agents : Dict [ npc_agent_class , Any ] = {} self . agent_collision_counter = 0 self . competition_mode = competition_mode self . start_bbox = start_bbox self . lap_count = lap_count self . completed_lap_count = 0 self . start_simulation_time : Optional [ float ] = None self . start_vehicle_position : Optional [ np . array ] = None self . end_simulation_time : Optional [ float ] = None self . end_vehicle_position : Optional [ np . array ] = None self . logger = logging . getLogger ( __name__ ) self . timestep_counter = 0","title":"__init__()"},{"location":"code_documentations/ROAR_Sim/carla_client/#ROAR_Sim.carla_client.carla_runner.CarlaRunner.check_version","text":"Source code in carla_client/carla_runner.py def check_version ( self , client ): return ( \"0.9.9\" in client . get_server_version ()) == ( \"0.9.9\" in client . get_client_version ())","title":"check_version()"},{"location":"code_documentations/ROAR_Sim/carla_client/#ROAR_Sim.carla_client.carla_runner.CarlaRunner.convert_data","text":"Convert data from source to agent Returns: Type Description Tuple[ROAR.utilities_module.data_structures_models.SensorsData, ROAR.utilities_module.vehicle_models.Vehicle] sensors_data: sensor data for agent new_vehicle: the current player's vehicle state Source code in carla_client/carla_runner.py def convert_data ( self ) -> Tuple [ SensorsData , Vehicle ]: \"\"\" Convert data from source to agent Returns: sensors_data: sensor data for agent new_vehicle: the current player's vehicle state \"\"\" sensor_data : SensorsData = \\ self . carla_bridge . convert_sensor_data_from_source_to_agent ( { \"front_rgb\" : None if self . world . front_rgb_sensor_data is None else self . world . front_rgb_sensor_data , \"rear_rgb\" : None if self . world . rear_rgb_sensor_data is None else self . world . rear_rgb_sensor_data , \"front_depth\" : None if self . world . front_depth_sensor_data is None else self . world . front_depth_sensor_data , \"imu\" : self . world . imu_sensor } ) new_vehicle = self . carla_bridge . convert_vehicle_from_source_to_agent ( self . world . player ) return sensor_data , new_vehicle","title":"convert_data()"},{"location":"code_documentations/ROAR_Sim/carla_client/#ROAR_Sim.carla_client.carla_runner.CarlaRunner.execute_npcs_step","text":"Source code in carla_client/carla_runner.py def execute_npcs_step ( self ): # TODO this can be parallelized try : for agent , actor in self . npc_agents . items (): new_vehicle = self . carla_bridge . convert_vehicle_from_source_to_agent ( actor ) curr_control : VehicleControl = agent . run_step ( sensors_data = SensorsData (), vehicle = new_vehicle ) carla_control = self . carla_bridge . convert_control_from_agent_to_source ( curr_control ) actor . apply_control ( carla_control ) except Exception as e : self . logger . error ( f \"Failed to execute step for NPC. \" f \"Error: { e } \" )","title":"execute_npcs_step()"},{"location":"code_documentations/ROAR_Sim/carla_client/#ROAR_Sim.carla_client.carla_runner.CarlaRunner.get_num_collision","text":"Source code in carla_client/carla_runner.py def get_num_collision ( self ): collision_sensor : CollisionSensor = self . world . collision_sensor return len ( collision_sensor . history )","title":"get_num_collision()"},{"location":"code_documentations/ROAR_Sim/carla_client/#ROAR_Sim.carla_client.carla_runner.CarlaRunner.is_within_start_finish_bbox","text":"Source code in carla_client/carla_runner.py def is_within_start_finish_bbox ( self , curr_pos : np . ndarray ) -> bool : min_bounding_box = self . start_bbox [: 3 ] max_bounding_box = self . start_bbox [ 3 :] return all ( np . logical_and ( min_bounding_box < curr_pos , curr_pos < max_bounding_box ))","title":"is_within_start_finish_bbox()"},{"location":"code_documentations/ROAR_Sim/carla_client/#ROAR_Sim.carla_client.carla_runner.CarlaRunner.on_finish","text":"Source code in carla_client/carla_runner.py def on_finish ( self ): self . logger . debug ( \"Ending Game\" ) if self . agent is not None : self . end_vehicle_position = self . agent . vehicle . transform . location . to_array () else : self . end_vehicle_position = self . start_vehicle_position if self . world is not None : self . end_simulation_time = self . world . hud . simulation_time self . world . destroy () self . logger . debug ( \"All actors are destroyed\" ) try : pygame . quit () except Exception as e : self . logger . debug ( f \"Cannot quit pygame normally, force quitting. Error: { e } \" ) self . logger . debug ( \"Game ended\" )","title":"on_finish()"},{"location":"code_documentations/ROAR_Sim/carla_client/#ROAR_Sim.carla_client.carla_runner.CarlaRunner.restart_on_lap","text":"Source code in carla_client/carla_runner.py def restart_on_lap ( self , agent , use_manual_control : bool , starting_lap_count : int ): self . logger . info ( f \"Restarting on Lap { starting_lap_count } \" ) self . on_finish () self . set_carla_world () self . start_game_loop ( agent = agent , use_manual_control = use_manual_control , starting_lap_count = starting_lap_count )","title":"restart_on_lap()"},{"location":"code_documentations/ROAR_Sim/carla_client/#ROAR_Sim.carla_client.carla_runner.CarlaRunner.set_carla_world","text":"Initiating the vehicle with loading messages Returns: Type Description Vehicle Vehicle Information Source code in carla_client/carla_runner.py def set_carla_world ( self ) -> Vehicle : \"\"\" Initiating the vehicle with loading messages Returns: Vehicle Information \"\"\" try : pygame . init () pygame . font . init () self . logger . debug ( f \"Connecting to { self . carla_settings . host } : \" f \" { self . carla_settings . port } \" ) self . client = carla . Client ( self . carla_settings . host , self . carla_settings . port ) if not self . check_version ( client = self . client ): self . logger . error ( f \"Version Mismatch: Client = { self . client . get_client_version () } , \" f \"Server = { self . client . get_server_version () } . \\n \" f \"HINT: Please change carla_version to either 0.9.9 or 0.9.10 \" f \"in ROAR_Sim.configurations.carla_version.txt\" ) exit ( 1 ) self . display = pygame . display . set_mode ( ( self . carla_settings . width , self . carla_settings . height ), pygame . HWSURFACE | pygame . DOUBLEBUF ) self . logger . debug ( f \"Setting HUD\" ) hud = HUD ( self . carla_settings . width , self . carla_settings . height ) self . logger . debug ( \"Setting up world\" ) self . world = World ( carla_world = self . client . get_world (), hud = hud , carla_settings = self . carla_settings , agent_settings = self . agent_settings ) if self . carla_settings . should_spawn_npcs : self . spawn_npcs () self . logger . debug ( f \"Connecting to Keyboard controls\" ) self . controller = KeyboardControl ( world = self . world , carla_setting = self . carla_settings ) self . logger . debug ( \"All settings done\" ) return self . carla_bridge . \\ convert_vehicle_from_source_to_agent ( self . world . player ) except Exception as e : self . logger . error ( f \"Unable to initiate the world due to error: { e } \" ) raise e","title":"set_carla_world()"},{"location":"code_documentations/ROAR_Sim/carla_client/#ROAR_Sim.carla_client.carla_runner.CarlaRunner.spawn_npcs","text":"Source code in carla_client/carla_runner.py def spawn_npcs ( self ): # parse npc file npc_config_file_path = Path ( self . carla_settings . npc_config_file_path ) assert npc_config_file_path . exists (), f \"NPC file path { npc_config_file_path . as_posix () } does not exist\" npc_configs = json . load ( npc_config_file_path . open ( 'r' )) npc_configs : List [ AgentConfig ] = [ AgentConfig . parse_obj ( config ) for config in npc_configs ] self . world . spawn_npcs ( npc_configs ) self . npc_agents = { self . npc_agent_class ( vehicle = actor , agent_settings = npc_config ): actor for actor , npc_config in self . world . npcs_mapping . values () }","title":"spawn_npcs()"},{"location":"code_documentations/ROAR_Sim/carla_client/#ROAR_Sim.carla_client.carla_runner.CarlaRunner.start_game_loop","text":"Start running the vehicle and stop when finished running the track Source code in carla_client/carla_runner.py def start_game_loop ( self , agent , use_manual_control = False , starting_lap_count = 0 ): \"\"\"Start running the vehicle and stop when finished running the track\"\"\" self . agent = agent lap_count = starting_lap_count has_entered_bbox = False should_restart_lap = False try : self . logger . debug ( \"Initiating game\" ) self . agent . start_module_threads () clock = pygame . time . Clock () self . start_simulation_time = self . world . hud . simulation_time self . start_vehicle_position = self . agent . vehicle . transform . location . to_array () while True : # make sure the program does not run above 60 frames per second # this allow proper synchrony between server and client clock . tick_busy_loop ( 60 ) should_continue , carla_control = self . controller . parse_events ( client = self . client , world = self . world , clock = clock ) self . agent_collision_counter = self . get_num_collision () if self . competition_mode : is_currently_in_bbox = self . is_within_start_finish_bbox ( curr_pos = self . agent . vehicle . transform . location . to_array ()) if has_entered_bbox is True and is_currently_in_bbox is False : has_entered_bbox = False elif has_entered_bbox is False and is_currently_in_bbox is True : has_entered_bbox = True lap_count += 1 if lap_count > self . lap_count : break else : self . logger . info ( f \"Going onto Lap { lap_count } out of { self . lap_count } \" ) if len ( self . world . collision_sensor . history ) > 0 : should_restart_lap = True if should_restart_lap : should_continue = False # check for exiting condition if should_continue is False : break self . world . tick ( clock ) self . world . render ( display = self . display ) pygame . display . flip () sensor_data , new_vehicle = self . convert_data () if self . carla_settings . save_semantic_segmentation and self . world . semantic_segmentation_sensor_data : Thread ( target = lambda : self . world . semantic_segmentation_sensor_data . save_to_disk (( Path ( \"./data/output\" ) / \"ss\" / f \"frame_ { self . agent . time_counter } .png\" ) . as_posix (), cc . CityScapesPalette ), args = ()) . start () if self . carla_settings . should_spawn_npcs : self . execute_npcs_step () if self . agent_settings . enable_autopilot : if self . agent is None : raise Exception ( \"In autopilot mode, but no agent is defined.\" ) agent_control = self . agent . run_step ( vehicle = new_vehicle , sensors_data = sensor_data ) if not use_manual_control : carla_control = self . carla_bridge . \\ convert_control_from_agent_to_source ( agent_control ) self . world . player . apply_control ( carla_control ) self . timestep_counter += 1 self . completed_lap_count = lap_count - 1 except Exception as e : self . logger . error ( f \"Error happened, exiting safely. Error: { e } \" ) finally : if self . competition_mode : if should_restart_lap : self . restart_on_lap ( agent = agent , use_manual_control = use_manual_control , starting_lap_count = lap_count - 1 ) else : self . on_finish ()","title":"start_game_loop()"},{"location":"code_documentations/ROAR_Sim/ccu/","text":"::: ROAR_Sim.carla_client.util","title":"Ccu"},{"location":"code_documentations/ROAR_Sim/conf/","text":"Configuration pydantic-model \u00a4 car_color : CarlaCarColor pydantic-field \u00a4 Your Vehicle Color carla_vehicle_blueprint_filter : str pydantic-field \u00a4 For more detail, see https://carla.readthedocs.io/en/0.9.9/bp_library/ carla_version : str pydantic-field \u00a4 carla_weather : CarlaWeather pydantic-field \u00a4 Weather Setting fixed_delta_seconds : float pydantic-field \u00a4 Note that for us, this will ONLY take effect when you are on sync mode. https://carla.readthedocs.io/en/0.9.9/adv_synchrony_timestep/#client-server-synchrony gamma : float pydantic-field \u00a4 Gamma Correction of the camera height : int pydantic-field \u00a4 host : str pydantic-field \u00a4 The IP Address of the Carla Server no_rendering_mode : bool pydantic-field \u00a4 https://carla.readthedocs.io/en/0.9.9/adv_rendering_options/ npc_config_file_path : str pydantic-field \u00a4 port : int pydantic-field \u00a4 The Port number of the Carla Server print_keyboard_hint : bool pydantic-field \u00a4 role_name : str pydantic-field \u00a4 Your name in Carla, can be used to correctly identify you later save_semantic_segmentation : bool pydantic-field \u00a4 should_spawn_npcs : bool pydantic-field \u00a4 synchronous_mode : bool pydantic-field \u00a4 https://carla.readthedocs.io/en/0.9.9/adv_synchrony_timestep/#client-server-synchrony timeout : float pydantic-field \u00a4 width : int pydantic-field \u00a4 __config__ \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 import_carla () \u00a4 Source code in configurations/configuration.py def import_carla (): from pathlib import Path import os , sys # clear path s.t. path contains no carla sys . path = [ p for p in sys . path if \"carla\" not in p ] if \"carla\" in sys . modules : del sys . modules [ \"carla\" ] roar_sim_folder_path = Path ( os . getcwd ()) / \"ROAR_Sim\" if roar_sim_folder_path . exists () is False : roar_sim_folder_path = Path ( os . getcwd ()) . parent / \"ROAR_Sim\" if roar_sim_folder_path . exists () is False : roar_sim_folder_path = Path ( os . getcwd ()) . parent . parent / \"ROAR_Sim\" carla_version_file_path = roar_sim_folder_path / \"configurations\" / \"carla_version.txt\" carla_version = ( carla_version_file_path . open ( 'r' ) . readline ()) . strip () carla_client_folder_path = roar_sim_folder_path / \"carla_client\" if sys . platform == 'darwin' : assert False , \"MacOS is currently not supported\" carla_client_egg_file_name = f 'carla- { carla_version } -py3.7-win-amd64.egg' if \\ sys . platform == \"win32\" else f \"carla- { carla_version } -py3.6-linux-x86_64.egg\" carla_client_egg_file_path = carla_client_folder_path / carla_client_egg_file_name if not carla_client_egg_file_path . is_file (): raise FileNotFoundError ( \"Please make sure carla client distribution is installed under the \" \"carla_client directory\" ) sys . path . append ( carla_client_egg_file_path . as_posix ()) import carla","title":"Configurations"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration","text":"","title":"Configuration"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.car_color","text":"Your Vehicle Color","title":"car_color"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.carla_vehicle_blueprint_filter","text":"For more detail, see https://carla.readthedocs.io/en/0.9.9/bp_library/","title":"carla_vehicle_blueprint_filter"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.carla_version","text":"","title":"carla_version"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.carla_weather","text":"Weather Setting","title":"carla_weather"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.fixed_delta_seconds","text":"Note that for us, this will ONLY take effect when you are on sync mode. https://carla.readthedocs.io/en/0.9.9/adv_synchrony_timestep/#client-server-synchrony","title":"fixed_delta_seconds"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.gamma","text":"Gamma Correction of the camera","title":"gamma"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.height","text":"","title":"height"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.host","text":"The IP Address of the Carla Server","title":"host"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.no_rendering_mode","text":"https://carla.readthedocs.io/en/0.9.9/adv_rendering_options/","title":"no_rendering_mode"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.npc_config_file_path","text":"","title":"npc_config_file_path"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.port","text":"The Port number of the Carla Server","title":"port"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.print_keyboard_hint","text":"","title":"print_keyboard_hint"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.role_name","text":"Your name in Carla, can be used to correctly identify you later","title":"role_name"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.save_semantic_segmentation","text":"","title":"save_semantic_segmentation"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.should_spawn_npcs","text":"","title":"should_spawn_npcs"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.synchronous_mode","text":"https://carla.readthedocs.io/en/0.9.9/adv_synchrony_timestep/#client-server-synchrony","title":"synchronous_mode"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.timeout","text":"","title":"timeout"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.width","text":"","title":"width"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.Configuration.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR_Sim/conf/#ROAR_Sim.configurations.configuration.import_carla","text":"Source code in configurations/configuration.py def import_carla (): from pathlib import Path import os , sys # clear path s.t. path contains no carla sys . path = [ p for p in sys . path if \"carla\" not in p ] if \"carla\" in sys . modules : del sys . modules [ \"carla\" ] roar_sim_folder_path = Path ( os . getcwd ()) / \"ROAR_Sim\" if roar_sim_folder_path . exists () is False : roar_sim_folder_path = Path ( os . getcwd ()) . parent / \"ROAR_Sim\" if roar_sim_folder_path . exists () is False : roar_sim_folder_path = Path ( os . getcwd ()) . parent . parent / \"ROAR_Sim\" carla_version_file_path = roar_sim_folder_path / \"configurations\" / \"carla_version.txt\" carla_version = ( carla_version_file_path . open ( 'r' ) . readline ()) . strip () carla_client_folder_path = roar_sim_folder_path / \"carla_client\" if sys . platform == 'darwin' : assert False , \"MacOS is currently not supported\" carla_client_egg_file_name = f 'carla- { carla_version } -py3.7-win-amd64.egg' if \\ sys . platform == \"win32\" else f \"carla- { carla_version } -py3.6-linux-x86_64.egg\" carla_client_egg_file_path = carla_client_folder_path / carla_client_egg_file_name if not carla_client_egg_file_path . is_file (): raise FileNotFoundError ( \"Please make sure carla client distribution is installed under the \" \"carla_client directory\" ) sys . path . append ( carla_client_egg_file_path . as_posix ()) import carla","title":"import_carla()"},{"location":"code_documentations/ROAR_Sim/hud/","text":"FadingText \u00a4 __init__ ( self , font , dim , pos ) special \u00a4 Source code in carla_client/util/hud.py def __init__ ( self , font , dim , pos ): self . font = font self . dim = dim self . pos = pos self . seconds_left = 0 self . surface = pygame . Surface ( self . dim ) render ( self , display ) \u00a4 Source code in carla_client/util/hud.py def render ( self , display ): display . blit ( self . surface , self . pos ) set_text ( self , text , color = ( 255 , 255 , 255 ), seconds = 2.0 ) \u00a4 Source code in carla_client/util/hud.py def set_text ( self , text , color = ( 255 , 255 , 255 ), seconds = 2.0 ): text_texture = self . font . render ( text , True , color ) self . surface = pygame . Surface ( self . dim ) self . seconds_left = seconds self . surface . fill (( 0 , 0 , 0 , 0 )) self . surface . blit ( text_texture , ( 10 , 11 )) tick ( self , _ , clock ) \u00a4 Source code in carla_client/util/hud.py def tick ( self , _ , clock ): delta_seconds = 1e-3 * clock . get_time () self . seconds_left = max ( 0.0 , self . seconds_left - delta_seconds ) self . surface . set_alpha ( 500.0 * self . seconds_left ) HUD \u00a4 __init__ ( self , width , height ) special \u00a4 Source code in carla_client/util/hud.py def __init__ ( self , width , height ): self . dim = ( width , height ) font = pygame . font . Font ( pygame . font . get_default_font (), 20 ) font_name = \"courier\" if os . name == \"nt\" else \"mono\" fonts = [ x for x in pygame . font . get_fonts () if font_name in x ] default_font = \"ubuntumono\" mono = default_font if default_font in fonts else fonts [ 0 ] mono = pygame . font . match_font ( mono ) self . _font_mono = pygame . font . Font ( mono , 12 if os . name == \"nt\" else 14 ) self . _notifications = FadingText ( font , ( width , 40 ), ( 0 , height - 40 )) self . server_fps = 0 self . frame = 0 self . simulation_time = 0 self . _show_info = True self . _info_text = [] self . _server_clock = pygame . time . Clock () error ( self , text ) \u00a4 Source code in carla_client/util/hud.py def error ( self , text ): self . _notifications . set_text ( \"Error: %s \" % text , ( 255 , 0 , 0 )) notification ( self , text , seconds = 2.0 ) \u00a4 Source code in carla_client/util/hud.py def notification ( self , text , seconds = 2.0 ): self . _notifications . set_text ( text , seconds = seconds ) on_world_tick ( self , timestamp ) \u00a4 Source code in carla_client/util/hud.py def on_world_tick ( self , timestamp ): self . _server_clock . tick () self . server_fps = self . _server_clock . get_fps () self . frame = timestamp . frame self . simulation_time = timestamp . elapsed_seconds render ( self , display ) \u00a4 Source code in carla_client/util/hud.py def render ( self , display ): if self . _show_info : info_surface = pygame . Surface (( 220 , self . dim [ 1 ])) info_surface . set_alpha ( 100 ) display . blit ( info_surface , ( 0 , 0 )) v_offset = 4 bar_h_offset = 100 bar_width = 106 for item in self . _info_text : if v_offset + 18 > self . dim [ 1 ]: break if isinstance ( item , list ): if len ( item ) > 1 : points = [ ( x + 8 , v_offset + 8 + ( 1.0 - y ) * 30 ) for x , y in enumerate ( item ) ] pygame . draw . lines ( display , ( 255 , 136 , 0 ), False , points , 2 ) item = None v_offset += 18 elif isinstance ( item , tuple ): if isinstance ( item [ 1 ], bool ): rect = pygame . Rect (( bar_h_offset , v_offset + 8 ), ( 6 , 6 )) pygame . draw . rect ( display , ( 255 , 255 , 255 ), rect , 0 if item [ 1 ] else 1 ) else : rect_border = pygame . Rect ( ( bar_h_offset , v_offset + 8 ), ( bar_width , 6 ) ) pygame . draw . rect ( display , ( 255 , 255 , 255 ), rect_border , 1 ) f = ( item [ 1 ] - item [ 2 ]) / ( item [ 3 ] - item [ 2 ]) if item [ 2 ] < 0.0 : rect = pygame . Rect ( ( bar_h_offset + f * ( bar_width - 6 ), v_offset + 8 ), ( 6 , 6 ), ) else : rect = pygame . Rect ( ( bar_h_offset , v_offset + 8 ), ( f * bar_width , 6 ) ) pygame . draw . rect ( display , ( 255 , 255 , 255 ), rect ) item = item [ 0 ] if item : # At this point has to be a str. surface = self . _font_mono . render ( item , True , ( 255 , 255 , 255 )) display . blit ( surface , ( 8 , v_offset )) v_offset += 18 self . _notifications . render ( display ) tick ( self , world , clock ) \u00a4 Source code in carla_client/util/hud.py def tick ( self , world , clock ): self . _notifications . tick ( world , clock ) if not self . _show_info : return t = world . player . get_transform () v = world . player . get_velocity () c = world . player . get_control () compass = world . imu_sensor . compass heading = \"N\" if compass > 270.5 or compass < 89.5 else \"\" heading += \"S\" if 90.5 < compass < 269.5 else \"\" heading += \"E\" if 0.5 < compass < 179.5 else \"\" heading += \"W\" if 180.5 < compass < 359.5 else \"\" colhist = world . collision_sensor . get_collision_history () collision = [ colhist [ x + self . frame - 200 ] for x in range ( 0 , 200 )] max_col = max ( 1.0 , max ( collision )) collision = [ x / max_col for x in collision ] vehicles = world . carla_world . get_actors () . filter ( \"vehicle.*\" ) self . _info_text = [ \"Server: % 16.0f FPS\" % self . server_fps , \"Client: % 16.0f FPS\" % clock . get_fps (), \"\" , \"Vehicle: % 20s \" % get_actor_display_name ( world . player , truncate = 20 ), \"Map: % 20s \" % world . map . name , \"Simulation time: % 12s \" % datetime . timedelta ( seconds = int ( self . simulation_time )), \"\" , \"Speed: % 15.0f km/h\" % ( 3.6 * math . sqrt ( v . x ** 2 + v . y ** 2 + v . z ** 2 )), \"Compass: % 17.0f \\N{DEGREE SIGN} % 2s \" % ( compass , heading ), # \"Accelero: (%5.1f,%5.1f,%5.1f)\" % (world.imu_sensor.accelerometer), # \"Gyroscop: (%5.1f,%5.1f,%5.1f)\" % (world.imu_sensor.gyroscope), \"Location: % 20s \" % ( \"( % 5.1f , % 5.1f )\" % ( t . location . x , t . location . y )), \"GNSS: % 24s \" % ( \"( % 2.6f , % 3.6f )\" % ( world . gnss_sensor . lat , world . gnss_sensor . lon )), \"Height: % 18.0f m\" % t . location . z , \"\" , ] if isinstance ( c , carla . VehicleControl ): self . _info_text += [ ( \"Throttle:\" , c . throttle , 0.0 , 1.0 ), ( \"Steer:\" , c . steer , - 1.0 , 1.0 ), ( \"Brake:\" , c . brake , 0.0 , 1.0 ), ( \"Reverse:\" , c . reverse ), ( \"Hand brake:\" , c . hand_brake ), ( \"Manual:\" , c . manual_gear_shift ), \"Gear: %s \" % { - 1 : \"R\" , 0 : \"N\" } . get ( c . gear , c . gear ), ] elif isinstance ( c , carla . WalkerControl ): self . _info_text += [( \"Speed:\" , c . speed , 0.0 , 5.556 ), ( \"Jump:\" , c . jump )] self . _info_text += [ \"\" , \"Collision:\" , collision , \"\" , \"Number of vehicles: % 8d \" % len ( vehicles ), ] if len ( vehicles ) > 1 : self . _info_text += [ \"Nearby vehicles:\" ] distance = lambda l : math . sqrt ( ( l . x - t . location . x ) ** 2 + ( l . y - t . location . y ) ** 2 + ( l . z - t . location . z ) ** 2 ) vehicles = [ ( distance ( x . get_location ()), x ) for x in vehicles if x . id != world . player . id ] for d , vehicle in sorted ( vehicles ): if d > 200.0 : break vehicle_type = get_actor_display_name ( vehicle , truncate = 22 ) self . _info_text . append ( \" % 4d m %s \" % ( d , vehicle_type )) toggle_info ( self ) \u00a4 Source code in carla_client/util/hud.py def toggle_info ( self ): self . _show_info = not self . _show_info","title":"Hud"},{"location":"code_documentations/ROAR_Sim/hud/#ROAR_Sim.carla_client.util.hud.FadingText","text":"","title":"FadingText"},{"location":"code_documentations/ROAR_Sim/hud/#ROAR_Sim.carla_client.util.hud.FadingText.__init__","text":"Source code in carla_client/util/hud.py def __init__ ( self , font , dim , pos ): self . font = font self . dim = dim self . pos = pos self . seconds_left = 0 self . surface = pygame . Surface ( self . dim )","title":"__init__()"},{"location":"code_documentations/ROAR_Sim/hud/#ROAR_Sim.carla_client.util.hud.FadingText.render","text":"Source code in carla_client/util/hud.py def render ( self , display ): display . blit ( self . surface , self . pos )","title":"render()"},{"location":"code_documentations/ROAR_Sim/hud/#ROAR_Sim.carla_client.util.hud.FadingText.set_text","text":"Source code in carla_client/util/hud.py def set_text ( self , text , color = ( 255 , 255 , 255 ), seconds = 2.0 ): text_texture = self . font . render ( text , True , color ) self . surface = pygame . Surface ( self . dim ) self . seconds_left = seconds self . surface . fill (( 0 , 0 , 0 , 0 )) self . surface . blit ( text_texture , ( 10 , 11 ))","title":"set_text()"},{"location":"code_documentations/ROAR_Sim/hud/#ROAR_Sim.carla_client.util.hud.FadingText.tick","text":"Source code in carla_client/util/hud.py def tick ( self , _ , clock ): delta_seconds = 1e-3 * clock . get_time () self . seconds_left = max ( 0.0 , self . seconds_left - delta_seconds ) self . surface . set_alpha ( 500.0 * self . seconds_left )","title":"tick()"},{"location":"code_documentations/ROAR_Sim/hud/#ROAR_Sim.carla_client.util.hud.HUD","text":"","title":"HUD"},{"location":"code_documentations/ROAR_Sim/hud/#ROAR_Sim.carla_client.util.hud.HUD.__init__","text":"Source code in carla_client/util/hud.py def __init__ ( self , width , height ): self . dim = ( width , height ) font = pygame . font . Font ( pygame . font . get_default_font (), 20 ) font_name = \"courier\" if os . name == \"nt\" else \"mono\" fonts = [ x for x in pygame . font . get_fonts () if font_name in x ] default_font = \"ubuntumono\" mono = default_font if default_font in fonts else fonts [ 0 ] mono = pygame . font . match_font ( mono ) self . _font_mono = pygame . font . Font ( mono , 12 if os . name == \"nt\" else 14 ) self . _notifications = FadingText ( font , ( width , 40 ), ( 0 , height - 40 )) self . server_fps = 0 self . frame = 0 self . simulation_time = 0 self . _show_info = True self . _info_text = [] self . _server_clock = pygame . time . Clock ()","title":"__init__()"},{"location":"code_documentations/ROAR_Sim/hud/#ROAR_Sim.carla_client.util.hud.HUD.error","text":"Source code in carla_client/util/hud.py def error ( self , text ): self . _notifications . set_text ( \"Error: %s \" % text , ( 255 , 0 , 0 ))","title":"error()"},{"location":"code_documentations/ROAR_Sim/hud/#ROAR_Sim.carla_client.util.hud.HUD.notification","text":"Source code in carla_client/util/hud.py def notification ( self , text , seconds = 2.0 ): self . _notifications . set_text ( text , seconds = seconds )","title":"notification()"},{"location":"code_documentations/ROAR_Sim/hud/#ROAR_Sim.carla_client.util.hud.HUD.on_world_tick","text":"Source code in carla_client/util/hud.py def on_world_tick ( self , timestamp ): self . _server_clock . tick () self . server_fps = self . _server_clock . get_fps () self . frame = timestamp . frame self . simulation_time = timestamp . elapsed_seconds","title":"on_world_tick()"},{"location":"code_documentations/ROAR_Sim/hud/#ROAR_Sim.carla_client.util.hud.HUD.render","text":"Source code in carla_client/util/hud.py def render ( self , display ): if self . _show_info : info_surface = pygame . Surface (( 220 , self . dim [ 1 ])) info_surface . set_alpha ( 100 ) display . blit ( info_surface , ( 0 , 0 )) v_offset = 4 bar_h_offset = 100 bar_width = 106 for item in self . _info_text : if v_offset + 18 > self . dim [ 1 ]: break if isinstance ( item , list ): if len ( item ) > 1 : points = [ ( x + 8 , v_offset + 8 + ( 1.0 - y ) * 30 ) for x , y in enumerate ( item ) ] pygame . draw . lines ( display , ( 255 , 136 , 0 ), False , points , 2 ) item = None v_offset += 18 elif isinstance ( item , tuple ): if isinstance ( item [ 1 ], bool ): rect = pygame . Rect (( bar_h_offset , v_offset + 8 ), ( 6 , 6 )) pygame . draw . rect ( display , ( 255 , 255 , 255 ), rect , 0 if item [ 1 ] else 1 ) else : rect_border = pygame . Rect ( ( bar_h_offset , v_offset + 8 ), ( bar_width , 6 ) ) pygame . draw . rect ( display , ( 255 , 255 , 255 ), rect_border , 1 ) f = ( item [ 1 ] - item [ 2 ]) / ( item [ 3 ] - item [ 2 ]) if item [ 2 ] < 0.0 : rect = pygame . Rect ( ( bar_h_offset + f * ( bar_width - 6 ), v_offset + 8 ), ( 6 , 6 ), ) else : rect = pygame . Rect ( ( bar_h_offset , v_offset + 8 ), ( f * bar_width , 6 ) ) pygame . draw . rect ( display , ( 255 , 255 , 255 ), rect ) item = item [ 0 ] if item : # At this point has to be a str. surface = self . _font_mono . render ( item , True , ( 255 , 255 , 255 )) display . blit ( surface , ( 8 , v_offset )) v_offset += 18 self . _notifications . render ( display )","title":"render()"},{"location":"code_documentations/ROAR_Sim/hud/#ROAR_Sim.carla_client.util.hud.HUD.tick","text":"Source code in carla_client/util/hud.py def tick ( self , world , clock ): self . _notifications . tick ( world , clock ) if not self . _show_info : return t = world . player . get_transform () v = world . player . get_velocity () c = world . player . get_control () compass = world . imu_sensor . compass heading = \"N\" if compass > 270.5 or compass < 89.5 else \"\" heading += \"S\" if 90.5 < compass < 269.5 else \"\" heading += \"E\" if 0.5 < compass < 179.5 else \"\" heading += \"W\" if 180.5 < compass < 359.5 else \"\" colhist = world . collision_sensor . get_collision_history () collision = [ colhist [ x + self . frame - 200 ] for x in range ( 0 , 200 )] max_col = max ( 1.0 , max ( collision )) collision = [ x / max_col for x in collision ] vehicles = world . carla_world . get_actors () . filter ( \"vehicle.*\" ) self . _info_text = [ \"Server: % 16.0f FPS\" % self . server_fps , \"Client: % 16.0f FPS\" % clock . get_fps (), \"\" , \"Vehicle: % 20s \" % get_actor_display_name ( world . player , truncate = 20 ), \"Map: % 20s \" % world . map . name , \"Simulation time: % 12s \" % datetime . timedelta ( seconds = int ( self . simulation_time )), \"\" , \"Speed: % 15.0f km/h\" % ( 3.6 * math . sqrt ( v . x ** 2 + v . y ** 2 + v . z ** 2 )), \"Compass: % 17.0f \\N{DEGREE SIGN} % 2s \" % ( compass , heading ), # \"Accelero: (%5.1f,%5.1f,%5.1f)\" % (world.imu_sensor.accelerometer), # \"Gyroscop: (%5.1f,%5.1f,%5.1f)\" % (world.imu_sensor.gyroscope), \"Location: % 20s \" % ( \"( % 5.1f , % 5.1f )\" % ( t . location . x , t . location . y )), \"GNSS: % 24s \" % ( \"( % 2.6f , % 3.6f )\" % ( world . gnss_sensor . lat , world . gnss_sensor . lon )), \"Height: % 18.0f m\" % t . location . z , \"\" , ] if isinstance ( c , carla . VehicleControl ): self . _info_text += [ ( \"Throttle:\" , c . throttle , 0.0 , 1.0 ), ( \"Steer:\" , c . steer , - 1.0 , 1.0 ), ( \"Brake:\" , c . brake , 0.0 , 1.0 ), ( \"Reverse:\" , c . reverse ), ( \"Hand brake:\" , c . hand_brake ), ( \"Manual:\" , c . manual_gear_shift ), \"Gear: %s \" % { - 1 : \"R\" , 0 : \"N\" } . get ( c . gear , c . gear ), ] elif isinstance ( c , carla . WalkerControl ): self . _info_text += [( \"Speed:\" , c . speed , 0.0 , 5.556 ), ( \"Jump:\" , c . jump )] self . _info_text += [ \"\" , \"Collision:\" , collision , \"\" , \"Number of vehicles: % 8d \" % len ( vehicles ), ] if len ( vehicles ) > 1 : self . _info_text += [ \"Nearby vehicles:\" ] distance = lambda l : math . sqrt ( ( l . x - t . location . x ) ** 2 + ( l . y - t . location . y ) ** 2 + ( l . z - t . location . z ) ** 2 ) vehicles = [ ( distance ( x . get_location ()), x ) for x in vehicles if x . id != world . player . id ] for d , vehicle in sorted ( vehicles ): if d > 200.0 : break vehicle_type = get_actor_display_name ( vehicle , truncate = 22 ) self . _info_text . append ( \" % 4d m %s \" % ( d , vehicle_type ))","title":"tick()"},{"location":"code_documentations/ROAR_Sim/hud/#ROAR_Sim.carla_client.util.hud.HUD.toggle_info","text":"Source code in carla_client/util/hud.py def toggle_info ( self ): self . _show_info = not self . _show_info","title":"toggle_info()"},{"location":"code_documentations/ROAR_Sim/kbc/","text":"Welcome to CARLA manual control. Use ARROWS or WASD keys for control. W : throttle S : brake A/D : steer left/right Q : toggle reverse Space : hand-brake P : toggle autopilot M : toggle manual transmission ,/. : gear up/down L : toggle next light type SHIFT + L : toggle high beam Z/X : toggle right/left blinker I : toggle interior light TAB : change sensor position [1-9] : change to sensor [1-9] G : toggle radar visualization R : toggle recording images to disk CTRL + R : toggle recording of simulation (replacing any previous) F1 : toggle HUD ESC : quit KeyboardControl \u00a4 Class that handles keyboard input. __init__ ( self , world , carla_setting ) special \u00a4 Source code in carla_client/util/keyboard_control.py def __init__ ( self , world , carla_setting : CarlaConfig ): self . logger = logging . getLogger ( __name__ ) if carla_setting . print_keyboard_hint : print ( __doc__ ) print () if isinstance ( world . player , carla . Vehicle ): self . _control = carla . VehicleControl () self . _lights = carla . VehicleLightState . NONE world . player . set_light_state ( self . _lights ) elif isinstance ( world . player , carla . Walker ): self . _control = carla . WalkerControl () self . _rotation = world . player . get_transform () . rotation else : raise NotImplementedError ( \"Actor type not supported\" ) self . _steer_cache = 0.0 self . logger . debug ( \"Keyboard Control initiated\" ) parse_events ( self , client , world , clock ) \u00a4 Parse keyboard press. :param client: carla.Client :param world: carla.Client :param clock: pygame clock :return: bool - True if should continue, aka no exit key was pressed control - carla.VehicleControl Source code in carla_client/util/keyboard_control.py def parse_events ( self , client , world , clock ) -> \\ Tuple [ bool , carla . VehicleControl ]: \"\"\" Parse keyboard press. :param client: carla.Client :param world: carla.Client :param clock: pygame clock :return: bool - True if should continue, aka no exit key was pressed control - carla.VehicleControl \"\"\" if isinstance ( self . _control , carla . VehicleControl ): current_lights = self . _lights for event in pygame . event . get (): if event . type == pygame . QUIT : return False , None elif event . type == pygame . KEYUP : if self . _is_quit_shortcut ( event . key ): return False , None elif event . key == K_F1 : world . hud . toggle_info () elif event . key == K_h or ( event . key == K_SLASH and pygame . key . get_mods () & KMOD_SHIFT ): world . hud . help . toggle () elif event . key == K_TAB : world . camera_manager . toggle_camera () elif event . key == K_g : world . toggle_radar () elif event . key > K_0 and event . key <= K_9 : world . camera_manager . set_sensor ( event . key - 1 - K_0 ) elif event . key == K_r and not ( pygame . key . get_mods () & KMOD_CTRL ): world . camera_manager . toggle_recording () elif event . key == K_r : if world . recording_enabled : client . stop_recorder () world . recording_enabled = False world . hud . notification ( \"Recorder is OFF\" ) else : client . start_recorder ( \"manual_recording.rec\" ) world . recording_enabled = True world . hud . notification ( \"Recorder is ON\" ) if isinstance ( self . _control , carla . VehicleControl ): if event . key == K_q : self . _control . gear = 1 if self . _control . reverse else - 1 elif event . key == K_m : self . _control . manual_gear_shift = ( not self . _control . manual_gear_shift ) self . _control . gear = world . player . get_control () . gear world . hud . notification ( \" %s Transmission\" % ( \"Manual\" if self . _control . manual_gear_shift else \"Automatic\" ) ) elif self . _control . manual_gear_shift and event . key == K_COMMA : self . _control . gear = max ( - 1 , self . _control . gear - 1 ) elif self . _control . manual_gear_shift and event . key == K_PERIOD : self . _control . gear = self . _control . gear + 1 elif event . key == K_l and pygame . key . get_mods () & KMOD_CTRL : current_lights ^= carla . VehicleLightState . Special1 elif event . key == K_l and pygame . key . get_mods () & KMOD_SHIFT : current_lights ^= carla . VehicleLightState . HighBeam elif event . key == K_l : # Use 'L' key to switch between lights: # closed -> position -> low beam -> fog if not self . _lights & carla . VehicleLightState . Position : world . hud . notification ( \"Position lights\" ) current_lights |= carla . VehicleLightState . Position else : world . hud . notification ( \"Low beam lights\" ) current_lights |= carla . VehicleLightState . LowBeam if self . _lights & carla . VehicleLightState . LowBeam : world . hud . notification ( \"Fog lights\" ) current_lights |= carla . VehicleLightState . Fog if self . _lights & carla . VehicleLightState . Fog : world . hud . notification ( \"Lights off\" ) current_lights ^= carla . VehicleLightState . Position current_lights ^= carla . VehicleLightState . LowBeam current_lights ^= carla . VehicleLightState . Fog elif event . key == K_i : current_lights ^= carla . VehicleLightState . Interior elif event . key == K_z : current_lights ^= carla . VehicleLightState . LeftBlinker elif event . key == K_x : current_lights ^= carla . VehicleLightState . RightBlinker if isinstance ( self . _control , carla . VehicleControl ): self . _parse_vehicle_keys ( pygame . key . get_pressed (), clock . get_time ()) self . _control . reverse = self . _control . gear < 0 # Set automatic control-related vehicle lights if self . _control . brake : current_lights |= carla . VehicleLightState . Brake else : # Remove the Brake flag current_lights &= carla . VehicleLightState . All ^ carla . VehicleLightState . Brake if self . _control . reverse : current_lights |= carla . VehicleLightState . Reverse else : # Remove the Reverse flag current_lights &= carla . VehicleLightState . All ^ carla . VehicleLightState . Reverse if current_lights != self . _lights : # Change the light state only if necessary self . _lights = current_lights world . player . set_light_state ( carla . VehicleLightState ( self . _lights )) elif isinstance ( self . _control , carla . WalkerControl ): self . _parse_walker_keys ( pygame . key . get_pressed (), clock . get_time (), world ) return True , self . _control","title":"Keyboard Controls"},{"location":"code_documentations/ROAR_Sim/kbc/#ROAR_Sim.carla_client.util.keyboard_control.KeyboardControl","text":"Class that handles keyboard input.","title":"KeyboardControl"},{"location":"code_documentations/ROAR_Sim/kbc/#ROAR_Sim.carla_client.util.keyboard_control.KeyboardControl.__init__","text":"Source code in carla_client/util/keyboard_control.py def __init__ ( self , world , carla_setting : CarlaConfig ): self . logger = logging . getLogger ( __name__ ) if carla_setting . print_keyboard_hint : print ( __doc__ ) print () if isinstance ( world . player , carla . Vehicle ): self . _control = carla . VehicleControl () self . _lights = carla . VehicleLightState . NONE world . player . set_light_state ( self . _lights ) elif isinstance ( world . player , carla . Walker ): self . _control = carla . WalkerControl () self . _rotation = world . player . get_transform () . rotation else : raise NotImplementedError ( \"Actor type not supported\" ) self . _steer_cache = 0.0 self . logger . debug ( \"Keyboard Control initiated\" )","title":"__init__()"},{"location":"code_documentations/ROAR_Sim/kbc/#ROAR_Sim.carla_client.util.keyboard_control.KeyboardControl.parse_events","text":"Parse keyboard press. :param client: carla.Client :param world: carla.Client :param clock: pygame clock :return: bool - True if should continue, aka no exit key was pressed control - carla.VehicleControl Source code in carla_client/util/keyboard_control.py def parse_events ( self , client , world , clock ) -> \\ Tuple [ bool , carla . VehicleControl ]: \"\"\" Parse keyboard press. :param client: carla.Client :param world: carla.Client :param clock: pygame clock :return: bool - True if should continue, aka no exit key was pressed control - carla.VehicleControl \"\"\" if isinstance ( self . _control , carla . VehicleControl ): current_lights = self . _lights for event in pygame . event . get (): if event . type == pygame . QUIT : return False , None elif event . type == pygame . KEYUP : if self . _is_quit_shortcut ( event . key ): return False , None elif event . key == K_F1 : world . hud . toggle_info () elif event . key == K_h or ( event . key == K_SLASH and pygame . key . get_mods () & KMOD_SHIFT ): world . hud . help . toggle () elif event . key == K_TAB : world . camera_manager . toggle_camera () elif event . key == K_g : world . toggle_radar () elif event . key > K_0 and event . key <= K_9 : world . camera_manager . set_sensor ( event . key - 1 - K_0 ) elif event . key == K_r and not ( pygame . key . get_mods () & KMOD_CTRL ): world . camera_manager . toggle_recording () elif event . key == K_r : if world . recording_enabled : client . stop_recorder () world . recording_enabled = False world . hud . notification ( \"Recorder is OFF\" ) else : client . start_recorder ( \"manual_recording.rec\" ) world . recording_enabled = True world . hud . notification ( \"Recorder is ON\" ) if isinstance ( self . _control , carla . VehicleControl ): if event . key == K_q : self . _control . gear = 1 if self . _control . reverse else - 1 elif event . key == K_m : self . _control . manual_gear_shift = ( not self . _control . manual_gear_shift ) self . _control . gear = world . player . get_control () . gear world . hud . notification ( \" %s Transmission\" % ( \"Manual\" if self . _control . manual_gear_shift else \"Automatic\" ) ) elif self . _control . manual_gear_shift and event . key == K_COMMA : self . _control . gear = max ( - 1 , self . _control . gear - 1 ) elif self . _control . manual_gear_shift and event . key == K_PERIOD : self . _control . gear = self . _control . gear + 1 elif event . key == K_l and pygame . key . get_mods () & KMOD_CTRL : current_lights ^= carla . VehicleLightState . Special1 elif event . key == K_l and pygame . key . get_mods () & KMOD_SHIFT : current_lights ^= carla . VehicleLightState . HighBeam elif event . key == K_l : # Use 'L' key to switch between lights: # closed -> position -> low beam -> fog if not self . _lights & carla . VehicleLightState . Position : world . hud . notification ( \"Position lights\" ) current_lights |= carla . VehicleLightState . Position else : world . hud . notification ( \"Low beam lights\" ) current_lights |= carla . VehicleLightState . LowBeam if self . _lights & carla . VehicleLightState . LowBeam : world . hud . notification ( \"Fog lights\" ) current_lights |= carla . VehicleLightState . Fog if self . _lights & carla . VehicleLightState . Fog : world . hud . notification ( \"Lights off\" ) current_lights ^= carla . VehicleLightState . Position current_lights ^= carla . VehicleLightState . LowBeam current_lights ^= carla . VehicleLightState . Fog elif event . key == K_i : current_lights ^= carla . VehicleLightState . Interior elif event . key == K_z : current_lights ^= carla . VehicleLightState . LeftBlinker elif event . key == K_x : current_lights ^= carla . VehicleLightState . RightBlinker if isinstance ( self . _control , carla . VehicleControl ): self . _parse_vehicle_keys ( pygame . key . get_pressed (), clock . get_time ()) self . _control . reverse = self . _control . gear < 0 # Set automatic control-related vehicle lights if self . _control . brake : current_lights |= carla . VehicleLightState . Brake else : # Remove the Brake flag current_lights &= carla . VehicleLightState . All ^ carla . VehicleLightState . Brake if self . _control . reverse : current_lights |= carla . VehicleLightState . Reverse else : # Remove the Reverse flag current_lights &= carla . VehicleLightState . All ^ carla . VehicleLightState . Reverse if current_lights != self . _lights : # Change the light state only if necessary self . _lights = current_lights world . player . set_light_state ( carla . VehicleLightState ( self . _lights )) elif isinstance ( self . _control , carla . WalkerControl ): self . _parse_walker_keys ( pygame . key . get_pressed (), clock . get_time (), world ) return True , self . _control","title":"parse_events()"},{"location":"code_documentations/ROAR_Sim/sensors/","text":"CollisionSensor \u00a4 __init__ ( self , parent_actor , hud ) special \u00a4 Source code in carla_client/util/sensors.py def __init__ ( self , parent_actor , hud ): self . sensor = None self . history = [] self . _parent = parent_actor self . hud = hud world = self . _parent . get_world () bp = world . get_blueprint_library () . find ( \"sensor.other.collision\" ) self . sensor = world . spawn_actor ( bp , carla . Transform (), attach_to = self . _parent ) # We need to pass the lambda a weak reference to self to avoid circular # reference. weak_self = weakref . ref ( self ) self . sensor . listen ( lambda event : CollisionSensor . _on_collision ( weak_self , event ) ) get_collision_history ( self ) \u00a4 Source code in carla_client/util/sensors.py def get_collision_history ( self ): history = collections . defaultdict ( int ) for frame , intensity in self . history : history [ frame ] += intensity return history GnssSensor \u00a4 __init__ ( self , parent_actor ) special \u00a4 Source code in carla_client/util/sensors.py def __init__ ( self , parent_actor ): self . sensor = None self . _parent = parent_actor self . lat = 0.0 self . lon = 0.0 world = self . _parent . get_world () bp = world . get_blueprint_library () . find ( \"sensor.other.gnss\" ) self . sensor = world . spawn_actor ( bp , carla . Transform ( carla . Location ( x = 1.0 , z = 2.8 )), attach_to = self . _parent ) # We need to pass the lambda a weak reference to self to avoid circular # reference. weak_self = weakref . ref ( self ) self . sensor . listen ( lambda event : GnssSensor . _on_gnss_event ( weak_self , event )) IMUSensor \u00a4 __init__ ( self , parent_actor ) special \u00a4 Source code in carla_client/util/sensors.py def __init__ ( self , parent_actor ): self . sensor = None self . _parent = parent_actor self . accelerometer = ( 0.0 , 0.0 , 0.0 ) self . gyroscope = ( 0.0 , 0.0 , 0.0 ) self . compass = 0.0 world = self . _parent . get_world () bp = world . get_blueprint_library () . find ( \"sensor.other.imu\" ) self . sensor = world . spawn_actor ( bp , carla . Transform (), attach_to = self . _parent ) # We need to pass the lambda a weak reference to self to avoid circular # reference. weak_self = weakref . ref ( self ) self . sensor . listen ( lambda sensor_data : IMUSensor . _IMU_callback ( weak_self , sensor_data ) ) LaneInvasionSensor \u00a4 __init__ ( self , parent_actor , hud ) special \u00a4 Source code in carla_client/util/sensors.py def __init__ ( self , parent_actor , hud ): self . sensor = None self . _parent = parent_actor self . hud = hud world = self . _parent . get_world () bp = world . get_blueprint_library () . find ( \"sensor.other.lane_invasion\" ) self . sensor = world . spawn_actor ( bp , carla . Transform (), attach_to = self . _parent ) # We need to pass the lambda a weak reference to self to avoid circular # reference. weak_self = weakref . ref ( self ) self . sensor . listen ( lambda event : LaneInvasionSensor . _on_invasion ( weak_self , event ) ) RadarSensor \u00a4 __init__ ( self , parent_actor ) special \u00a4 Source code in carla_client/util/sensors.py def __init__ ( self , parent_actor ): self . sensor = None self . _parent = parent_actor self . velocity_range = 7.5 # m/s world = self . _parent . get_world () self . debug = world . debug bp = world . get_blueprint_library () . find ( \"sensor.other.radar\" ) bp . set_attribute ( \"horizontal_fov\" , str ( 35 )) bp . set_attribute ( \"vertical_fov\" , str ( 20 )) self . sensor = world . spawn_actor ( bp , carla . Transform ( carla . Location ( x = 2.8 , z = 1.0 ), carla . Rotation ( pitch = 5 )), attach_to = self . _parent , ) # We need a weak reference to self to avoid circular reference. weak_self = weakref . ref ( self ) self . sensor . listen ( lambda radar_data : RadarSensor . _Radar_callback ( weak_self , radar_data ) )","title":"Sensors"},{"location":"code_documentations/ROAR_Sim/sensors/#ROAR_Sim.carla_client.util.sensors.CollisionSensor","text":"","title":"CollisionSensor"},{"location":"code_documentations/ROAR_Sim/sensors/#ROAR_Sim.carla_client.util.sensors.CollisionSensor.__init__","text":"Source code in carla_client/util/sensors.py def __init__ ( self , parent_actor , hud ): self . sensor = None self . history = [] self . _parent = parent_actor self . hud = hud world = self . _parent . get_world () bp = world . get_blueprint_library () . find ( \"sensor.other.collision\" ) self . sensor = world . spawn_actor ( bp , carla . Transform (), attach_to = self . _parent ) # We need to pass the lambda a weak reference to self to avoid circular # reference. weak_self = weakref . ref ( self ) self . sensor . listen ( lambda event : CollisionSensor . _on_collision ( weak_self , event ) )","title":"__init__()"},{"location":"code_documentations/ROAR_Sim/sensors/#ROAR_Sim.carla_client.util.sensors.CollisionSensor.get_collision_history","text":"Source code in carla_client/util/sensors.py def get_collision_history ( self ): history = collections . defaultdict ( int ) for frame , intensity in self . history : history [ frame ] += intensity return history","title":"get_collision_history()"},{"location":"code_documentations/ROAR_Sim/sensors/#ROAR_Sim.carla_client.util.sensors.GnssSensor","text":"","title":"GnssSensor"},{"location":"code_documentations/ROAR_Sim/sensors/#ROAR_Sim.carla_client.util.sensors.GnssSensor.__init__","text":"Source code in carla_client/util/sensors.py def __init__ ( self , parent_actor ): self . sensor = None self . _parent = parent_actor self . lat = 0.0 self . lon = 0.0 world = self . _parent . get_world () bp = world . get_blueprint_library () . find ( \"sensor.other.gnss\" ) self . sensor = world . spawn_actor ( bp , carla . Transform ( carla . Location ( x = 1.0 , z = 2.8 )), attach_to = self . _parent ) # We need to pass the lambda a weak reference to self to avoid circular # reference. weak_self = weakref . ref ( self ) self . sensor . listen ( lambda event : GnssSensor . _on_gnss_event ( weak_self , event ))","title":"__init__()"},{"location":"code_documentations/ROAR_Sim/sensors/#ROAR_Sim.carla_client.util.sensors.IMUSensor","text":"","title":"IMUSensor"},{"location":"code_documentations/ROAR_Sim/sensors/#ROAR_Sim.carla_client.util.sensors.IMUSensor.__init__","text":"Source code in carla_client/util/sensors.py def __init__ ( self , parent_actor ): self . sensor = None self . _parent = parent_actor self . accelerometer = ( 0.0 , 0.0 , 0.0 ) self . gyroscope = ( 0.0 , 0.0 , 0.0 ) self . compass = 0.0 world = self . _parent . get_world () bp = world . get_blueprint_library () . find ( \"sensor.other.imu\" ) self . sensor = world . spawn_actor ( bp , carla . Transform (), attach_to = self . _parent ) # We need to pass the lambda a weak reference to self to avoid circular # reference. weak_self = weakref . ref ( self ) self . sensor . listen ( lambda sensor_data : IMUSensor . _IMU_callback ( weak_self , sensor_data ) )","title":"__init__()"},{"location":"code_documentations/ROAR_Sim/sensors/#ROAR_Sim.carla_client.util.sensors.LaneInvasionSensor","text":"","title":"LaneInvasionSensor"},{"location":"code_documentations/ROAR_Sim/sensors/#ROAR_Sim.carla_client.util.sensors.LaneInvasionSensor.__init__","text":"Source code in carla_client/util/sensors.py def __init__ ( self , parent_actor , hud ): self . sensor = None self . _parent = parent_actor self . hud = hud world = self . _parent . get_world () bp = world . get_blueprint_library () . find ( \"sensor.other.lane_invasion\" ) self . sensor = world . spawn_actor ( bp , carla . Transform (), attach_to = self . _parent ) # We need to pass the lambda a weak reference to self to avoid circular # reference. weak_self = weakref . ref ( self ) self . sensor . listen ( lambda event : LaneInvasionSensor . _on_invasion ( weak_self , event ) )","title":"__init__()"},{"location":"code_documentations/ROAR_Sim/sensors/#ROAR_Sim.carla_client.util.sensors.RadarSensor","text":"","title":"RadarSensor"},{"location":"code_documentations/ROAR_Sim/sensors/#ROAR_Sim.carla_client.util.sensors.RadarSensor.__init__","text":"Source code in carla_client/util/sensors.py def __init__ ( self , parent_actor ): self . sensor = None self . _parent = parent_actor self . velocity_range = 7.5 # m/s world = self . _parent . get_world () self . debug = world . debug bp = world . get_blueprint_library () . find ( \"sensor.other.radar\" ) bp . set_attribute ( \"horizontal_fov\" , str ( 35 )) bp . set_attribute ( \"vertical_fov\" , str ( 20 )) self . sensor = world . spawn_actor ( bp , carla . Transform ( carla . Location ( x = 2.8 , z = 1.0 ), carla . Rotation ( pitch = 5 )), attach_to = self . _parent , ) # We need a weak reference to self to avoid circular reference. weak_self = weakref . ref ( self ) self . sensor . listen ( lambda radar_data : RadarSensor . _Radar_callback ( weak_self , radar_data ) )","title":"__init__()"},{"location":"code_documentations/ROAR_Sim/util/","text":"CarlaCarColor pydantic-model \u00a4 a : int pydantic-field \u00a4 b : int pydantic-field \u00a4 g : int pydantic-field \u00a4 r : int pydantic-field \u00a4 __config__ \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 to_string ( self , * args , ** kwargs ) \u00a4 Source code in carla_client/util/utilities.py def to_string ( self , * args , ** kwargs ): return f \" { self . r } , { self . g } , { self . b } \" CarlaCarColors \u00a4 BLACK : CarlaCarColor \u00a4 BLUE : CarlaCarColor \u00a4 GREEN : CarlaCarColor \u00a4 GREY : CarlaCarColor \u00a4 RED : CarlaCarColor \u00a4 WHITE : CarlaCarColor \u00a4 CarlaWeather pydantic-model \u00a4 Default weather is sunny cloudiness : float pydantic-field \u00a4 fog_density : float pydantic-field \u00a4 fog_distance : float pydantic-field \u00a4 precipitation : float pydantic-field \u00a4 precipitation_deposits : float pydantic-field \u00a4 sun_altitude_angle : float pydantic-field \u00a4 sun_azimuth_angle : float pydantic-field \u00a4 wetness : float pydantic-field \u00a4 wind_intensity : float pydantic-field \u00a4 __config__ \u00a4 __json_encoder__ ( obj ) special staticmethod \u00a4 to_carla_weather_params ( self ) \u00a4 Source code in carla_client/util/utilities.py def to_carla_weather_params ( self ): return carla . WeatherParameters ( cloudiness = self . cloudiness , precipitation = self . precipitation , precipitation_deposits = self . precipitation_deposits , wind_intensity = self . wind_intensity , sun_azimuth_angle = self . sun_azimuth_angle , sun_altitude_angle = self . sun_altitude_angle , fog_density = self . fog_density , fog_distance = self . fog_distance , wetness = self . wetness , ) CarlaWeathers \u00a4 create_dir_if_not_exist ( path ) \u00a4 Source code in carla_client/util/utilities.py def create_dir_if_not_exist ( path : Path ): if not path . exists (): path . mkdir ( parents = True , exist_ok = True ) get_actor_display_name ( actor , truncate = 250 ) \u00a4 Source code in carla_client/util/utilities.py def get_actor_display_name ( actor , truncate = 250 ): name = \" \" . join ( actor . type_id . replace ( \"_\" , \".\" ) . title () . split ( \".\" )[ 1 :]) return ( name [: truncate - 1 ] + \" \\u2026 \" ) if len ( name ) > truncate else name","title":"Utilities"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColor","text":"","title":"CarlaCarColor"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColor.a","text":"","title":"a"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColor.b","text":"","title":"b"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColor.g","text":"","title":"g"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColor.r","text":"","title":"r"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColor.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColor.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColor.to_string","text":"Source code in carla_client/util/utilities.py def to_string ( self , * args , ** kwargs ): return f \" { self . r } , { self . g } , { self . b } \"","title":"to_string()"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColors","text":"","title":"CarlaCarColors"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColors.BLACK","text":"","title":"BLACK"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColors.BLUE","text":"","title":"BLUE"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColors.GREEN","text":"","title":"GREEN"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColors.GREY","text":"","title":"GREY"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColors.RED","text":"","title":"RED"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaCarColors.WHITE","text":"","title":"WHITE"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeather","text":"Default weather is sunny","title":"CarlaWeather"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeather.cloudiness","text":"","title":"cloudiness"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeather.fog_density","text":"","title":"fog_density"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeather.fog_distance","text":"","title":"fog_distance"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeather.precipitation","text":"","title":"precipitation"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeather.precipitation_deposits","text":"","title":"precipitation_deposits"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeather.sun_altitude_angle","text":"","title":"sun_altitude_angle"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeather.sun_azimuth_angle","text":"","title":"sun_azimuth_angle"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeather.wetness","text":"","title":"wetness"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeather.wind_intensity","text":"","title":"wind_intensity"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeather.__config__","text":"","title":"__config__"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeather.__json_encoder__","text":"","title":"__json_encoder__()"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeather.to_carla_weather_params","text":"Source code in carla_client/util/utilities.py def to_carla_weather_params ( self ): return carla . WeatherParameters ( cloudiness = self . cloudiness , precipitation = self . precipitation , precipitation_deposits = self . precipitation_deposits , wind_intensity = self . wind_intensity , sun_azimuth_angle = self . sun_azimuth_angle , sun_altitude_angle = self . sun_altitude_angle , fog_density = self . fog_density , fog_distance = self . fog_distance , wetness = self . wetness , )","title":"to_carla_weather_params()"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.CarlaWeathers","text":"","title":"CarlaWeathers"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.create_dir_if_not_exist","text":"Source code in carla_client/util/utilities.py def create_dir_if_not_exist ( path : Path ): if not path . exists (): path . mkdir ( parents = True , exist_ok = True )","title":"create_dir_if_not_exist()"},{"location":"code_documentations/ROAR_Sim/util/#ROAR_Sim.carla_client.util.utilities.get_actor_display_name","text":"Source code in carla_client/util/utilities.py def get_actor_display_name ( actor , truncate = 250 ): name = \" \" . join ( actor . type_id . replace ( \"_\" , \".\" ) . title () . split ( \".\" )[ 1 :]) return ( name [: truncate - 1 ] + \" \\u2026 \" ) if len ( name ) > truncate else name","title":"get_actor_display_name()"},{"location":"code_documentations/ROAR_Sim/world/","text":"World \u00a4 An World that holds all display settings __init__ ( self , carla_world , hud , carla_settings , agent_settings ) special \u00a4 Create a World with the given carla_world, head-up display and server setting. Source code in carla_client/util/world.py def __init__ ( self , carla_world : carla . World , hud : HUD , carla_settings : CarlaConfig , agent_settings : AgentConfig ): \"\"\"Create a World with the given carla_world, head-up display and server setting.\"\"\" self . logger = logging . getLogger ( __name__ ) self . carla_settings : CarlaConfig = carla_settings self . agent_settings : AgentConfig = agent_settings self . carla_world : carla . World = carla_world self . clean_spawned_all_actors () self . actor_role_name = carla_settings . role_name try : self . map = self . carla_world . get_map () except RuntimeError as error : print ( 'RuntimeError: {} ' . format ( error )) print ( ' The server could not send the OpenDRIVE (.xodr) file:' ) print ( ' Make sure it exists, has the same name of your town, ' 'and is correct.' ) sys . exit ( 1 ) self . hud = hud self . carla_bridge = CarlaBridge () self . _spawn_point_id = agent_settings . spawn_point_id self . _actor_filter = carla_settings . carla_vehicle_blueprint_filter self . _car_color = carla_settings . car_color self . _gamma = carla_settings . gamma self . player = None self . collision_sensor = None self . lane_invasion_sensor = None self . gnss_sensor = None self . imu_sensor = None self . radar_sensor = None self . camera_manager = None self . recording_enabled = False self . time_counter = 0 self . front_rgb_sensor = None self . front_depth_sensor = None self . rear_rgb_sensor = None self . semantic_segmentation_sensor = None self . recording_start = 0 # set weather self . logger . debug ( \"Setting Weather\" ) self . set_weather ( carla_settings . carla_weather . to_carla_weather_params ()) # set player self . logger . debug ( \"Setting Player\" ) self . player = self . spawn_actor ( actor_filter = self . _actor_filter , player_role_name = self . actor_role_name , color = self . _car_color , spawn_point_id = self . _spawn_point_id , ) # set camera self . logger . debug ( \"Setting Camera\" ) self . set_camera () # set sensor self . logger . debug ( \"Setting Default Sensor\" ) self . set_sensor () # set custom sensor self . logger . debug ( \"Setting Custom Sensor\" ) self . set_custom_sensor () self . front_rgb_sensor_data = None self . front_depth_sensor_data = None self . rear_rgb_sensor_data = None self . semantic_segmentation_sensor_data = None # spawn npc self . npcs_mapping : Dict [ str , Tuple [ Any , AgentConfig ]] = {} settings = self . carla_world . get_settings () settings . synchronous_mode = self . carla_settings . synchronous_mode settings . no_rendering_mode = self . carla_settings . no_rendering_mode if self . carla_settings . synchronous_mode : settings . fixed_delta_seconds = self . carla_settings . fixed_delta_seconds self . carla_world . apply_settings ( settings ) self . carla_world . on_tick ( hud . on_world_tick ) self . logger . debug ( \"World Initialized\" ) clean_spawned_all_actors ( self ) \u00a4 This function is to clean all actors that are not traffic light/signals Source code in carla_client/util/world.py def clean_spawned_all_actors ( self ): \"\"\" This function is to clean all actors that are not traffic light/signals Returns: \"\"\" for actor in self . carla_world . get_actors (): if \"traffic\" not in actor . type_id and \"spectator\" not in actor . type_id : actor . destroy () destroy ( self ) \u00a4 Source code in carla_client/util/world.py def destroy ( self ): self . logger . debug ( f \"destroying all actors belonging to \" f \"[ { self . actor_role_name } ] in this world\" ) # if self.radar_sensor is not None: # self.toggle_radar() actors = [ self . camera_manager . sensor , self . collision_sensor . sensor , self . lane_invasion_sensor . sensor , self . gnss_sensor . sensor , self . imu_sensor . sensor , self . player , ] for actor in actors : if actor is not None : actor . destroy () self . _destroy_custom_sensors () for npc , _ in self . npcs_mapping . values (): npc . destroy () destroy_sensors ( self ) \u00a4 Source code in carla_client/util/world.py def destroy_sensors ( self ): self . camera_manager . sensor . destroy () self . camera_manager . sensor = None self . camera_manager . index = None render ( self , display ) \u00a4 Source code in carla_client/util/world.py def render ( self , display ): self . camera_manager . render ( display ) self . hud . render ( display ) set_camera ( self , cam_index = 0 , cam_pos_index = 0 ) \u00a4 Source code in carla_client/util/world.py def set_camera ( self , cam_index : int = 0 , cam_pos_index : int = 0 ): self . camera_manager = CameraManager ( self . player , self . hud , self . _gamma ) self . camera_manager . transform_index = cam_pos_index self . camera_manager . set_sensor ( cam_index , notify = False ) actor_type = get_actor_display_name ( self . player ) self . hud . notification ( actor_type ) set_custom_sensor ( self ) \u00a4 Source code in carla_client/util/world.py def set_custom_sensor ( self ): Attachment = carla . AttachmentType self . _destroy_custom_sensors () self . front_rgb_sensor = self . _spawn_custom_sensor ( blueprint_filter = \"sensor.camera.rgb\" , transform = self . carla_bridge . convert_transform_from_agent_to_source ( self . agent_settings . front_rgb_cam . transform ), attachment = Attachment . Rigid , attributes = { \"fov\" : self . agent_settings . front_rgb_cam . fov , }) self . front_depth_sensor = self . _spawn_custom_sensor ( blueprint_filter = \"sensor.camera.depth\" , transform = self . carla_bridge . convert_transform_from_agent_to_source ( self . agent_settings . front_depth_cam . transform ), attachment = Attachment . Rigid , attributes = { \"fov\" : self . agent_settings . front_depth_cam . fov , }) self . rear_rgb_sensor = \\ self . _spawn_custom_sensor ( blueprint_filter = \"sensor.camera.rgb\" , transform = self . carla_bridge . convert_transform_from_agent_to_source ( self . agent_settings . rear_rgb_cam . transform ), attachment = Attachment . Rigid , attributes = { \"fov\" : self . agent_settings . rear_rgb_cam . fov , }) if self . carla_settings . save_semantic_segmentation : self . semantic_segmentation_sensor = self . _spawn_custom_sensor ( blueprint_filter = \"sensor.camera.semantic_segmentation\" , transform = self . carla_bridge . convert_transform_from_agent_to_source ( self . agent_settings . front_depth_cam . transform ), attachment = Attachment . Rigid , attributes = { \"fov\" : self . agent_settings . front_depth_cam . fov }, ) weak_self = weakref . ref ( self ) self . front_rgb_sensor . listen ( lambda image : World . _parse_front_rgb_sensor_image ( weak_self = weak_self , image = image )) self . front_depth_sensor . listen ( lambda image : World . _parse_front_depth_sensor_image ( weak_self = weak_self , image = image )) self . rear_rgb_sensor . listen ( lambda image : World . _parse_rear_rgb_sensor_image ( weak_self = weak_self , image = image )) if self . carla_settings . save_semantic_segmentation : self . semantic_segmentation_sensor . listen ( lambda image : World . _parse_semantic_segmentation_image ( weak_self = weak_self , image = image )) set_sensor ( self ) \u00a4 Source code in carla_client/util/world.py def set_sensor ( self ): self . collision_sensor = CollisionSensor ( self . player , self . hud ) self . lane_invasion_sensor = LaneInvasionSensor ( self . player , self . hud ) self . gnss_sensor = GnssSensor ( self . player ) self . imu_sensor = IMUSensor ( self . player ) set_weather ( self , new_weather ) \u00a4 Source code in carla_client/util/world.py def set_weather ( self , new_weather : carla . WeatherParameters ): self . carla_world . weather = new_weather spawn_actor ( self , actor_filter = 'vehicle.tesla.model3' , player_role_name = 'npc' , color = CarlaCarColor ( r = 211 , g = 211 , b = 211 , a = 255 ), spawn_point_id = 1 ) \u00a4 Set up a hero-named player with Grey Tesla Model3 Vehicle Source code in carla_client/util/world.py def spawn_actor ( self , actor_filter : str = \"vehicle.tesla.model3\" , player_role_name : str = \"npc\" , color : CarlaCarColor = CarlaCarColors . GREY , spawn_point_id : int = random . choice ( list ( range ( 8 )))): \"\"\"Set up a hero-named player with Grey Tesla Model3 Vehicle \"\"\" blueprint = self . carla_world . get_blueprint_library () . find ( actor_filter ) blueprint . set_attribute ( \"role_name\" , player_role_name ) if blueprint . has_attribute ( \"color\" ): blueprint . set_attribute ( \"color\" , color . to_string ()) if blueprint . has_attribute ( \"is_invincible\" ): self . logger . debug ( \"TESLA IS INVINCIBLE\" ) blueprint . set_attribute ( \"is_invincible\" , \"true\" ) try : actor = \\ self . carla_world . spawn_actor ( blueprint , self . map . get_spawn_points ()[ spawn_point_id ]) return actor except Exception as e : raise ValueError ( f \"Cannot spawn actor at ID [ { spawn_point_id } ]. \" f \"Error: { e } \" ) spawn_npcs ( self , npc_configs ) \u00a4 Source code in carla_client/util/world.py def spawn_npcs ( self , npc_configs : List [ AgentConfig ]): for npc_config in npc_configs : self . logger . debug ( f \"Spawning NPC [ { npc_config . name } ]\" ) try : npc = self . spawn_actor ( spawn_point_id = npc_config . spawn_point_id ) self . npcs_mapping [ npc_config . name ] = ( npc , npc_config ) except Exception as e : self . logger . error ( f \"Failed to Spawn NPC { 'default' } .\" f \"Error: { e } \" ) tick ( self , clock ) \u00a4 Source code in carla_client/util/world.py def tick ( self , clock ): self . time_counter += 1 self . hud . tick ( self , clock ) if self . carla_settings . synchronous_mode : self . carla_world . tick () toggle_radar ( self ) \u00a4 Source code in carla_client/util/world.py def toggle_radar ( self ): if self . radar_sensor is None : self . radar_sensor = RadarSensor ( self . player ) elif self . radar_sensor . sensor is not None : self . radar_sensor . sensor . destroy () self . radar_sensor = None","title":"World"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World","text":"An World that holds all display settings","title":"World"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World.__init__","text":"Create a World with the given carla_world, head-up display and server setting. Source code in carla_client/util/world.py def __init__ ( self , carla_world : carla . World , hud : HUD , carla_settings : CarlaConfig , agent_settings : AgentConfig ): \"\"\"Create a World with the given carla_world, head-up display and server setting.\"\"\" self . logger = logging . getLogger ( __name__ ) self . carla_settings : CarlaConfig = carla_settings self . agent_settings : AgentConfig = agent_settings self . carla_world : carla . World = carla_world self . clean_spawned_all_actors () self . actor_role_name = carla_settings . role_name try : self . map = self . carla_world . get_map () except RuntimeError as error : print ( 'RuntimeError: {} ' . format ( error )) print ( ' The server could not send the OpenDRIVE (.xodr) file:' ) print ( ' Make sure it exists, has the same name of your town, ' 'and is correct.' ) sys . exit ( 1 ) self . hud = hud self . carla_bridge = CarlaBridge () self . _spawn_point_id = agent_settings . spawn_point_id self . _actor_filter = carla_settings . carla_vehicle_blueprint_filter self . _car_color = carla_settings . car_color self . _gamma = carla_settings . gamma self . player = None self . collision_sensor = None self . lane_invasion_sensor = None self . gnss_sensor = None self . imu_sensor = None self . radar_sensor = None self . camera_manager = None self . recording_enabled = False self . time_counter = 0 self . front_rgb_sensor = None self . front_depth_sensor = None self . rear_rgb_sensor = None self . semantic_segmentation_sensor = None self . recording_start = 0 # set weather self . logger . debug ( \"Setting Weather\" ) self . set_weather ( carla_settings . carla_weather . to_carla_weather_params ()) # set player self . logger . debug ( \"Setting Player\" ) self . player = self . spawn_actor ( actor_filter = self . _actor_filter , player_role_name = self . actor_role_name , color = self . _car_color , spawn_point_id = self . _spawn_point_id , ) # set camera self . logger . debug ( \"Setting Camera\" ) self . set_camera () # set sensor self . logger . debug ( \"Setting Default Sensor\" ) self . set_sensor () # set custom sensor self . logger . debug ( \"Setting Custom Sensor\" ) self . set_custom_sensor () self . front_rgb_sensor_data = None self . front_depth_sensor_data = None self . rear_rgb_sensor_data = None self . semantic_segmentation_sensor_data = None # spawn npc self . npcs_mapping : Dict [ str , Tuple [ Any , AgentConfig ]] = {} settings = self . carla_world . get_settings () settings . synchronous_mode = self . carla_settings . synchronous_mode settings . no_rendering_mode = self . carla_settings . no_rendering_mode if self . carla_settings . synchronous_mode : settings . fixed_delta_seconds = self . carla_settings . fixed_delta_seconds self . carla_world . apply_settings ( settings ) self . carla_world . on_tick ( hud . on_world_tick ) self . logger . debug ( \"World Initialized\" )","title":"__init__()"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World.clean_spawned_all_actors","text":"This function is to clean all actors that are not traffic light/signals Source code in carla_client/util/world.py def clean_spawned_all_actors ( self ): \"\"\" This function is to clean all actors that are not traffic light/signals Returns: \"\"\" for actor in self . carla_world . get_actors (): if \"traffic\" not in actor . type_id and \"spectator\" not in actor . type_id : actor . destroy ()","title":"clean_spawned_all_actors()"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World.destroy","text":"Source code in carla_client/util/world.py def destroy ( self ): self . logger . debug ( f \"destroying all actors belonging to \" f \"[ { self . actor_role_name } ] in this world\" ) # if self.radar_sensor is not None: # self.toggle_radar() actors = [ self . camera_manager . sensor , self . collision_sensor . sensor , self . lane_invasion_sensor . sensor , self . gnss_sensor . sensor , self . imu_sensor . sensor , self . player , ] for actor in actors : if actor is not None : actor . destroy () self . _destroy_custom_sensors () for npc , _ in self . npcs_mapping . values (): npc . destroy ()","title":"destroy()"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World.destroy_sensors","text":"Source code in carla_client/util/world.py def destroy_sensors ( self ): self . camera_manager . sensor . destroy () self . camera_manager . sensor = None self . camera_manager . index = None","title":"destroy_sensors()"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World.render","text":"Source code in carla_client/util/world.py def render ( self , display ): self . camera_manager . render ( display ) self . hud . render ( display )","title":"render()"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World.set_camera","text":"Source code in carla_client/util/world.py def set_camera ( self , cam_index : int = 0 , cam_pos_index : int = 0 ): self . camera_manager = CameraManager ( self . player , self . hud , self . _gamma ) self . camera_manager . transform_index = cam_pos_index self . camera_manager . set_sensor ( cam_index , notify = False ) actor_type = get_actor_display_name ( self . player ) self . hud . notification ( actor_type )","title":"set_camera()"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World.set_custom_sensor","text":"Source code in carla_client/util/world.py def set_custom_sensor ( self ): Attachment = carla . AttachmentType self . _destroy_custom_sensors () self . front_rgb_sensor = self . _spawn_custom_sensor ( blueprint_filter = \"sensor.camera.rgb\" , transform = self . carla_bridge . convert_transform_from_agent_to_source ( self . agent_settings . front_rgb_cam . transform ), attachment = Attachment . Rigid , attributes = { \"fov\" : self . agent_settings . front_rgb_cam . fov , }) self . front_depth_sensor = self . _spawn_custom_sensor ( blueprint_filter = \"sensor.camera.depth\" , transform = self . carla_bridge . convert_transform_from_agent_to_source ( self . agent_settings . front_depth_cam . transform ), attachment = Attachment . Rigid , attributes = { \"fov\" : self . agent_settings . front_depth_cam . fov , }) self . rear_rgb_sensor = \\ self . _spawn_custom_sensor ( blueprint_filter = \"sensor.camera.rgb\" , transform = self . carla_bridge . convert_transform_from_agent_to_source ( self . agent_settings . rear_rgb_cam . transform ), attachment = Attachment . Rigid , attributes = { \"fov\" : self . agent_settings . rear_rgb_cam . fov , }) if self . carla_settings . save_semantic_segmentation : self . semantic_segmentation_sensor = self . _spawn_custom_sensor ( blueprint_filter = \"sensor.camera.semantic_segmentation\" , transform = self . carla_bridge . convert_transform_from_agent_to_source ( self . agent_settings . front_depth_cam . transform ), attachment = Attachment . Rigid , attributes = { \"fov\" : self . agent_settings . front_depth_cam . fov }, ) weak_self = weakref . ref ( self ) self . front_rgb_sensor . listen ( lambda image : World . _parse_front_rgb_sensor_image ( weak_self = weak_self , image = image )) self . front_depth_sensor . listen ( lambda image : World . _parse_front_depth_sensor_image ( weak_self = weak_self , image = image )) self . rear_rgb_sensor . listen ( lambda image : World . _parse_rear_rgb_sensor_image ( weak_self = weak_self , image = image )) if self . carla_settings . save_semantic_segmentation : self . semantic_segmentation_sensor . listen ( lambda image : World . _parse_semantic_segmentation_image ( weak_self = weak_self , image = image ))","title":"set_custom_sensor()"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World.set_sensor","text":"Source code in carla_client/util/world.py def set_sensor ( self ): self . collision_sensor = CollisionSensor ( self . player , self . hud ) self . lane_invasion_sensor = LaneInvasionSensor ( self . player , self . hud ) self . gnss_sensor = GnssSensor ( self . player ) self . imu_sensor = IMUSensor ( self . player )","title":"set_sensor()"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World.set_weather","text":"Source code in carla_client/util/world.py def set_weather ( self , new_weather : carla . WeatherParameters ): self . carla_world . weather = new_weather","title":"set_weather()"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World.spawn_actor","text":"Set up a hero-named player with Grey Tesla Model3 Vehicle Source code in carla_client/util/world.py def spawn_actor ( self , actor_filter : str = \"vehicle.tesla.model3\" , player_role_name : str = \"npc\" , color : CarlaCarColor = CarlaCarColors . GREY , spawn_point_id : int = random . choice ( list ( range ( 8 )))): \"\"\"Set up a hero-named player with Grey Tesla Model3 Vehicle \"\"\" blueprint = self . carla_world . get_blueprint_library () . find ( actor_filter ) blueprint . set_attribute ( \"role_name\" , player_role_name ) if blueprint . has_attribute ( \"color\" ): blueprint . set_attribute ( \"color\" , color . to_string ()) if blueprint . has_attribute ( \"is_invincible\" ): self . logger . debug ( \"TESLA IS INVINCIBLE\" ) blueprint . set_attribute ( \"is_invincible\" , \"true\" ) try : actor = \\ self . carla_world . spawn_actor ( blueprint , self . map . get_spawn_points ()[ spawn_point_id ]) return actor except Exception as e : raise ValueError ( f \"Cannot spawn actor at ID [ { spawn_point_id } ]. \" f \"Error: { e } \" )","title":"spawn_actor()"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World.spawn_npcs","text":"Source code in carla_client/util/world.py def spawn_npcs ( self , npc_configs : List [ AgentConfig ]): for npc_config in npc_configs : self . logger . debug ( f \"Spawning NPC [ { npc_config . name } ]\" ) try : npc = self . spawn_actor ( spawn_point_id = npc_config . spawn_point_id ) self . npcs_mapping [ npc_config . name ] = ( npc , npc_config ) except Exception as e : self . logger . error ( f \"Failed to Spawn NPC { 'default' } .\" f \"Error: { e } \" )","title":"spawn_npcs()"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World.tick","text":"Source code in carla_client/util/world.py def tick ( self , clock ): self . time_counter += 1 self . hud . tick ( self , clock ) if self . carla_settings . synchronous_mode : self . carla_world . tick ()","title":"tick()"},{"location":"code_documentations/ROAR_Sim/world/#ROAR_Sim.carla_client.util.world.World.toggle_radar","text":"Source code in carla_client/util/world.py def toggle_radar ( self ): if self . radar_sensor is None : self . radar_sensor = RadarSensor ( self . player ) elif self . radar_sensor . sensor is not None : self . radar_sensor . sensor . destroy () self . radar_sensor = None","title":"toggle_radar()"}]}